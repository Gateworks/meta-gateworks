--- a/Makefile.am
+++ b/Makefile.am
@@ -811,7 +811,8 @@ if PLATFORM_IS_MX6X
 
 BASEDIRS = $(AIURDIRS) $(BEEPDIRS) $(V4LSINKDIRS)   \
            src/audio/audio_pp/src      \
-           src/misc/v4l_source/src
+           src/misc/v4l_source/src     \
+           src/misc/tvsrc/src
 
 if USE_VPU_WRAP
 VPUWRAPDIRS = src/video/vpu/src
--- a/configure.ac
+++ b/configure.ac
@@ -320,6 +320,7 @@ src/parser/aiur/src/Makefile
 src/parser/aiur/src/aiur_registry.arm11.cf
 src/parser/aiur/src/aiur_registry.arm9.cf
 src/misc/v4l_source/src/Makefile
+src/misc/tvsrc/src/Makefile
 src/misc/v4l_sink/src/Makefile
 src/misc/i_sink/src/Makefile
 tools/Makefile
--- /dev/null
+++ b/src/misc/tvsrc/src/Makefile.am
@@ -0,0 +1,14 @@
+if LTIBBUILD
+
+else
+FBHEADER_PATH=../../../../inc/misc
+endif
+
+plugin_LTLIBRARIES = libmfw_gst_tvsrc.la 
+
+libmfw_gst_tvsrc_la_SOURCES =  mfw_gst_tvsrc.c 
+libmfw_gst_tvsrc_la_CFLAGS = $(GST_BASE_CFLAGS) -fno-omit-frame-pointer $(IPU_CFLAGS) -D$(PLATFORM) -I$(FBHEADER_PATH) -I. -I../../../../inc/plugin -I../../../../libs/gstbufmeta 
+libmfw_gst_tvsrc_la_LIBADD = $(GST_BASE_LIBS) -lgstvideo-$(GST_MAJORMINOR) -lgstinterfaces-$(GST_MAJORMINOR) ../../../../libs/libgstfsl-@GST_MAJORMINOR@.la
+libmfw_gst_tvsrc_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+
+noinst_HEADERS = 
--- /dev/null
+++ b/src/misc/tvsrc/src/Makefile.in
@@ -0,0 +1,570 @@
+# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/misc/tvsrc/src
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__installdirs = "$(DESTDIR)$(plugindir)"
+LTLIBRARIES = $(plugin_LTLIBRARIES)
+am__DEPENDENCIES_1 =
+libmfw_gst_tvsrc_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \
+	../../../../libs/gstbufmeta/libgstbufmeta.la
+am_libmfw_gst_tvsrc_la_OBJECTS = libmfw_gst_tvsrc_la-mfw_gst_tvsrc.lo
+libmfw_gst_tvsrc_la_OBJECTS = $(am_libmfw_gst_tvsrc_la_OBJECTS)
+libmfw_gst_tvsrc_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(libmfw_gst_tvsrc_la_CFLAGS) $(CFLAGS) \
+	$(libmfw_gst_tvsrc_la_LDFLAGS) $(LDFLAGS) -o $@
+DEFAULT_INCLUDES = -I.@am__isrc@
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libmfw_gst_tvsrc_la_SOURCES)
+DIST_SOURCES = $(libmfw_gst_tvsrc_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+ACLOCAL_AMFLAGS = @ACLOCAL_AMFLAGS@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+FSL_MM_CORE_CFLAGS = @FSL_MM_CORE_CFLAGS@
+FSL_MM_CORE_LIBS = @FSL_MM_CORE_LIBS@
+GREP = @GREP@
+GSTMXLIBS_VERSION = @GSTMXLIBS_VERSION@
+GST_BASE_CFLAGS = @GST_BASE_CFLAGS@
+GST_BASE_LIBS = @GST_BASE_LIBS@
+GST_CFLAGS = @GST_CFLAGS@
+GST_LIBS = @GST_LIBS@
+GST_MAJORMINOR = @GST_MAJORMINOR@
+GST_PLUGINS_BASE_CFLAGS = @GST_PLUGINS_BASE_CFLAGS@
+GST_PLUGINS_BASE_LIBS = @GST_PLUGINS_BASE_LIBS@
+GST_PLUGIN_LDFLAGS = @GST_PLUGIN_LDFLAGS@
+HAVE_PKGCONFIG = @HAVE_PKGCONFIG@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+IPU_CFLAGS = @IPU_CFLAGS@
+IPU_LIBS = @IPU_LIBS@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MANIFEST_TOOL = @MANIFEST_TOOL@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
+PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
+PLATFORM = @PLATFORM@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+VPU_CFLAGS = @VPU_CFLAGS@
+VPU_LIBS = @VPU_LIBS@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+asf_arm11_SONAME = @asf_arm11_SONAME@
+asf_arm9_SONAME = @asf_arm9_SONAME@
+avi_arm11_SONAME = @avi_arm11_SONAME@
+avi_arm9_SONAME = @avi_arm9_SONAME@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+flv_arm11_SONAME = @flv_arm11_SONAME@
+flv_arm9_SONAME = @flv_arm9_SONAME@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+mkv_arm11_SONAME = @mkv_arm11_SONAME@
+mkv_arm9_SONAME = @mkv_arm9_SONAME@
+mp4_arm11_SONAME = @mp4_arm11_SONAME@
+mp4_arm9_SONAME = @mp4_arm9_SONAME@
+mpg2_arm11_SONAME = @mpg2_arm11_SONAME@
+mpg2_arm9_SONAME = @mpg2_arm9_SONAME@
+ogg_arm11_SONAME = @ogg_arm11_SONAME@
+ogg_arm9_SONAME = @ogg_arm9_SONAME@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+plugindir = @plugindir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+@LTIBBUILD_FALSE@FBHEADER_PATH = ../../../../inc/misc
+plugin_LTLIBRARIES = libmfw_gst_tvsrc.la 
+libmfw_gst_tvsrc_la_SOURCES = mfw_gst_tvsrc.c 
+libmfw_gst_tvsrc_la_CFLAGS = $(GST_BASE_CFLAGS) -fno-omit-frame-pointer $(IPU_CFLAGS) -D$(PLATFORM) -I$(FBHEADER_PATH) -I. -I../../../../inc/plugin -I../../../../libs/gstbufmeta 
+libmfw_gst_tvsrc_la_LIBADD = $(GST_BASE_LIBS) -lgstvideo-$(GST_MAJORMINOR) -lgstinterfaces-$(GST_MAJORMINOR) ../../../../libs/gstbufmeta/libgstbufmeta.la
+libmfw_gst_tvsrc_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+noinst_HEADERS = 
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu src/misc/tvsrc/src/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu src/misc/tvsrc/src/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+install-pluginLTLIBRARIES: $(plugin_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	test -z "$(plugindir)" || $(MKDIR_P) "$(DESTDIR)$(plugindir)"
+	@list='$(plugin_LTLIBRARIES)'; test -n "$(plugindir)" || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2="$$list2 $$p"; \
+	  else :; fi; \
+	done; \
+	test -z "$$list2" || { \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(plugindir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(plugindir)"; \
+	}
+
+uninstall-pluginLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(plugin_LTLIBRARIES)'; test -n "$(plugindir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(plugindir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(plugindir)/$$f"; \
+	done
+
+clean-pluginLTLIBRARIES:
+	-test -z "$(plugin_LTLIBRARIES)" || rm -f $(plugin_LTLIBRARIES)
+	@list='$(plugin_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libmfw_gst_tvsrc.la: $(libmfw_gst_tvsrc_la_OBJECTS) $(libmfw_gst_tvsrc_la_DEPENDENCIES) 
+	$(libmfw_gst_tvsrc_la_LINK) -rpath $(plugindir) $(libmfw_gst_tvsrc_la_OBJECTS) $(libmfw_gst_tvsrc_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmfw_gst_tvsrc_la-mfw_gst_tvsrc.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+libmfw_gst_tvsrc_la-mfw_gst_tvsrc.lo: mfw_gst_tvsrc.c
+@am__fastdepCC_TRUE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmfw_gst_tvsrc_la_CFLAGS) $(CFLAGS) -MT libmfw_gst_tvsrc_la-mfw_gst_tvsrc.lo -MD -MP -MF $(DEPDIR)/libmfw_gst_tvsrc_la-mfw_gst_tvsrc.Tpo -c -o libmfw_gst_tvsrc_la-mfw_gst_tvsrc.lo `test -f 'mfw_gst_tvsrc.c' || echo '$(srcdir)/'`mfw_gst_tvsrc.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/libmfw_gst_tvsrc_la-mfw_gst_tvsrc.Tpo $(DEPDIR)/libmfw_gst_tvsrc_la-mfw_gst_tvsrc.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='mfw_gst_tvsrc.c' object='libmfw_gst_tvsrc_la-mfw_gst_tvsrc.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmfw_gst_tvsrc_la_CFLAGS) $(CFLAGS) -c -o libmfw_gst_tvsrc_la-mfw_gst_tvsrc.lo `test -f 'mfw_gst_tvsrc.c' || echo '$(srcdir)/'`mfw_gst_tvsrc.c
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(plugindir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-pluginLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-pluginLTLIBRARIES
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-pluginLTLIBRARIES
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-pluginLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-pluginLTLIBRARIES \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-pluginLTLIBRARIES
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
--- /dev/null
+++ b/src/misc/tvsrc/src/mfw_gst_tvsrc.c
@@ -0,0 +1,1280 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ *
+ */
+
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Module Name:    mfw_gst_tvsrc.c
+ *
+ * Description:    Implementation of TV-in module V4L2 Plugin for Gstreamer
+ *
+ * Portability:    This code is written for Linux OS and Gstreamer
+ */
+
+/*
+ * Changelog: 
+ *
+ */
+
+
+
+/*=============================================================================
+                            INCLUDE FILES
+=============================================================================*/
+#include <gst/gst.h>
+#include <gst/base/gstpushsrc.h>
+#include <gst/interfaces/propertyprobe.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <stdint.h>
+#include <linux/videodev2.h>
+#include <sys/mman.h>
+#include <string.h>
+#include "mfw_gst_tvsrc.h"
+#ifdef MX27
+#include "mxcfb.h"
+#else
+#include "linux/mxcfb.h"
+#endif
+
+#include "mfw_gst_utils.h"
+#include "gstbufmeta.h"
+
+
+/*=============================================================================
+                            LOCAL CONSTANTS
+=============================================================================*/
+#define DEFAULT_QUEUE_SIZE 6
+/*=============================================================================
+                LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
+=============================================================================*/
+
+enum
+{
+  MFW_V4L_SRC_0,
+  MFW_V4L_SRC_FRAMERATE_NUM,
+  MFW_V4L_SRC_FRAMERATE_DEN,
+  MFW_V4L_SRC_DEVICE,
+  MFW_V4L_SRC_QUEUE_SIZE,
+};
+
+
+/*=============================================================================
+                              LOCAL MACROS
+=============================================================================*/
+
+/* used for debugging */
+#define GST_CAT_DEFAULT mfw_gst_tvsrc_debug
+
+#define ipu_fourcc(a,b,c,d)\
+        (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+#define IPU_PIX_FMT_RGB332  ipu_fourcc('R','G','B','1') /*!<  8  RGB-3-3-2     */
+#define IPU_PIX_FMT_RGB555  ipu_fourcc('R','G','B','O') /*!< 16  RGB-5-5-5     */
+#define IPU_PIX_FMT_RGB565  ipu_fourcc('R','G','B','P') /*!< 16  RGB-5-6-5     */
+#define IPU_PIX_FMT_RGB666  ipu_fourcc('R','G','B','6') /*!< 18  RGB-6-6-6     */
+#define IPU_PIX_FMT_BGR24   ipu_fourcc('B','G','R','3') /*!< 24  BGR-8-8-8     */
+#define IPU_PIX_FMT_RGB24   ipu_fourcc('R','G','B','3') /*!< 24  RGB-8-8-8     */
+#define IPU_PIX_FMT_BGR32   ipu_fourcc('B','G','R','4') /*!< 32  BGR-8-8-8-8   */
+#define IPU_PIX_FMT_BGRA32  ipu_fourcc('B','G','R','A') /*!< 32  BGR-8-8-8-8   */
+#define IPU_PIX_FMT_RGB32   ipu_fourcc('R','G','B','4') /*!< 32  RGB-8-8-8-8   */
+#define IPU_PIX_FMT_RGBA32  ipu_fourcc('R','G','B','A') /*!< 32  RGB-8-8-8-8   */
+#define IPU_PIX_FMT_ABGR32  ipu_fourcc('A','B','G','R') /*!< 32  ABGR-8-8-8-8  */
+
+
+
+/*=============================================================================
+                             STATIC VARIABLES
+=============================================================================*/
+
+
+/*=============================================================================
+                             GLOBAL VARIABLES
+=============================================================================*/
+/* None */
+
+/*=============================================================================
+                        LOCAL FUNCTION PROTOTYPES
+=============================================================================*/
+
+GST_DEBUG_CATEGORY_STATIC (mfw_gst_tvsrc_debug);
+static void mfw_gst_tvsrc_buffer_class_init (gpointer g_class,
+    gpointer class_data);
+static void mfw_gst_tvsrc_buffer_init (GTypeInstance * instance,
+    gpointer g_class);
+static void mfw_gst_tvsrc_buffer_finalize (MFWGstTVSRCBuffer * TVSRC_buffer);
+static void mfw_gst_tvsrc_fixate (GstPad * pad, GstCaps * caps);
+static GstCaps *mfw_gst_tvsrc_get_caps (GstBaseSrc * src);
+static GstFlowReturn mfw_gst_tvsrc_create (GstPushSrc * src, GstBuffer ** buf);
+static GstBuffer *mfw_gst_tvsrc_buffer_new (MFWGstTVSRC * v4l_src);
+static gboolean mfw_gst_tvsrc_stop (GstBaseSrc * src);
+static gboolean mfw_gst_tvsrc_start (GstBaseSrc * src);
+static gboolean mfw_gst_tvsrc_set_caps (GstBaseSrc * src, GstCaps * caps);
+static void mfw_gst_tvsrc_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+static void mfw_gst_tvsrc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static gint mfw_gst_tvsrc_capture_setup (MFWGstTVSRC * v4l_src);
+static gint mfw_gst_tvsrc_stop_capturing (MFWGstTVSRC * v4l_src);
+static gint mfw_gst_tvsrc_start_capturing (MFWGstTVSRC * v4l_src);
+
+
+GST_BOILERPLATE (MFWGstTVSRC, mfw_gst_tvsrc, GstPushSrc, GST_TYPE_PUSH_SRC);
+
+
+/*=============================================================================
+FUNCTION:           mfw_gst_tvsrc_buffer_get_type    
+
+DESCRIPTION:        This funtion registers the  buffer type on to the V4L Source plugin
+             
+ARGUMENTS PASSED:   void   
+
+RETURN VALUE:       Return the registered buffer type
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+GType
+mfw_gst_tvsrc_buffer_get_type (void)
+{
+  static GType TVSRC_buffer_type;
+
+  if (G_UNLIKELY (TVSRC_buffer_type == 0)) {
+    static const GTypeInfo TVSRC_buffer_info = {
+      sizeof (GstBufferClass),
+      NULL,
+      NULL,
+      mfw_gst_tvsrc_buffer_class_init,
+      NULL,
+      NULL,
+      sizeof (MFWGstTVSRCBuffer),
+      0,
+      mfw_gst_tvsrc_buffer_init,
+      NULL
+    };
+    TVSRC_buffer_type = g_type_register_static (GST_TYPE_BUFFER,
+        "MFWGstTVSRCBuffer", &TVSRC_buffer_info, 0);
+  }
+  return TVSRC_buffer_type;
+}
+
+
+/*=============================================================================
+FUNCTION:           mfw_gst_tvsrc_buffer_class_init    
+
+DESCRIPTION:   This funtion registers the  funtions used by the 
+                buffer class of the V4l source plug-in
+             
+ARGUMENTS PASSED:
+        g_class        -   class from which the mini objext is derived
+        class_data     -   global class data
+
+RETURN VALUE:       None
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+static void
+mfw_gst_tvsrc_buffer_class_init (gpointer g_class, gpointer class_data)
+{
+  GstMiniObjectClass *mini_object_class = GST_MINI_OBJECT_CLASS (g_class);
+
+  mini_object_class->finalize = (GstMiniObjectFinalizeFunction)
+      mfw_gst_tvsrc_buffer_finalize;
+}
+
+
+/*=============================================================================
+FUNCTION:      mfw_gst_tvsrc_buffer_init    
+
+DESCRIPTION:   This funtion initialises the buffer class of the V4l source plug-in
+             
+ARGUMENTS PASSED:
+        instance       -   pointer to buffer instance
+        g_class        -   global pointer
+
+RETURN VALUE:       None
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+static void
+mfw_gst_tvsrc_buffer_init (GTypeInstance * instance, gpointer g_class)
+{
+
+}
+
+
+/*=============================================================================
+FUNCTION:      mfw_gst_tvsrc_buffer_finalize    
+
+DESCRIPTION:   This function is invoked whenever the buffer object belonging 
+               to the V4L Source buffer glass is tried to un-refrenced. Here 
+               only the refernce count of the buffer object is increased without 
+               freeing the memory allocated.
+
+ARGUMENTS PASSED:
+        TVSRC_buffer -   pointer to V4L sou4rce buffer class
+
+RETURN VALUE:       None
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+static void
+mfw_gst_tvsrc_buffer_finalize (MFWGstTVSRCBuffer * TVSRC_buffer)
+{
+  MFWGstTVSRC *v4l_src;
+  gint num;
+  GstBuffer *buf;
+  struct v4l2_buffer v4lbuf;
+
+
+  v4l_src = TVSRC_buffer->TVSRCcontext;
+  if (v4l_src->start) {
+    num = TVSRC_buffer->num;
+
+
+    buf = (GstBuffer *) (v4l_src->buffers[num]);
+    GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_LAST);
+
+    if (g_list_find (v4l_src->free_pool, (gpointer) (num)))
+      GST_WARNING ("something wrong here, v4l buffer index:%d already in queue",
+          num);
+    else
+      GST_LOG ("v4l buffer index:%d will be push in pool", num);
+
+    memset (&v4lbuf, 0, sizeof (v4lbuf));
+    v4lbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    v4lbuf.memory = V4L2_MEMORY_MMAP;
+    v4lbuf.index = num;
+
+    if (ioctl (v4l_src->fd_v4l, VIDIOC_QBUF, &v4lbuf) < 0) {
+      GST_ERROR (">>V4L_SRC: VIDIOC_QBUF failed");
+      return;
+    }
+
+    v4l_src->free_pool = g_list_append (v4l_src->free_pool, (gpointer) num);
+    GST_LOG_OBJECT (v4l_src, "freeing buffer %p for frame %d", TVSRC_buffer,
+        num);
+    gst_buffer_ref (GST_BUFFER_CAST (TVSRC_buffer));
+  } else {
+    GST_LOG ("free buffer %d\n", TVSRC_buffer->num);
+  }
+}
+
+
+/*=============================================================================
+FUNCTION:      mfw_gst_tvsrc_start_capturing    
+        
+DESCRIPTION:   This function triggers the V4L Driver to start Capturing
+
+ARGUMENTS PASSED:
+        v4l_src -   The V4L Souce plug-in context.
+
+RETURN VALUE:       None
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+static gint
+mfw_gst_tvsrc_start_capturing (MFWGstTVSRC * v4l_src)
+{
+  guint i;
+  struct v4l2_buffer *buf;
+  MFWGstTVSRCBuffer *tvsrc_buf = NULL;
+  enum v4l2_buf_type type;
+
+  v4l_src->buffers = g_malloc (v4l_src->queue_size * sizeof (GstBuffer *));
+  // query for v4l_src->queue_size number of buffers to store the captured data 
+  for (i = 0; i < v4l_src->queue_size; i++) {
+    tvsrc_buf =
+        (MFWGstTVSRCBuffer *) gst_mini_object_new (MFW_GST_TYPE_TVSRC_BUFFER);
+    tvsrc_buf->num = i;
+    tvsrc_buf->TVSRCcontext = v4l_src;
+    /* v4l2_buffer initialization */
+    buf = &tvsrc_buf->v4l2_buf;
+    // memset (&buf, 0, sizeof (buf));
+    buf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    buf->memory = V4L2_MEMORY_MMAP;
+    buf->index = i;
+    if (ioctl (v4l_src->fd_v4l, VIDIOC_QUERYBUF, buf) < 0) {
+      GST_ERROR (">>V4L_SRC: VIDIOC_QUERYBUF error");
+      return -1;
+    }
+    // v4l_src->buffers[i] = gst_buffer_new ();
+    /* GstBuffer initialization */
+    v4l_src->buffers[i] = (GstBuffer *) tvsrc_buf;
+    GST_BUFFER_SIZE (v4l_src->buffers[i]) = buf->length;
+    GST_BUFFER_OFFSET (v4l_src->buffers[i]) = (size_t) buf->m.offset;
+    GST_BUFFER_DATA (v4l_src->buffers[i]) = mmap (NULL,
+        GST_BUFFER_SIZE (v4l_src->buffers[i]),
+        PROT_READ | PROT_WRITE, MAP_SHARED,
+        v4l_src->fd_v4l, GST_BUFFER_OFFSET (v4l_src->buffers[i]));
+    memset (GST_BUFFER_DATA (v4l_src->buffers[i]), 0xFF,
+        GST_BUFFER_SIZE (v4l_src->buffers[i]));
+    {
+      gint index;
+      GstBufferMeta *meta;
+      index = G_N_ELEMENTS (v4l_src->buffers[i]->_gst_reserved) - 1;
+      meta = gst_buffer_meta_new ();
+      meta->physical_data = (gpointer) (buf->m.offset);
+      v4l_src->buffers[i]->_gst_reserved[index] = meta;
+    }
+
+
+    buf->m.offset = GST_BUFFER_OFFSET (v4l_src->buffers[i]);
+    if (v4l_src->crop_pixel) {
+      buf->m.offset += v4l_src->crop_pixel *
+          (v4l_src->capture_width) + v4l_src->crop_pixel;
+    }
+
+    if (ioctl (v4l_src->fd_v4l, VIDIOC_QBUF, buf) < 0) {
+      GST_ERROR (">>V4L_SRC: VIDIOC_QBUF error");
+      return -1;
+    }
+    v4l_src->free_pool =
+        g_list_append (v4l_src->free_pool, (gpointer) buf->index);
+
+  }
+
+  /* Switch ON the capture device */
+  type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  if (ioctl (v4l_src->fd_v4l, VIDIOC_STREAMON, &type) < 0) {
+    GST_ERROR (">>V4L_SRC: VIDIOC_STREAMON error");
+    return -1;
+  }
+
+  v4l_src->start = TRUE;
+  v4l_src->time_per_frame =
+      gst_util_uint64_scale_int (GST_SECOND, v4l_src->fps_d, v4l_src->fps_n);
+  GST_DEBUG (">>V4L_SRC: time per frame %d", (guint32) v4l_src->time_per_frame);
+  v4l_src->last_ts = 0;
+  return 0;
+}
+
+
+/*=============================================================================
+FUNCTION:      mfw_gst_tvsrc_stop_capturing    
+        
+DESCRIPTION:   This function triggers the V4L Driver to stop Capturing
+
+ARGUMENTS PASSED:
+        v4l_src -   The V4L Souce plug-in context.
+
+RETURN VALUE:       None
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+static gint
+mfw_gst_tvsrc_stop_capturing (MFWGstTVSRC * v4l_src)
+{
+  enum v4l2_buf_type type;
+  guint i;
+  gint index;
+
+  type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  if (ioctl (v4l_src->fd_v4l, VIDIOC_STREAMOFF, &type) < 0) {
+    GST_ERROR (">>V4L_SRC: error in VIDIOC_STREAMOFF");
+    return -1;
+  }
+  v4l_src->start = FALSE;
+  for (i = 0; i < v4l_src->queue_size; i++) {
+    munmap (GST_BUFFER_DATA (v4l_src->buffers[i]),
+        GST_BUFFER_SIZE (v4l_src->buffers[i]));
+
+    index = G_N_ELEMENTS (v4l_src->buffers[i]->_gst_reserved) - 1;
+    gst_buffer_meta_free (v4l_src->buffers[i]->_gst_reserved[index]);
+    gst_buffer_unref (v4l_src->buffers[i]);
+  }
+  if (v4l_src->buffers)
+    g_free (v4l_src->buffers);
+
+  return 0;
+}
+
+
+
+/*=============================================================================
+FUNCTION:      mfw_gst_tvsrc_capture_setup    
+        
+DESCRIPTION:   This function does the necessay initialistions for the V4L capture
+               device driver.
+
+ARGUMENTS PASSED:
+        v4l_src -   The V4L Souce plug-in context.
+
+RETURN VALUE:       None
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+static gint
+mfw_gst_tvsrc_capture_setup (MFWGstTVSRC * v4l_src)
+{
+  struct v4l2_format fmt;
+  struct v4l2_control ctrl;
+  struct v4l2_streamparm parm;
+  struct v4l2_dbg_chip_ident chip;
+  gint fd_v4l = 0;
+  struct v4l2_mxc_offset off;
+  gint in_width = 0, in_height = 0;
+  v4l2_std_id id;
+
+  if ((fd_v4l = open (v4l_src->devicename, O_RDWR, 0)) < 0) {
+    GST_ERROR (">>V4L_SRC: Unable to open %s", v4l_src->devicename);
+    return 0;
+  }
+
+  if (ioctl (fd_v4l, VIDIOC_DBG_G_CHIP_IDENT, &chip)) {
+    g_print ("VIDIOC_DBG_G_CHIP_IDENT failed.\n");
+  } else
+    g_print ("sensor chip is %s\n", chip.match.name);
+
+
+
+  if (ioctl (fd_v4l, VIDIOC_G_STD, &id) < 0) {
+    g_print ("VIDIOC_G_STD failed\n");
+    close (fd_v4l);
+    return 0;
+  }
+  v4l_src->id = id;
+
+  if (ioctl (fd_v4l, VIDIOC_S_STD, &id) < 0) {
+    g_print ("VIDIOC_S_STD failed\n");
+    close (fd_v4l);
+    return 0;
+  }
+
+  parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  parm.parm.capture.timeperframe.numerator = v4l_src->fps_d;
+  parm.parm.capture.timeperframe.denominator = v4l_src->fps_n;
+  parm.parm.capture.capturemode = v4l_src->capture_mode;
+  if ((v4l_src->tv_in) || (parm.parm.capture.capturemode >= 4)) {
+    gint input = 1;
+    g_print ("should set the input to 1\n");
+    if (ioctl (fd_v4l, VIDIOC_S_INPUT, &input) < 0) {
+      GST_ERROR (">>V4L_SRC: VIDIOC_S_INPUT failed");
+      return -1;
+    }
+  }
+
+
+  if (ioctl (fd_v4l, VIDIOC_S_PARM, &parm) < 0) {
+    GST_ERROR (">>V4L_SRC: VIDIOC_S_PARM failed");
+    return -1;
+  }
+
+  memset (&fmt, 0, sizeof (fmt));
+
+  fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+#ifdef MX51
+  fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_NV12;
+#else
+  fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;
+#endif
+  fmt.fmt.pix.width = 0;
+  fmt.fmt.pix.height = 0;
+
+
+  if (ioctl (fd_v4l, VIDIOC_S_FMT, &fmt) < 0) {
+    GST_ERROR (">>V4L_SRC: set format failed");
+    return 0;
+  }
+
+  if (ioctl (fd_v4l, VIDIOC_G_FMT, &fmt) < 0) {
+    g_print ("VIDIOC_G_FMT failed\n");
+    close (fd_v4l);
+    return 0;
+  }
+
+  v4l_src->capture_width = fmt.fmt.pix.width;
+  v4l_src->capture_height = fmt.fmt.pix.height;
+
+  struct v4l2_requestbuffers req;
+  memset (&req, 0, sizeof (req));
+  req.count = v4l_src->queue_size;
+  req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  req.memory = V4L2_MEMORY_MMAP;
+
+  if (ioctl (fd_v4l, VIDIOC_REQBUFS, &req) < 0) {
+    GST_ERROR
+        (">>V4L_SRC: v4l_mfw_gst_tvsrc_capture_setup: VIDIOC_REQBUFS failed");
+    return 0;
+  }
+
+  return fd_v4l;
+}
+
+
+/*=============================================================================
+FUNCTION:           mfw_gst_tvsrc_set_property   
+        
+DESCRIPTION:        This function is notified if application changes the values of 
+                    a property.            
+
+ARGUMENTS PASSED:
+        object  -   pointer to GObject   
+        prop_id -   id of element
+        value   -   pointer to Gvalue
+        pspec   -   pointer to GParamSpec
+
+RETURN VALUE:       None
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+static void
+mfw_gst_tvsrc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  MFWGstTVSRC *v4l_src = MFW_GST_TVSRC (object);
+  switch (prop_id) {
+    case MFW_V4L_SRC_FRAMERATE_NUM:
+      v4l_src->fps_n = g_value_get_int (value);
+      GST_DEBUG ("framerate numerator =%d", v4l_src->fps_n);
+      break;
+    case MFW_V4L_SRC_FRAMERATE_DEN:
+      v4l_src->fps_d = g_value_get_int (value);
+      GST_DEBUG ("framerate denominator=%d", v4l_src->fps_d);
+      break;
+    case MFW_V4L_SRC_DEVICE:
+      if (v4l_src->devicename)
+        g_free (v4l_src->devicename);
+      v4l_src->devicename = g_strdup (g_value_get_string (value));
+      break;
+    case MFW_V4L_SRC_QUEUE_SIZE:
+      v4l_src->queue_size = g_value_get_int (value);
+      GST_DEBUG ("queue size=%d", v4l_src->queue_size);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+
+}
+
+
+/*=============================================================================
+FUNCTION:   mfw_gst_tvsrc_get_property    
+        
+DESCRIPTION:    This function is notified if application requests the values of 
+                a property.                  
+
+ARGUMENTS PASSED:
+        object  -   pointer to GObject   
+        prop_id -   id of element
+        value   -   pointer to Gvalue
+        pspec   -   pointer to GParamSpec
+
+RETURN VALUE:       None
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+static void
+mfw_gst_tvsrc_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+
+  MFWGstTVSRC *v4l_src = MFW_GST_TVSRC (object);
+  switch (prop_id) {
+    case MFW_V4L_SRC_FRAMERATE_NUM:
+      g_value_set_int (value, v4l_src->fps_n);
+      break;
+    case MFW_V4L_SRC_FRAMERATE_DEN:
+      g_value_set_int (value, v4l_src->fps_d);
+      break;
+
+    case MFW_V4L_SRC_DEVICE:
+      g_value_set_string (value, v4l_src->devicename);
+      break;
+
+    case MFW_V4L_SRC_QUEUE_SIZE:
+      g_value_set_int (value, v4l_src->queue_size);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+
+}
+
+
+/*=============================================================================
+FUNCTION:            mfw_gst_tvsrc_set_caps
+         
+DESCRIPTION:         this function does the capability negotiation between adjacent pad  
+
+ARGUMENTS PASSED:    
+        src       -   pointer to base source 
+        caps      -   pointer to GstCaps
+        
+  
+RETURN VALUE:       TRUE or FALSE depending on capability is negotiated or not.
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+static gboolean
+mfw_gst_tvsrc_set_caps (GstBaseSrc * src, GstCaps * caps)
+{
+  MFWGstTVSRC *v4l_src = MFW_GST_TVSRC (src);
+  return TRUE;
+}
+
+
+/*=============================================================================
+FUNCTION:            mfw_gst_tvsrc_overlay_setup
+         
+DESCRIPTION:         This function performs the initialisations required for preview
+
+ARGUMENTS PASSED:    
+        fd_v4l    -   capture device ID
+        fmt       -   pointer to the V4L format structure.
+        
+  
+RETURN VALUE:       TRUE - preview setup initialised successfully
+                    FALSE - Error in initialising the preview set up.
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+gboolean
+mfw_gst_tvsrc_overlay_setup (MFWGstTVSRC * v4l_src, struct v4l2_format * fmt)
+{
+  struct v4l2_streamparm parm;
+  v4l2_std_id id;
+  struct v4l2_control ctl;
+  struct v4l2_crop crop;
+  int g_sensor_top = 0;
+  int g_sensor_left = 0;
+  int g_camera_color = 0;
+  int fd_v4l = v4l_src->fd_v4l;
+  struct v4l2_framebuffer fb;
+  struct v4l2_cropcap cropcap;
+
+  GST_INFO ("display lcd:%d\n", v4l_src->g_display_lcd);
+  /* this ioctl sets up the LCD display for preview */
+  if (ioctl (v4l_src->fd_v4l_out, VIDIOC_S_OUTPUT, &v4l_src->g_display_lcd) < 0) {
+    GST_ERROR (">>V4L_SRC: VIDIOC_S_OUTPUT failed");
+    return FALSE;
+  }
+
+  memset (&cropcap, 0, sizeof (cropcap));
+  cropcap.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+  if (ioctl (v4l_src->fd_v4l_out, VIDIOC_CROPCAP, &cropcap) < 0) {
+    g_print ("get crop capability failed\n");
+    return FALSE;
+  }
+
+  crop.type = V4L2_BUF_TYPE_VIDEO_OVERLAY;
+  crop.c.left = v4l_src->crop_pixel;
+  crop.c.top = v4l_src->crop_pixel;
+  crop.c.width = v4l_src->capture_width;
+  crop.c.height = v4l_src->capture_height;
+
+  /* this ioctl sets capture rectangle */
+  if (ioctl (v4l_src->fd_v4l_out, VIDIOC_S_CROP, &crop) < 0) {
+    GST_ERROR (">>V4L_SRC: set capture rectangle for cropping failed");
+    return FALSE;
+  }
+
+  ctl.id = V4L2_CID_PRIVATE_BASE;
+  ctl.value = 0;
+  if (ioctl (v4l_src->fd_v4l_out, VIDIOC_S_CTRL, &ctl) < 0) {
+    g_print ("set ctrl failed\n");
+    return FALSE;
+  }
+
+  ctl.id = V4L2_CID_PRIVATE_BASE + 3;
+  ctl.value = 0;
+  if (ioctl (v4l_src->fd_v4l_out, VIDIOC_S_CTRL, &ctl) < 0) {
+    g_print ("set ctrl failed\n");
+    return FALSE;
+  }
+  g_print ("set fb overlay\n");
+  fb.flags = V4L2_FBUF_FLAG_OVERLAY;
+  ioctl (v4l_src->fd_v4l_out, VIDIOC_S_FBUF, &fb);
+
+  g_print ("display lcd:%d\n", v4l_src->g_display_lcd);
+
+  if (ioctl (fd_v4l, VIDIOC_S_FMT, fmt) < 0) {
+    GST_ERROR (">>V4L_SRC: set format failed");
+    return FALSE;
+  }
+
+  if (ioctl (fd_v4l, VIDIOC_G_FMT, fmt) < 0) {
+    GST_ERROR (">>V4L_SRC: get format failed");
+    return FALSE;
+  }
+
+  if (ioctl (fd_v4l, VIDIOC_G_STD, &id) < 0) {
+    GST_ERROR (">>V4L_SRC: VIDIOC_G_STD failed");
+    return FALSE;
+  }
+
+  struct v4l2_requestbuffers req;
+  memset (&req, 0, sizeof (req));
+  req.count = v4l_src->queue_size;
+  req.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+  req.memory = V4L2_MEMORY_MMAP;
+  if (ioctl (v4l_src->fd_v4l_out, VIDIOC_REQBUFS, &req) < 0) {
+    g_print ("request buffers failed\n");
+    return FALSE;
+  }
+
+
+  return TRUE;
+}
+
+
+
+/*=============================================================================
+FUNCTION:            mfw_gst_tvsrc_start
+         
+DESCRIPTION:         this function is registered  with the Base Source Class of
+                     the gstreamer to start the video capturing process 
+                     from this function
+
+ARGUMENTS PASSED:    
+        src       -   pointer to base source 
+        
+RETURN VALUE:        TRUE or FALSE depending on the sate of capture initiation
+        
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+static gboolean
+mfw_gst_tvsrc_start (GstBaseSrc * src)
+{
+  MFWGstTVSRC *v4l_src = MFW_GST_TVSRC (src);
+  struct v4l2_format fmt;
+  struct v4l2_framebuffer fb_v4l2;
+  char fb_device[100] = "/dev/fb0";
+  int fd_fb = 0;
+  struct fb_fix_screeninfo fix;
+  struct fb_var_screeninfo var;
+  struct mxcfb_color_key color_key;
+  struct mxcfb_gbl_alpha alpha;
+  unsigned short *fb0;
+  unsigned char *cur_fb8;
+  unsigned short *cur_fb16;
+  unsigned int *cur_fb32;
+  __u32 screen_size;
+  int h, w;
+  int ret = 0;
+  int g_display_width = 0;
+  int g_display_height = 0;
+  int g_display_top = 0;
+  int g_display_left = 0;
+
+
+  if (v4l_src->tv_in) {
+    v4l_src->capture_width = 0;
+    v4l_src->capture_height = 0;
+    v4l_src->fps_n = 1;
+  }
+
+  v4l_src->fd_v4l = mfw_gst_tvsrc_capture_setup (v4l_src);
+  if (v4l_src->fd_v4l <= 0) {
+    GST_ERROR ("TVSRC:error in opening the device");
+    return FALSE;
+  }
+
+  fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  if (ioctl (v4l_src->fd_v4l, VIDIOC_G_FMT, &fmt) < 0) {
+    GST_ERROR (">>V4L_SRC: get format failed");
+    return FALSE;
+  } else {
+    v4l_src->buffer_size = fmt.fmt.pix.sizeimage;
+    GST_DEBUG ("Width = %d", fmt.fmt.pix.width);
+    GST_DEBUG ("Height = %d", fmt.fmt.pix.height);
+    GST_DEBUG ("Image size = %d", fmt.fmt.pix.sizeimage);
+    GST_DEBUG ("pixelformat = %d", fmt.fmt.pix.pixelformat);
+  }
+
+
+  if (mfw_gst_tvsrc_start_capturing (v4l_src) < 0) {
+    GST_ERROR ("start_capturing failed");
+    return FALSE;
+  }
+
+  v4l_src->offset = 0;
+  return TRUE;
+}
+
+
+/*=============================================================================
+FUNCTION:            mfw_gst_tvsrc_stop
+         
+DESCRIPTION:         this function is registered  with the Base Source Class of
+                     the gstreamer to stop the video capturing process 
+                     by this function
+
+ARGUMENTS PASSED:    
+        src       -   pointer to base source 
+        
+  
+RETURN VALUE:        TRUE or FALSE depending on the sate of capture initiation
+        
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+static gboolean
+mfw_gst_tvsrc_stop (GstBaseSrc * src)
+{
+  MFWGstTVSRC *v4l_src = MFW_GST_TVSRC (src);
+  gint overlay = 0;
+
+
+  if (mfw_gst_tvsrc_stop_capturing (v4l_src) < 0) {
+    GST_ERROR (">>V4L_SRC: stop_capturing failed");
+    return FALSE;
+  }
+
+  if (TRUE == v4l_src->preview) {
+
+    if (ioctl (v4l_src->fd_v4l, VIDIOC_OVERLAY, &overlay) < 0) {
+      g_print ("VIDIOC_OVERLAY stop failed\n");
+      return FALSE;
+    }
+  }
+  close (v4l_src->fd_v4l);
+  v4l_src->fd_v4l = -1;
+  close (v4l_src->fd_v4l_out);
+  v4l_src->fd_v4l_out = -1;
+  return TRUE;
+}
+
+
+/*=============================================================================
+FUNCTION:           mfw_gst_tvsrc_buffer_new
+         
+DESCRIPTION:        This function is used to store the frames captured by the
+                    V4L capture driver
+
+ARGUMENTS PASSED:   v4l_src     - 
+        
+RETURN VALUE:       TRUE or FALSE depending on the sate of capture initiation
+        
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+static GstBuffer *
+mfw_gst_tvsrc_buffer_new (MFWGstTVSRC * v4l_src)
+{
+  GstBuffer *buf;
+  gint fps_n, fps_d;
+  struct v4l2_buffer v4lbuf;
+  GstClockTime ts, res;
+
+  v4l_src->count++;
+  memset (&v4lbuf, 0, sizeof (v4lbuf));
+  v4lbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  v4lbuf.memory = V4L2_MEMORY_MMAP;
+
+  if (g_list_length (v4l_src->free_pool) == 0) {
+    GST_WARNING ("no buffer available in pool");
+    return NULL;
+  }
+
+  if (ioctl (v4l_src->fd_v4l, VIDIOC_DQBUF, &v4lbuf) < 0) {
+    GST_ERROR (">>V4L_SRC: VIDIOC_DQBUF failed.");
+    return NULL;
+  }
+  if (g_list_find (v4l_src->free_pool, (gpointer) (v4lbuf.index)))
+    GST_LOG ("v4l buffer index:%d will be used outside", v4lbuf.index);
+  else
+    GST_WARNING ("v4l buffer index:%d can not be found in pool", v4lbuf.index);
+
+  v4l_src->free_pool =
+      g_list_remove (v4l_src->free_pool, (gpointer) (v4lbuf.index));
+
+
+  buf = (GstBuffer *) (v4l_src->buffers[v4lbuf.index]);
+  GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_LAST);
+
+  GST_LOG ("v4l dequeued buffer index:%d(ref %d), num in pool:%d", v4lbuf.index,
+      buf->mini_object.refcount, g_list_length (v4l_src->free_pool));
+
+  if (v4l_src->preview) {
+
+  }
+
+  GST_BUFFER_SIZE (buf) = v4l_src->buffer_size;
+
+  ts = gst_clock_get_time (GST_ELEMENT (v4l_src)->clock);
+  if (ts != GST_CLOCK_TIME_NONE)
+    ts -= gst_element_get_base_time (GST_ELEMENT (v4l_src));
+  else
+    ts = v4l_src->count * v4l_src->time_per_frame;
+  GST_BUFFER_TIMESTAMP (buf) = ts;
+  GST_BUFFER_DURATION (buf) = v4l_src->time_per_frame;
+
+  if (v4l_src->last_ts) {
+    guint num_frame_delay = 0;
+    GstClockTimeDiff diff = ts - v4l_src->last_ts;
+    if (ts < v4l_src->last_ts)
+      diff = v4l_src->last_ts + ts;
+    while (diff > v4l_src->time_per_frame) {
+      diff -= v4l_src->time_per_frame;
+      num_frame_delay++;
+    }
+    if (num_frame_delay > 1)
+      GST_DEBUG (">>V4L_SRC: Camera ts late by %d frames", num_frame_delay);
+  }
+  v4l_src->last_ts = ts;
+
+  gst_buffer_set_caps (buf, GST_PAD_CAPS (GST_BASE_SRC_PAD (v4l_src)));
+  return buf;
+}
+
+
+/*=============================================================================
+FUNCTION:            mfw_gst_tvsrc_create
+         
+DESCRIPTION:         This function is registered with the Base Source Class 
+                     This function updates the the buffer to be pushed to the
+                     next element with the frame captured.
+                     
+ARGUMENTS PASSED:    v4l_src     - 
+        
+  
+RETURN VALUE:        
+              GST_FLOW_OK       -    buffer create successfull.
+              GST_FLOW_ERROR    -    Error in buffer creation.
+        
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+static GstFlowReturn
+mfw_gst_tvsrc_create (GstPushSrc * src, GstBuffer ** buf)
+{
+  MFWGstTVSRC *v4l_src = MFW_GST_TVSRC (src);
+  *buf = mfw_gst_tvsrc_buffer_new (v4l_src);
+  if (*buf == NULL)
+    return GST_FLOW_ERROR;
+  else
+    return GST_FLOW_OK;
+
+}
+
+
+/*=============================================================================
+FUNCTION:            mfw_gst_tvsrc_get_caps
+         
+DESCRIPTION:         This function gets the caps to be set on the source pad.
+                     
+
+ARGUMENTS PASSED:    
+        v4l_src     - 
+         
+RETURN VALUE:       Returns the caps to be set.
+        
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+static GstCaps *
+mfw_gst_tvsrc_get_caps (GstBaseSrc * src)
+{
+  GstCaps *list;
+  MFWGstTVSRC *v4l_src = MFW_GST_TVSRC (src);
+  GstCaps *capslist;
+  GstPadTemplate *src_template = NULL;
+  gint i;
+#ifndef MX51
+  guint32 format = GST_MAKE_FOURCC ('I', '4', '2', '0');
+#else
+  guint32 format = GST_MAKE_FOURCC ('N', 'V', '1', '2');
+#endif
+
+  capslist = gst_caps_new_empty ();
+
+  gst_caps_append_structure (capslist,
+      gst_structure_new ("video/x-raw-yuv",
+          "format",
+          GST_TYPE_FOURCC,
+          format, "width",
+          GST_TYPE_INT_RANGE, 16,
+          G_MAXINT, "height",
+          GST_TYPE_INT_RANGE, 16,
+          G_MAXINT, "framerate",
+          GST_TYPE_FRACTION_RANGE,
+          0, 1, 100, 1, "pixel-aspect-ratio",
+          GST_TYPE_FRACTION_RANGE, 0, 1, 100, 1, NULL));
+
+
+
+  return capslist;
+}
+
+
+/*=============================================================================
+FUNCTION:            mfw_gst_tvsrc_fixate
+         
+DESCRIPTION:         Fixes the Caps on the source pad
+                     
+
+ARGUMENTS PASSED:    v4l_src     - 
+        
+RETURN VALUE:        None
+PRE-CONDITIONS:      None
+POST-CONDITIONS:     None
+IMPORTANT NOTES:     None
+=============================================================================*/
+static void
+mfw_gst_tvsrc_fixate (GstPad * pad, GstCaps * caps)
+{
+
+  gint i = 0;
+  GstStructure *structure = NULL;
+  MFWGstTVSRC *v4l_src = MFW_GST_TVSRC (gst_pad_get_parent (pad));
+#ifndef MX51
+  guint32 fourcc = GST_MAKE_FOURCC ('I', '4', '2', '0');
+#else
+  guint32 fourcc = GST_MAKE_FOURCC ('N', 'V', '1', '2');
+#endif
+
+  const GValue *v = NULL;
+  for (i = 0; i < gst_caps_get_size (caps); ++i) {
+    structure = gst_caps_get_structure (caps, i);
+    gst_structure_fixate_field_nearest_int (structure, "width",
+        v4l_src->capture_width);
+    gst_structure_fixate_field_nearest_int (structure, "height",
+        v4l_src->capture_height);
+    gst_structure_fixate_field_nearest_fraction (structure, "framerate",
+        v4l_src->fps_n, v4l_src->fps_d);
+    gst_structure_fixate_field_nearest_fraction (structure,
+        "pixel-aspect-ratio", 1, 1);
+
+    gst_structure_set (structure, "format", GST_TYPE_FOURCC, fourcc, NULL);
+  }
+  GST_INFO ("capture: %d, %d, fixrate :%s\n", v4l_src->capture_width,
+      v4l_src->capture_height, gst_caps_to_string (caps));
+  gst_object_unref (v4l_src);
+
+}
+
+/*=============================================================================
+FUNCTION:   mfw_gst_tvsrc_init   
+        
+DESCRIPTION:     create the pad template that has been registered with the 
+                element class in the _base_init and do library table 
+                initialization      
+
+ARGUMENTS PASSED:
+        context  -    pointer to TVSRC element structure      
+  
+RETURN VALUE:       None
+      
+PRE-CONDITIONS:     _base_init and _class_init are called 
+ 
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=============================================================================*/
+static void
+mfw_gst_tvsrc_init (MFWGstTVSRC * v4l_src, MFWGstTVSRCClass * klass)
+{
+  v4l_src->capture_width = 176;
+  v4l_src->capture_height = 144;
+  v4l_src->fps_n = 30;
+  v4l_src->fps_d = 1;
+  v4l_src->fd_v4l = -1;
+  v4l_src->count = 0;
+  v4l_src->buffer_size = 0;
+  v4l_src->offset = 0;
+  v4l_src->crop_pixel = 0;
+  v4l_src->rotate = 0;
+  v4l_src->preview = FALSE;
+  v4l_src->preview_width = 160;
+  v4l_src->preview_height = 128;
+  v4l_src->preview_top = 0;
+  v4l_src->preview_left = 0;
+  v4l_src->sensor_width = 1280;
+  v4l_src->sensor_height = 1024;
+  v4l_src->capture_mode = 0;
+  v4l_src->bg = FALSE;
+  v4l_src->g_display_lcd = 0;
+  v4l_src->queue_size = DEFAULT_QUEUE_SIZE;
+  v4l_src->start = FALSE;
+  v4l_src->tv_in = TRUE;        /* */
+  if (v4l_src->tv_in) {
+    v4l_src->capture_width = 0;
+    v4l_src->capture_height = 0;
+    v4l_src->fps_n = 1;
+    v4l_src->g_display_lcd = 3;
+  }
+#ifdef MX27
+  v4l_src->devicename = g_strdup ("/dev/v4l/video0");
+#else
+  v4l_src->devicename = g_strdup ("/dev/video0");
+#endif
+  v4l_src->buf_pools = g_malloc (sizeof (GstBuffer *) * v4l_src->queue_size);
+
+  gst_pad_set_fixatecaps_function (GST_BASE_SRC_PAD (v4l_src),
+      mfw_gst_tvsrc_fixate);
+  gst_base_src_set_live (GST_BASE_SRC (v4l_src), TRUE);
+
+#define MFW_GST_tvsrc_PLUGIN VERSION
+  PRINT_PLUGIN_VERSION (MFW_GST_tvsrc_PLUGIN);
+  return;
+}
+
+/*=============================================================================
+FUNCTION:   mfw_gst_tvsrc_class_init    
+        
+DESCRIPTION:     Initialise the class only once (specifying what signals,
+                arguments and virtual functions the class has and setting up 
+                global state)    
+     
+
+ARGUMENTS PASSED:
+       klass   -   pointer to mp3decoder element class
+        
+RETURN VALUE:        None
+PRE-CONDITIONS:      None
+POST-CONDITIONS:     None
+IMPORTANT NOTES:     None
+=============================================================================*/
+static void
+mfw_gst_tvsrc_class_init (MFWGstTVSRCClass * klass)
+{
+
+  GObjectClass *gobject_class;
+  GstBaseSrcClass *basesrc_class;
+  GstPushSrcClass *pushsrc_class;
+
+  gobject_class = (GObjectClass *) klass;
+  basesrc_class = (GstBaseSrcClass *) klass;
+  pushsrc_class = (GstPushSrcClass *) klass;
+
+
+  gobject_class->set_property = mfw_gst_tvsrc_set_property;
+  gobject_class->get_property = mfw_gst_tvsrc_get_property;
+
+  g_object_class_install_property (gobject_class, MFW_V4L_SRC_FRAMERATE_NUM,
+      g_param_spec_int ("fps-n",
+          "fps_n",
+          "gets the numerator of the framerate at which"
+          "the input stream is to be captured",
+          0, G_MAXINT, 0, G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class, MFW_V4L_SRC_FRAMERATE_DEN,
+      g_param_spec_int ("fps-d",
+          "fps_d",
+          "gets the denominator of the framerate at which"
+          "the input stream is to be captured",
+          1, G_MAXINT, 1, G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class, MFW_V4L_SRC_DEVICE,
+      g_param_spec_string ("device", "Device", "Device location",
+          NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, MFW_V4L_SRC_QUEUE_SIZE,
+      g_param_spec_int ("queue-size",
+          "queue-size",
+          "v4l2 request buffer number", 0, G_MAXINT, 5, G_PARAM_READWRITE));
+
+  basesrc_class->get_caps = mfw_gst_tvsrc_get_caps;
+  basesrc_class->set_caps = mfw_gst_tvsrc_set_caps;
+  basesrc_class->start = mfw_gst_tvsrc_start;
+  basesrc_class->stop = mfw_gst_tvsrc_stop;
+  pushsrc_class->create = mfw_gst_tvsrc_create;
+  return;
+}
+
+
+/*=============================================================================
+FUNCTION:   mfw_gst_tvsrc_base_init   
+        
+DESCRIPTION:     v4l source element details are registered with the plugin during
+                _base_init ,This function will initialise the class and child 
+                class properties during each new child class creation       
+
+ARGUMENTS PASSED:
+        Klass   -   void pointer
+  
+RETURN VALUE:        None
+PRE-CONDITIONS:      None
+POST-CONDITIONS:     None
+IMPORTANT NOTES:     None
+=============================================================================*/
+static void
+mfw_gst_tvsrc_base_init (gpointer g_class)
+{
+
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
+
+  FSL_GST_ELEMENT_SET_DETAIL_SIMPLE (element_class, "v4l2 based tv src",
+      "Src/Video", "Capture by using tv-in");
+
+  gst_element_class_add_pad_template (element_class,
+      gst_pad_template_new ("src", GST_PAD_SRC, GST_PAD_ALWAYS,
+          gst_caps_new_any ()));
+
+  GST_DEBUG_CATEGORY_INIT (mfw_gst_tvsrc_debug, "tvsrc", 0,
+      "V4L2 tv src element");
+
+  return;
+}
+
+/*=============================================================================
+FUNCTION:   plugin_init
+
+DESCRIPTION:    special function , which is called as soon as the plugin or 
+                element is loaded and information returned by this function 
+                will be cached in central registry
+
+ARGUMENTS PASSED:
+        plugin     -    pointer to container that contains features loaded 
+                        from shared object module
+
+RETURN VALUE:
+        return TRUE or FALSE depending on whether it loaded initialized any 
+        dependency correctly
+
+PRE-CONDITIONS:      None
+POST-CONDITIONS:     None
+IMPORTANT NOTES:     None
+=============================================================================*/
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  if (!gst_element_register (plugin, "tvsrc", GST_RANK_PRIMARY,
+          MFW_GST_TYPE_TVSRC))
+    return FALSE;
+
+  return TRUE;
+}
+
+/*****************************************************************************/
+/*    This is used to define the entry point and meta data of plugin         */
+/*****************************************************************************/
+
+FSL_GST_PLUGIN_DEFINE ("tvsrc", "v4l2-based tv src", plugin_init);
--- /dev/null
+++ b/src/misc/tvsrc/src/mfw_gst_tvsrc.h
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.  
+ */
+
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Module Name:    mfw_gst_tvsrc.h
+ *
+ * Description:    Header file of TV Source (Capture) Plug-in for 
+ *                 GStreamer.
+ *
+ * Portability:    This code is written for Linux OS and Gstreamer
+ */
+
+/*
+ * Changelog: 
+ *
+ */
+
+
+/*=============================================================================
+                                INCLUDE FILES
+=============================================================================*/
+
+#ifndef _MFW_GST_TVSRC_H_
+#define _MFW_GST_TVSRC_H_
+
+/*=============================================================================
+                                CONSTANTS
+=============================================================================*/
+
+/*=============================================================================
+                                ENUMS
+=============================================================================*/
+
+/* None. */
+
+/*=============================================================================
+                                MACROS
+=============================================================================*/
+G_BEGIN_DECLS
+/* #defines don't like whitespacey bits */
+#define MFW_GST_TYPE_TVSRC (mfw_gst_tvsrc_get_type())
+#define MFW_GST_TVSRC(obj) \
+    (G_TYPE_CHECK_INSTANCE_CAST((obj),MFW_GST_TYPE_TVSRC,MFWGstTVSRC))
+#define MFW_GST_TVSRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),MFW_GST_TYPE_TVSRC,MFWGstTVSRCClass))
+#define MFW_GST_IS_TVSRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MFW_GST_TYPE_TVSRC))
+#define MFW_GST_IS_TVSRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),MFW_GST_TYPE_TVSRC))
+#define MFW_GST_TYPE_TVSRC_BUFFER (mfw_gst_tvsrc_buffer_get_type())
+#define MFW_GST_IS_TVSRC_BUFFER(obj) \
+    (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MFW_GST_TYPE_TVSRC_BUFFER))
+#define MFW_GST_TVSRC_BUFFER(obj) \
+    (G_TYPE_CHECK_INSTANCE_CAST ((obj), MFW_GST_TYPE_TVSRC_BUFFER, MFWGstTVSRCBuffer))
+#define MFW_GST_TVSRC_BUFFER_GET_CLASS(obj)  \
+    (G_TYPE_INSTANCE_GET_CLASS ((obj), MFW_GST_TYPE_TVSRC_BUFFER, MFWGstTVSRCBufferClass))
+/*=============================================================================
+                  STRUCTURES AND OTHER TYPEDEFS
+=============================================================================*/
+    typedef struct MFW_GST_TVSRC_INFO_S
+{
+
+  GstPushSrc element;
+  gint capture_width;           /* width to be captured */
+  gint capture_height;          /* height to be captured */
+  gint rotate;
+  gint crop_pixel;
+  gint fps_n;
+  gint fps_d;
+  GstBuffer **buffers;
+  void **buf_pools;
+  GstElementClass *parent_class;
+  guint32 offset;
+  guint32 buffer_size;
+  guint32 count;
+  gboolean preview;
+  gint preview_width;
+  gint preview_height;
+  gint preview_top;
+  gint preview_left;
+  gint fd_v4l;
+  gint fd_v4l_out;
+  gint sensor_width;
+  gint sensor_height;
+  GstClockTime time_per_frame;
+  GstClockTime last_ts;
+  gint capture_mode;
+  gboolean bg;
+  char *devicename;
+  int g_display_lcd;
+  int queue_size;               /* v4l request buffer number */
+  GList *free_pool;             /* pool for v4l buffers. */
+  gboolean start;
+  gboolean tv_in;
+  v4l2_std_id id;
+} MFWGstTVSRC;
+
+typedef struct MFW_GST_TVSRC_INFO_CLASS_S
+{
+  GstPushSrcClass parent_class;
+} MFWGstTVSRCClass;
+
+struct v4l2_mxc_offset
+{
+  uint32_t u_offset;
+  uint32_t v_offset;
+};
+
+
+typedef struct _MFWGstTVSRCBuffer MFWGstTVSRCBuffer;
+typedef struct _MFWGstTVSRCBufferClass MFWGstTVSRCBufferClass;
+
+struct _MFWGstTVSRCBuffer
+{
+  GstBuffer buffer;
+  struct v4l2_buffer v4l2_buf;
+  MFWGstTVSRC *TVSRCcontext;
+  gint num;
+};
+
+
+
+
+
+
+
+
+
+/*=============================================================================
+                  GLOBAL VARIABLE DECLARATIONS
+=============================================================================*/
+
+/* None. */
+
+/*=============================================================================
+                  FUNCTION PROTOTYPES
+=============================================================================*/
+
+extern GType mfw_gst_tvsrc_get_type (void);
+
+G_END_DECLS
+/*===========================================================================*/
+#endif /* _MFW_GST_TVSRC_H_ */
