diff --git a/MAINTAINERS b/MAINTAINERS
index 8603085..7ab0fa6 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -1299,6 +1299,10 @@ Dimitar Penev <dpn@switchfin.org>
 	BR4 Appliance	BF537
 	PR1 Appliance	BF537
 
+Tim Harvey <tharvey@gateworks.com>
+
+	gw_ventana      i.MX6Q
+
 #########################################################################
 # NDS32 Systems:							#
 #									#
diff --git a/Makefile b/Makefile
index 55bd55c..697333b 100644
--- a/Makefile
+++ b/Makefile
@@ -335,7 +335,7 @@ ifneq ($(CONFIG_AM33XX)$(CONFIG_OMAP34XX)$(CONFIG_OMAP44XX)$(CONFIG_OMAP54XX),)
 LIBS-y += $(CPUDIR)/omap-common/libomap-common.o
 endif
 
-ifneq (,$(filter $(SOC), mx25 mx27 mx5 mx6 mx31 mx35))
+ifneq (,$(filter $(SOC), mx25 mx27 mx5 mx6 mx31 mx35 mxs))
 LIBS-y += arch/$(ARCH)/imx-common/libimx-common.o
 endif
 
diff --git a/arch/arm/cpu/arm926ejs/mxs/mxs.c b/arch/arm/cpu/arm926ejs/mxs/mxs.c
index e2b4196..a5e388b 100644
--- a/arch/arm/cpu/arm926ejs/mxs/mxs.c
+++ b/arch/arm/cpu/arm926ejs/mxs/mxs.c
@@ -30,7 +30,7 @@
 #include <asm/errno.h>
 #include <asm/io.h>
 #include <asm/arch/clock.h>
-#include <asm/arch/dma.h>
+#include <asm/imx-common/dma.h>
 #include <asm/arch/gpio.h>
 #include <asm/arch/iomux.h>
 #include <asm/arch/imx-regs.h>
@@ -39,12 +39,6 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-/* 1 second delay should be plenty of time for block reset. */
-#define	RESET_MAX_TIMEOUT	1000000
-
-#define	MXS_BLOCK_SFTRST	(1 << 31)
-#define	MXS_BLOCK_CLKGATE	(1 << 30)
-
 /* Lowlevel init isn't used on i.MX28, so just have a dummy here */
 inline void lowlevel_init(void) {}
 
@@ -82,63 +76,6 @@ void enable_caches(void)
 #endif
 }
 
-int mxs_wait_mask_set(struct mxs_register_32 *reg, uint32_t mask, unsigned
-								int timeout)
-{
-	while (--timeout) {
-		if ((readl(&reg->reg) & mask) == mask)
-			break;
-		udelay(1);
-	}
-
-	return !timeout;
-}
-
-int mxs_wait_mask_clr(struct mxs_register_32 *reg, uint32_t mask, unsigned
-								int timeout)
-{
-	while (--timeout) {
-		if ((readl(&reg->reg) & mask) == 0)
-			break;
-		udelay(1);
-	}
-
-	return !timeout;
-}
-
-int mxs_reset_block(struct mxs_register_32 *reg)
-{
-	/* Clear SFTRST */
-	writel(MXS_BLOCK_SFTRST, &reg->reg_clr);
-
-	if (mxs_wait_mask_clr(reg, MXS_BLOCK_SFTRST, RESET_MAX_TIMEOUT))
-		return 1;
-
-	/* Clear CLKGATE */
-	writel(MXS_BLOCK_CLKGATE, &reg->reg_clr);
-
-	/* Set SFTRST */
-	writel(MXS_BLOCK_SFTRST, &reg->reg_set);
-
-	/* Wait for CLKGATE being set */
-	if (mxs_wait_mask_set(reg, MXS_BLOCK_CLKGATE, RESET_MAX_TIMEOUT))
-		return 1;
-
-	/* Clear SFTRST */
-	writel(MXS_BLOCK_SFTRST, &reg->reg_clr);
-
-	if (mxs_wait_mask_clr(reg, MXS_BLOCK_SFTRST, RESET_MAX_TIMEOUT))
-		return 1;
-
-	/* Clear CLKGATE */
-	writel(MXS_BLOCK_CLKGATE, &reg->reg_clr);
-
-	if (mxs_wait_mask_clr(reg, MXS_BLOCK_CLKGATE, RESET_MAX_TIMEOUT))
-		return 1;
-
-	return 0;
-}
-
 void mx28_fixup_vt(uint32_t start_addr)
 {
 	uint32_t *vt = (uint32_t *)0x20;
diff --git a/arch/arm/cpu/armv7/mx6/clock.c b/arch/arm/cpu/armv7/mx6/clock.c
index a50db70..7ad2f78 100644
--- a/arch/arm/cpu/armv7/mx6/clock.c
+++ b/arch/arm/cpu/armv7/mx6/clock.c
@@ -50,6 +50,21 @@ void enable_usboh3_clk(unsigned char enable)
 
 }
 
+#ifdef CONFIG_IMX_OTP
+void enable_otp_clk(unsigned char enable)
+{
+	u32 reg;
+
+	reg = __raw_readl(&imx_ccm->CCGR2);
+	if (enable)
+		reg |= MXC_CCM_CCGR2_OCOTP_CTRL_MASK;
+	else
+		reg &= ~(MXC_CCM_CCGR2_OCOTP_CTRL_MASK);
+	__raw_writel(reg, &imx_ccm->CCGR2);
+
+}
+#endif
+
 #ifdef CONFIG_I2C_MXC
 /* i2c_num can be from 0 - 2 */
 int enable_i2c_clk(unsigned char enable, unsigned i2c_num)
diff --git a/arch/arm/cpu/armv7/mx6/soc.c b/arch/arm/cpu/armv7/mx6/soc.c
index a8aad5d..1e89645 100644
--- a/arch/arm/cpu/armv7/mx6/soc.c
+++ b/arch/arm/cpu/armv7/mx6/soc.c
@@ -30,6 +30,8 @@
 #include <asm/arch/clock.h>
 #include <asm/arch/sys_proto.h>
 #include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/dma.h>
+#include <stdbool.h>
 
 struct scu_regs {
 	u32	ctrl;
@@ -127,6 +129,11 @@ int arch_cpu_init(void)
 
 	set_vddsoc(1200);	/* Set VDDSOC to 1.2V */
 
+#ifdef CONFIG_APBH_DMA
+	/* Start APBH DMA */
+	mxs_dma_init();
+#endif
+
 	return 0;
 }
 
diff --git a/arch/arm/imx-common/Makefile b/arch/arm/imx-common/Makefile
index 6309fcd..63a04a9 100644
--- a/arch/arm/imx-common/Makefile
+++ b/arch/arm/imx-common/Makefile
@@ -31,7 +31,11 @@ ifeq ($(SOC),$(filter $(SOC),mx5 mx6))
 COBJS-y	= iomux-v3.o timer.o cpu.o speed.o
 COBJS-$(CONFIG_I2C_MXC) += i2c-mxv7.o
 endif
+ifeq ($(SOC),$(filter $(SOC),mx6 mxs))
+COBJS-y	+= misc.o
+endif
 COBJS-$(CONFIG_CMD_BMODE) += cmd_bmode.o
+COBJS-$(CONFIG_CMD_HDMIDETECT) += cmd_hdmidet.o
 COBJS	:= $(sort $(COBJS-y))
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
diff --git a/arch/arm/imx-common/cmd_hdmidet.c b/arch/arm/imx-common/cmd_hdmidet.c
new file mode 100644
index 0000000..f7dff3b
--- /dev/null
+++ b/arch/arm/imx-common/cmd_hdmidet.c
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2012 Boundary Devices Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/io.h>
+
+int do_hdmidet(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	u8 reg = __raw_readb(HDMI_ARB_BASE_ADDR+HDMI_PHY_STAT0);
+	return (reg&HDMI_PHY_HPD)
+		? 0 : 1;
+}
+
+U_BOOT_CMD(hdmidet, 1, 1, do_hdmidet,
+	"detect HDMI monitor",
+	""
+);
diff --git a/arch/arm/imx-common/misc.c b/arch/arm/imx-common/misc.c
new file mode 100644
index 0000000..220785c
--- /dev/null
+++ b/arch/arm/imx-common/misc.c
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2013 Stefan Roese <sr@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/imx-common/regs-common.h>
+
+/* 1 second delay should be plenty of time for block reset. */
+#define	RESET_MAX_TIMEOUT	1000000
+
+#define	MXS_BLOCK_SFTRST	(1 << 31)
+#define	MXS_BLOCK_CLKGATE	(1 << 30)
+
+int mxs_wait_mask_set(struct mxs_register_32 *reg, uint32_t mask, unsigned
+								int timeout)
+{
+	while (--timeout) {
+		if ((readl(&reg->reg) & mask) == mask)
+			break;
+		udelay(1);
+	}
+
+	return !timeout;
+}
+
+int mxs_wait_mask_clr(struct mxs_register_32 *reg, uint32_t mask, unsigned
+								int timeout)
+{
+	while (--timeout) {
+		if ((readl(&reg->reg) & mask) == 0)
+			break;
+		udelay(1);
+	}
+
+	return !timeout;
+}
+
+int mxs_reset_block(struct mxs_register_32 *reg)
+{
+	/* Clear SFTRST */
+	writel(MXS_BLOCK_SFTRST, &reg->reg_clr);
+
+	if (mxs_wait_mask_clr(reg, MXS_BLOCK_SFTRST, RESET_MAX_TIMEOUT))
+		return 1;
+
+	/* Clear CLKGATE */
+	writel(MXS_BLOCK_CLKGATE, &reg->reg_clr);
+
+	/* Set SFTRST */
+	writel(MXS_BLOCK_SFTRST, &reg->reg_set);
+
+	/* Wait for CLKGATE being set */
+	if (mxs_wait_mask_set(reg, MXS_BLOCK_CLKGATE, RESET_MAX_TIMEOUT))
+		return 1;
+
+	/* Clear SFTRST */
+	writel(MXS_BLOCK_SFTRST, &reg->reg_clr);
+
+	if (mxs_wait_mask_clr(reg, MXS_BLOCK_SFTRST, RESET_MAX_TIMEOUT))
+		return 1;
+
+	/* Clear CLKGATE */
+	writel(MXS_BLOCK_CLKGATE, &reg->reg_clr);
+
+	if (mxs_wait_mask_clr(reg, MXS_BLOCK_CLKGATE, RESET_MAX_TIMEOUT))
+		return 1;
+
+	return 0;
+}
diff --git a/arch/arm/include/asm/arch-mx6/crm_regs.h b/arch/arm/include/asm/arch-mx6/crm_regs.h
index d670f30..43021ee 100644
--- a/arch/arm/include/asm/arch-mx6/crm_regs.h
+++ b/arch/arm/include/asm/arch-mx6/crm_regs.h
@@ -20,6 +20,17 @@
 #ifndef __ARCH_ARM_MACH_MX6_CCM_REGS_H__
 #define __ARCH_ARM_MACH_MX6_CCM_REGS_H__
 
+#define CCM_CCGR0              0x020C4068
+#define CCM_CCGR1              0x020C406c
+#define CCM_CCGR2              0x020C4070
+#define CCM_CCGR3              0x020C4074
+#define CCM_CCGR4              0x020C4078
+#define CCM_CCGR5              0x020C407c
+#define CCM_CCGR6              0x020C4080
+
+#define PMU_MISC2              0x020C8170
+
+#ifndef __ASSEMBLY__
 struct mxc_ccm_reg {
 	u32 ccr;	/* 0x0000 */
 	u32 ccdr;
@@ -105,6 +116,7 @@ struct mxc_ccm_reg {
 	u32 analog_pfd_528_clr;
 	u32 analog_pfd_528_tog;
 };
+#endif
 
 /* Define the bits in register CCR */
 #define MXC_CCM_CCR_RBC_EN				(1 << 27)
@@ -250,10 +262,13 @@ struct mxc_ccm_reg {
 /* Define the bits in register CS2CDR */
 #define MXC_CCM_CS2CDR_ENFC_CLK_PODF_MASK		(0x3F << 21)
 #define MXC_CCM_CS2CDR_ENFC_CLK_PODF_OFFSET		21
+#define MXC_CCM_CS2CDR_ENFC_CLK_PODF(v)			(((v) & 0x3f) << 21)
 #define MXC_CCM_CS2CDR_ENFC_CLK_PRED_MASK		(0x7 << 18)
 #define MXC_CCM_CS2CDR_ENFC_CLK_PRED_OFFSET		18
+#define MXC_CCM_CS2CDR_ENFC_CLK_PRED(v)			(((v) & 0x7) << 18)
 #define MXC_CCM_CS2CDR_ENFC_CLK_SEL_MASK		(0x3 << 16)
 #define MXC_CCM_CS2CDR_ENFC_CLK_SEL_OFFSET		16
+#define MXC_CCM_CS2CDR_ENFC_CLK_SEL(v)			(((v) & 0x3) << 16)
 #define MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK		(0x7 << 12)
 #define MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET		12
 #define MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK		(0x7 << 9)
@@ -403,8 +418,8 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR0_AIPS_TZ1_MASK			(3<<MXC_CCM_CCGR0_AIPS_TZ1_OFFSET)
 #define MXC_CCM_CCGR0_AIPS_TZ2_OFFSET			2
 #define MXC_CCM_CCGR0_AIPS_TZ2_MASK			(3<<MXC_CCM_CCGR0_AIPS_TZ2_OFFSET)
-#define MXC_CCM_CCGR0_APBHDMA HCLK_OFFSET		4
-#define MXC_CCM_CCGR0_AMASK				(3<<MXC_CCM_CCGR0_APBHDMA)
+#define MXC_CCM_CCGR0_APBHDMA_OFFSET			4
+#define MXC_CCM_CCGR0_APBHDMA_MASK			(3<<MXC_CCM_CCGR0_APBHDMA_OFFSET)
 #define MXC_CCM_CCGR0_ASRC_OFFSET			6
 #define MXC_CCM_CCGR0_ASRC_MASK				(3<<MXC_CCM_CCGR0_ASRC_OFFSET)
 #define MXC_CCM_CCGR0_CAAM_SECURE_MEM_OFFSET		8
diff --git a/arch/arm/include/asm/arch-mx6/imx-regs.h b/arch/arm/include/asm/arch-mx6/imx-regs.h
index 3eb0081..306212f 100644
--- a/arch/arm/include/asm/arch-mx6/imx-regs.h
+++ b/arch/arm/include/asm/arch-mx6/imx-regs.h
@@ -38,6 +38,10 @@
 #define DTCP_ARB_BASE_ADDR              0x00138000
 #define DTCP_ARB_END_ADDR               0x0013BFFF
 
+#define MXS_APBH_BASE			APBH_DMA_ARB_BASE_ADDR
+#define MXS_GPMI_BASE			(APBH_DMA_ARB_BASE_ADDR + 0x02000)
+#define MXS_BCH_BASE			(APBH_DMA_ARB_BASE_ADDR + 0x04000)
+
 /* GPV - PL301 configuration ports */
 #define GPV2_BASE_ADDR			0x00200000
 #define GPV3_BASE_ADDR			0x00300000
@@ -601,5 +605,44 @@ struct iomuxc_base_regs {
 	u32     daisy[104];     /* 0x7b0..94c */
 };
 
+#define BP_OCOTP_CTRL_WR_UNLOCK		16
+#define BM_OCOTP_CTRL_WR_UNLOCK		0xFFFF0000
+#define BV_OCOTP_CTRL_WR_UNLOCK__KEY	0x3E77
+#define BM_OCOTP_CTRL_RELOAD_SHADOWS	0x00000400
+#define BM_OCOTP_CTRL_ERROR		0x00000200
+#define BM_OCOTP_CTRL_BUSY		0x00000100
+#define BP_OCOTP_CTRL_ADDR		0
+#define BM_OCOTP_CTRL_ADDR		0x0000007F
+
+#define BP_OCOTP_TIMING_STROBE_READ	16
+#define BM_OCOTP_TIMING_STROBE_READ	0x003F0000
+#define BP_OCOTP_TIMING_RELAX		12
+#define BM_OCOTP_TIMING_RELAX		0x0000F000
+#define BP_OCOTP_TIMING_STROBE_PROG     0
+#define BM_OCOTP_TIMING_STROBE_PROG	0x00000FFF
+
+#define BM_OCOTP_READ_CTRL_READ_FUSE	0x00000001
+
+struct src_regs {
+	u32	scr;		/* 0x00 */
+	u32	sbmr1;		/* 0x04 */
+	u32	srsr;		/* 0x08 */
+	u32	reserved1;	/* 0x0c */
+	u32	reserved2;	/* 0x10 */
+	u32	sisr;		/* 0x14 */
+	u32	simr;		/* 0x18 */
+	u32	sbmr2;		/* 0x1c */
+	u32	gpr1;		/* 0x20 */
+	u32	gpr2;		/* 0x24 */
+	u32	gpr3;		/* 0x28 */
+	u32	gpr4;		/* 0x2c */
+	u32	gpr5;		/* 0x30 */
+	u32	gpr6;		/* 0x34 */
+	u32	gpr7;		/* 0x38 */
+	u32	gpr8;		/* 0x3c */
+	u32	gpr9;		/* 0x40 */
+	u32	gpr10;		/* 0x44 */
+};
+
 #endif /* __ASSEMBLER__*/
 #endif /* __ASM_ARCH_MX6_IMX_REGS_H__ */
diff --git a/arch/arm/include/asm/arch-mx6/iomux.h b/arch/arm/include/asm/arch-mx6/iomux.h
index d23abd7..d67f600 100644
--- a/arch/arm/include/asm/arch-mx6/iomux.h
+++ b/arch/arm/include/asm/arch-mx6/iomux.h
@@ -16,6 +16,11 @@
 
 #ifndef __ASM_ARCH_IOMUX_H__
 #define __ASM_ARCH_IOMUX_H__
+
+#define MX6_IOMUXC_GPR4		0x020e0010
+#define MX6_IOMUXC_GPR6		0x020e0018
+#define MX6_IOMUXC_GPR7		0x020e001c
+
 /*
  * IOMUXC_GPR13 bit fields
  */
diff --git a/arch/arm/include/asm/arch-mx6/mx6-ddr.h b/arch/arm/include/asm/arch-mx6/mx6-ddr.h
new file mode 100644
index 0000000..1fdc1d4
--- /dev/null
+++ b/arch/arm/include/asm/arch-mx6/mx6-ddr.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2013 Boundary Devices Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef __ASM_ARCH_MX6_DDR_H__
+#define __ASM_ARCH_MX6_DDR_H__
+
+#ifdef CONFIG_MX6Q
+#include "mx6q-ddr.h"
+#else
+#if defined(CONFIG_MX6DL) || defined(CONFIG_MX6S)
+#include "mx6dl-ddr.h"
+#else
+#error "Please select cpu"
+#endif	/* CONFIG_MX6DL or CONFIG_MX6S */
+#endif	/* CONFIG_MX6Q */
+
+#define MX6_MMDC_P0_MDCTL	0x021b0000
+#define MX6_MMDC_P0_MDPDC	0x021b0004
+#define MX6_MMDC_P0_MDOTC	0x021b0008
+#define MX6_MMDC_P0_MDCFG0	0x021b000c
+#define MX6_MMDC_P0_MDCFG1	0x021b0010
+#define MX6_MMDC_P0_MDCFG2	0x021b0014
+#define MX6_MMDC_P0_MDMISC	0x021b0018
+#define MX6_MMDC_P0_MDSCR	0x021b001c
+#define MX6_MMDC_P0_MDREF	0x021b0020
+#define MX6_MMDC_P0_MDRWD	0x021b002c
+#define MX6_MMDC_P0_MDOR	0x021b0030
+#define MX6_MMDC_P0_MDASP	0x021b0040
+#define MX6_MMDC_P0_MAPSR	0x021b0404
+#define MX6_MMDC_P0_MPZQHWCTRL	0x021b0800
+#define MX6_MMDC_P0_MPWLDECTRL0	0x021b080c
+#define MX6_MMDC_P0_MPWLDECTRL1	0x021b0810
+#define MX6_MMDC_P0_MPODTCTRL	0x021b0818
+#define MX6_MMDC_P0_MPRDDQBY0DL	0x021b081c
+#define MX6_MMDC_P0_MPRDDQBY1DL	0x021b0820
+#define MX6_MMDC_P0_MPRDDQBY2DL	0x021b0824
+#define MX6_MMDC_P0_MPRDDQBY3DL	0x021b0828
+#define MX6_MMDC_P0_MPDGCTRL0	0x021b083c
+#define MX6_MMDC_P0_MPDGCTRL1	0x021b0840
+#define MX6_MMDC_P0_MPRDDLCTL	0x021b0848
+#define MX6_MMDC_P0_MPWRDLCTL	0x021b0850
+#define MX6_MMDC_P0_MPMUR0	0x021b08b8
+
+#define MX6_MMDC_P1_MDCTL	0x021b4000
+#define MX6_MMDC_P1_MDPDC	0x021b4004
+#define MX6_MMDC_P1_MDOTC	0x021b4008
+#define MX6_MMDC_P1_MDCFG0	0x021b400c
+#define MX6_MMDC_P1_MDCFG1	0x021b4010
+#define MX6_MMDC_P1_MDCFG2	0x021b4014
+#define MX6_MMDC_P1_MDMISC	0x021b4018
+#define MX6_MMDC_P1_MDSCR	0x021b401c
+#define MX6_MMDC_P1_MDREF	0x021b4020
+#define MX6_MMDC_P1_MDRWD	0x021b402c
+#define MX6_MMDC_P1_MDOR	0x021b4030
+#define MX6_MMDC_P1_MDASP	0x021b4040
+#define MX6_MMDC_P1_MAPSR	0x021b4404
+#define MX6_MMDC_P1_MPZQHWCTRL	0x021b4800
+#define MX6_MMDC_P1_MPWLDECTRL0	0x021b480c
+#define MX6_MMDC_P1_MPWLDECTRL1	0x021b4810
+#define MX6_MMDC_P1_MPODTCTRL	0x021b4818
+#define MX6_MMDC_P1_MPRDDQBY0DL	0x021b481c
+#define MX6_MMDC_P1_MPRDDQBY1DL	0x021b4820
+#define MX6_MMDC_P1_MPRDDQBY2DL	0x021b4824
+#define MX6_MMDC_P1_MPRDDQBY3DL	0x021b4828
+#define MX6_MMDC_P1_MPDGCTRL0	0x021b483c
+#define MX6_MMDC_P1_MPDGCTRL1	0x021b4840
+#define MX6_MMDC_P1_MPRDDLCTL	0x021b4848
+#define MX6_MMDC_P1_MPWRDLCTL	0x021b4850
+#define MX6_MMDC_P1_MPMUR0	0x021b48b8
+
+#endif	/*__ASM_ARCH_MX6_DDR_H__ */
diff --git a/arch/arm/include/asm/arch-mx6/mx6dl-ddr.h b/arch/arm/include/asm/arch-mx6/mx6dl-ddr.h
new file mode 100644
index 0000000..325da33
--- /dev/null
+++ b/arch/arm/include/asm/arch-mx6/mx6dl-ddr.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2013 Boundary Devices Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef __ASM_ARCH_MX6DLS_DDR_H__
+#define __ASM_ARCH_MX6DLS_DDR_H__
+
+#ifndef CONFIG_MX6DL
+#ifndef CONFIG_MX6S
+#error "wrong CPU"
+#endif
+#endif
+
+#define MX6_IOM_DRAM_DQM0	0x020e0470
+#define MX6_IOM_DRAM_DQM1	0x020e0474
+#define MX6_IOM_DRAM_DQM2	0x020e0478
+#define MX6_IOM_DRAM_DQM3	0x020e047c
+#define MX6_IOM_DRAM_DQM4	0x020e0480
+#define MX6_IOM_DRAM_DQM5	0x020e0484
+#define MX6_IOM_DRAM_DQM6	0x020e0488
+#define MX6_IOM_DRAM_DQM7	0x020e048c
+
+#define MX6_IOM_DRAM_CAS	0x020e0464
+#define MX6_IOM_DRAM_RAS	0x020e0490
+#define MX6_IOM_DRAM_RESET	0x020e0494
+#define MX6_IOM_DRAM_SDCLK_0	0x020e04ac
+#define MX6_IOM_DRAM_SDCLK_1	0x020e04b0
+#define MX6_IOM_DRAM_SDBA2	0x020e04a0
+#define MX6_IOM_DRAM_SDCKE0	0x020e04a4
+#define MX6_IOM_DRAM_SDCKE1	0x020e04a8
+#define MX6_IOM_DRAM_SDODT0	0x020e04b4
+#define MX6_IOM_DRAM_SDODT1	0x020e04b8
+
+#define MX6_IOM_DRAM_SDQS0	0x020e04bc
+#define MX6_IOM_DRAM_SDQS1	0x020e04c0
+#define MX6_IOM_DRAM_SDQS2	0x020e04c4
+#define MX6_IOM_DRAM_SDQS3	0x020e04c8
+#define MX6_IOM_DRAM_SDQS4	0x020e04cc
+#define MX6_IOM_DRAM_SDQS5	0x020e04d0
+#define MX6_IOM_DRAM_SDQS6	0x020e04d4
+#define MX6_IOM_DRAM_SDQS7	0x020e04d8
+
+#define MX6_IOM_GRP_B0DS	0x020e0764
+#define MX6_IOM_GRP_B1DS	0x020e0770
+#define MX6_IOM_GRP_B2DS	0x020e0778
+#define MX6_IOM_GRP_B3DS	0x020e077c
+#define MX6_IOM_GRP_B4DS	0x020e0780
+#define MX6_IOM_GRP_B5DS	0x020e0784
+#define MX6_IOM_GRP_B6DS	0x020e078c
+#define MX6_IOM_GRP_B7DS	0x020e0748
+#define MX6_IOM_GRP_ADDDS	0x020e074c
+#define MX6_IOM_DDRMODE_CTL	0x020e0750
+#define MX6_IOM_GRP_DDRPKE	0x020e0754
+#define MX6_IOM_GRP_DDRMODE	0x020e0760
+#define MX6_IOM_GRP_CTLDS	0x020e076c
+#define MX6_IOM_GRP_DDR_TYPE	0x020e0774
+
+#endif	/*__ASM_ARCH_MX6S_DDR_H__ */
diff --git a/arch/arm/include/asm/arch-mx6/mx6q-ddr.h b/arch/arm/include/asm/arch-mx6/mx6q-ddr.h
new file mode 100644
index 0000000..e51727c
--- /dev/null
+++ b/arch/arm/include/asm/arch-mx6/mx6q-ddr.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2013 Boundary Devices Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef __ASM_ARCH_MX6Q_DDR_H__
+#define __ASM_ARCH_MX6Q_DDR_H__
+
+#ifndef CONFIG_MX6Q
+#error "wrong CPU"
+#endif
+
+#define MX6_IOM_DRAM_DQM0	0x020e05ac
+#define MX6_IOM_DRAM_DQM1	0x020e05b4
+#define MX6_IOM_DRAM_DQM2	0x020e0528
+#define MX6_IOM_DRAM_DQM3	0x020e0520
+#define MX6_IOM_DRAM_DQM4	0x020e0514
+#define MX6_IOM_DRAM_DQM5	0x020e0510
+#define MX6_IOM_DRAM_DQM6	0x020e05bc
+#define MX6_IOM_DRAM_DQM7	0x020e05c4
+
+#define MX6_IOM_DRAM_CAS	0x020e056c
+#define MX6_IOM_DRAM_RAS	0x020e0578
+#define MX6_IOM_DRAM_RESET	0x020e057c
+#define MX6_IOM_DRAM_SDCLK_0	0x020e0588
+#define MX6_IOM_DRAM_SDCLK_1	0x020e0594
+#define MX6_IOM_DRAM_SDBA2	0x020e058c
+#define MX6_IOM_DRAM_SDCKE0	0x020e0590
+#define MX6_IOM_DRAM_SDCKE1	0x020e0598
+#define MX6_IOM_DRAM_SDODT0	0x020e059c
+#define MX6_IOM_DRAM_SDODT1	0x020e05a0
+
+#define MX6_IOM_DRAM_SDQS0	0x020e05a8
+#define MX6_IOM_DRAM_SDQS1	0x020e05b0
+#define MX6_IOM_DRAM_SDQS2	0x020e0524
+#define MX6_IOM_DRAM_SDQS3	0x020e051c
+#define MX6_IOM_DRAM_SDQS4	0x020e0518
+#define MX6_IOM_DRAM_SDQS5	0x020e050c
+#define MX6_IOM_DRAM_SDQS6	0x020e05b8
+#define MX6_IOM_DRAM_SDQS7	0x020e05c0
+
+#define MX6_IOM_GRP_B0DS	0x020e0784
+#define MX6_IOM_GRP_B1DS	0x020e0788
+#define MX6_IOM_GRP_B2DS	0x020e0794
+#define MX6_IOM_GRP_B3DS	0x020e079c
+#define MX6_IOM_GRP_B4DS	0x020e07a0
+#define MX6_IOM_GRP_B5DS	0x020e07a4
+#define MX6_IOM_GRP_B6DS	0x020e07a8
+#define MX6_IOM_GRP_B7DS	0x020e0748
+#define MX6_IOM_GRP_ADDDS	0x020e074c
+#define MX6_IOM_DDRMODE_CTL	0x020e0750
+#define MX6_IOM_GRP_DDRPKE	0x020e0758
+#define MX6_IOM_GRP_DDRMODE	0x020e0774
+#define MX6_IOM_GRP_CTLDS	0x020e078c
+#define MX6_IOM_GRP_DDR_TYPE	0x020e0798
+
+#endif	/*__ASM_ARCH_MX6Q_DDR_H__ */
diff --git a/arch/arm/include/asm/arch-mx6/sys_proto.h b/arch/arm/include/asm/arch-mx6/sys_proto.h
index 3193297..3f4764a 100644
--- a/arch/arm/include/asm/arch-mx6/sys_proto.h
+++ b/arch/arm/include/asm/arch-mx6/sys_proto.h
@@ -24,6 +24,8 @@
 #ifndef _SYS_PROTO_H_
 #define _SYS_PROTO_H_
 
+#include <asm/imx-common/regs-common.h>
+
 #define MXC_CPU_MX51		0x51
 #define MXC_CPU_MX53		0x53
 #define MXC_CPU_MX6SL		0x60
@@ -46,4 +48,17 @@ void set_vddsoc(u32 mv);
 int fecmxc_initialize(bd_t *bis);
 u32 get_ahb_clk(void);
 u32 get_periph_clk(void);
+
+/* OTP related functionality */
+int imx_otp_read_one_u32(u32, u32 *);
+int imx_otp_blow_one_u32(u32, u32, u32 *);
+void enable_otp_clk(unsigned char);
+
+int mxs_reset_block(struct mxs_register_32 *reg);
+int mxs_wait_mask_set(struct mxs_register_32 *reg,
+		       uint32_t mask,
+		       unsigned int timeout);
+int mxs_wait_mask_clr(struct mxs_register_32 *reg,
+		       uint32_t mask,
+		       unsigned int timeout);
 #endif
diff --git a/arch/arm/include/asm/arch-mxs/dma.h b/arch/arm/include/asm/arch-mxs/dma.h
deleted file mode 100644
index a0a0ea5..0000000
--- a/arch/arm/include/asm/arch-mxs/dma.h
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Freescale i.MX28 APBH DMA
- *
- * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
- * on behalf of DENX Software Engineering GmbH
- *
- * Based on code from LTIB:
- * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#ifndef __DMA_H__
-#define __DMA_H__
-
-#include <linux/list.h>
-#include <linux/compiler.h>
-
-#ifndef	CONFIG_ARCH_DMA_PIO_WORDS
-#define	DMA_PIO_WORDS		15
-#else
-#define	DMA_PIO_WORDS		CONFIG_ARCH_DMA_PIO_WORDS
-#endif
-
-#define MXS_DMA_ALIGNMENT	32
-
-/*
- * MXS DMA channels
- */
-enum {
-	MXS_DMA_CHANNEL_AHB_APBH_SSP0 = 0,
-	MXS_DMA_CHANNEL_AHB_APBH_SSP1,
-	MXS_DMA_CHANNEL_AHB_APBH_SSP2,
-	MXS_DMA_CHANNEL_AHB_APBH_SSP3,
-	MXS_DMA_CHANNEL_AHB_APBH_GPMI0,
-	MXS_DMA_CHANNEL_AHB_APBH_GPMI1,
-	MXS_DMA_CHANNEL_AHB_APBH_GPMI2,
-	MXS_DMA_CHANNEL_AHB_APBH_GPMI3,
-	MXS_DMA_CHANNEL_AHB_APBH_GPMI4,
-	MXS_DMA_CHANNEL_AHB_APBH_GPMI5,
-	MXS_DMA_CHANNEL_AHB_APBH_GPMI6,
-	MXS_DMA_CHANNEL_AHB_APBH_GPMI7,
-	MXS_DMA_CHANNEL_AHB_APBH_SSP,
-	MXS_MAX_DMA_CHANNELS,
-};
-
-/*
- * MXS DMA hardware command.
- *
- * This structure describes the in-memory layout of an entire DMA command,
- * including space for the maximum number of PIO accesses. See the appropriate
- * reference manual for a detailed description of what these fields mean to the
- * DMA hardware.
- */
-#define	MXS_DMA_DESC_COMMAND_MASK	0x3
-#define	MXS_DMA_DESC_COMMAND_OFFSET	0
-#define	MXS_DMA_DESC_COMMAND_NO_DMAXFER	0x0
-#define	MXS_DMA_DESC_COMMAND_DMA_WRITE	0x1
-#define	MXS_DMA_DESC_COMMAND_DMA_READ	0x2
-#define	MXS_DMA_DESC_COMMAND_DMA_SENSE	0x3
-#define	MXS_DMA_DESC_CHAIN		(1 << 2)
-#define	MXS_DMA_DESC_IRQ		(1 << 3)
-#define	MXS_DMA_DESC_NAND_LOCK		(1 << 4)
-#define	MXS_DMA_DESC_NAND_WAIT_4_READY	(1 << 5)
-#define	MXS_DMA_DESC_DEC_SEM		(1 << 6)
-#define	MXS_DMA_DESC_WAIT4END		(1 << 7)
-#define	MXS_DMA_DESC_HALT_ON_TERMINATE	(1 << 8)
-#define	MXS_DMA_DESC_TERMINATE_FLUSH	(1 << 9)
-#define	MXS_DMA_DESC_PIO_WORDS_MASK	(0xf << 12)
-#define	MXS_DMA_DESC_PIO_WORDS_OFFSET	12
-#define	MXS_DMA_DESC_BYTES_MASK		(0xffff << 16)
-#define	MXS_DMA_DESC_BYTES_OFFSET	16
-
-struct mxs_dma_cmd {
-	unsigned long		next;
-	unsigned long		data;
-	union {
-		dma_addr_t	address;
-		unsigned long	alternate;
-	};
-	unsigned long		pio_words[DMA_PIO_WORDS];
-};
-
-/*
- * MXS DMA command descriptor.
- *
- * This structure incorporates an MXS DMA hardware command structure, along
- * with metadata.
- */
-#define	MXS_DMA_DESC_FIRST	(1 << 0)
-#define	MXS_DMA_DESC_LAST	(1 << 1)
-#define	MXS_DMA_DESC_READY	(1 << 31)
-
-struct mxs_dma_desc {
-	struct mxs_dma_cmd	cmd;
-	unsigned int		flags;
-	dma_addr_t		address;
-	void			*buffer;
-	struct list_head	node;
-} __aligned(MXS_DMA_ALIGNMENT);
-
-/**
- * MXS DMA channel
- *
- * This structure represents a single DMA channel. The MXS platform code
- * maintains an array of these structures to represent every DMA channel in the
- * system (see mxs_dma_channels).
- */
-#define	MXS_DMA_FLAGS_IDLE	0
-#define	MXS_DMA_FLAGS_BUSY	(1 << 0)
-#define	MXS_DMA_FLAGS_FREE	0
-#define	MXS_DMA_FLAGS_ALLOCATED	(1 << 16)
-#define	MXS_DMA_FLAGS_VALID	(1 << 31)
-
-struct mxs_dma_chan {
-	const char *name;
-	unsigned long dev;
-	struct mxs_dma_device *dma;
-	unsigned int flags;
-	unsigned int active_num;
-	unsigned int pending_num;
-	struct list_head active;
-	struct list_head done;
-};
-
-struct mxs_dma_desc *mxs_dma_desc_alloc(void);
-void mxs_dma_desc_free(struct mxs_dma_desc *);
-int mxs_dma_desc_append(int channel, struct mxs_dma_desc *pdesc);
-
-int mxs_dma_go(int chan);
-void mxs_dma_init(void);
-int mxs_dma_init_channel(int chan);
-int mxs_dma_release(int chan);
-
-#endif	/* __DMA_H__ */
diff --git a/arch/arm/include/asm/arch-mxs/imx-regs.h b/arch/arm/include/asm/arch-mxs/imx-regs.h
index 05eb63c..c6ee49b 100644
--- a/arch/arm/include/asm/arch-mxs/imx-regs.h
+++ b/arch/arm/include/asm/arch-mxs/imx-regs.h
@@ -23,11 +23,11 @@
 #ifndef __IMX_REGS_H__
 #define __IMX_REGS_H__
 
-#include <asm/arch/regs-apbh.h>
+#include <asm/imx-common/regs-apbh.h>
 #include <asm/arch/regs-base.h>
-#include <asm/arch/regs-bch.h>
+#include <asm/imx-common/regs-bch.h>
 #include <asm/arch/regs-digctl.h>
-#include <asm/arch/regs-gpmi.h>
+#include <asm/imx-common/regs-gpmi.h>
 #include <asm/arch/regs-i2c.h>
 #include <asm/arch/regs-lcdif.h>
 #include <asm/arch/regs-lradc.h>
diff --git a/arch/arm/include/asm/arch-mxs/regs-apbh.h b/arch/arm/include/asm/arch-mxs/regs-apbh.h
deleted file mode 100644
index fcef4b8..0000000
--- a/arch/arm/include/asm/arch-mxs/regs-apbh.h
+++ /dev/null
@@ -1,587 +0,0 @@
-/*
- * Freescale i.MX28 APBH Register Definitions
- *
- * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
- * on behalf of DENX Software Engineering GmbH
- *
- * Based on code from LTIB:
- * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#ifndef __REGS_APBH_H__
-#define __REGS_APBH_H__
-
-#include <asm/arch/regs-common.h>
-
-#ifndef	__ASSEMBLY__
-
-#if defined(CONFIG_MX23)
-struct mxs_apbh_regs {
-	mxs_reg_32(hw_apbh_ctrl0)
-	mxs_reg_32(hw_apbh_ctrl1)
-	mxs_reg_32(hw_apbh_ctrl2)
-	mxs_reg_32(hw_apbh_channel_ctrl)
-
-	union {
-	struct {
-		mxs_reg_32(hw_apbh_ch_curcmdar)
-		mxs_reg_32(hw_apbh_ch_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch_cmd)
-		mxs_reg_32(hw_apbh_ch_bar)
-		mxs_reg_32(hw_apbh_ch_sema)
-		mxs_reg_32(hw_apbh_ch_debug1)
-		mxs_reg_32(hw_apbh_ch_debug2)
-	} ch[8];
-	struct {
-		mxs_reg_32(hw_apbh_ch0_curcmdar)
-		mxs_reg_32(hw_apbh_ch0_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch0_cmd)
-		mxs_reg_32(hw_apbh_ch0_bar)
-		mxs_reg_32(hw_apbh_ch0_sema)
-		mxs_reg_32(hw_apbh_ch0_debug1)
-		mxs_reg_32(hw_apbh_ch0_debug2)
-		mxs_reg_32(hw_apbh_ch1_curcmdar)
-		mxs_reg_32(hw_apbh_ch1_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch1_cmd)
-		mxs_reg_32(hw_apbh_ch1_bar)
-		mxs_reg_32(hw_apbh_ch1_sema)
-		mxs_reg_32(hw_apbh_ch1_debug1)
-		mxs_reg_32(hw_apbh_ch1_debug2)
-		mxs_reg_32(hw_apbh_ch2_curcmdar)
-		mxs_reg_32(hw_apbh_ch2_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch2_cmd)
-		mxs_reg_32(hw_apbh_ch2_bar)
-		mxs_reg_32(hw_apbh_ch2_sema)
-		mxs_reg_32(hw_apbh_ch2_debug1)
-		mxs_reg_32(hw_apbh_ch2_debug2)
-		mxs_reg_32(hw_apbh_ch3_curcmdar)
-		mxs_reg_32(hw_apbh_ch3_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch3_cmd)
-		mxs_reg_32(hw_apbh_ch3_bar)
-		mxs_reg_32(hw_apbh_ch3_sema)
-		mxs_reg_32(hw_apbh_ch3_debug1)
-		mxs_reg_32(hw_apbh_ch3_debug2)
-		mxs_reg_32(hw_apbh_ch4_curcmdar)
-		mxs_reg_32(hw_apbh_ch4_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch4_cmd)
-		mxs_reg_32(hw_apbh_ch4_bar)
-		mxs_reg_32(hw_apbh_ch4_sema)
-		mxs_reg_32(hw_apbh_ch4_debug1)
-		mxs_reg_32(hw_apbh_ch4_debug2)
-		mxs_reg_32(hw_apbh_ch5_curcmdar)
-		mxs_reg_32(hw_apbh_ch5_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch5_cmd)
-		mxs_reg_32(hw_apbh_ch5_bar)
-		mxs_reg_32(hw_apbh_ch5_sema)
-		mxs_reg_32(hw_apbh_ch5_debug1)
-		mxs_reg_32(hw_apbh_ch5_debug2)
-		mxs_reg_32(hw_apbh_ch6_curcmdar)
-		mxs_reg_32(hw_apbh_ch6_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch6_cmd)
-		mxs_reg_32(hw_apbh_ch6_bar)
-		mxs_reg_32(hw_apbh_ch6_sema)
-		mxs_reg_32(hw_apbh_ch6_debug1)
-		mxs_reg_32(hw_apbh_ch6_debug2)
-		mxs_reg_32(hw_apbh_ch7_curcmdar)
-		mxs_reg_32(hw_apbh_ch7_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch7_cmd)
-		mxs_reg_32(hw_apbh_ch7_bar)
-		mxs_reg_32(hw_apbh_ch7_sema)
-		mxs_reg_32(hw_apbh_ch7_debug1)
-		mxs_reg_32(hw_apbh_ch7_debug2)
-	};
-	};
-	mxs_reg_32(hw_apbh_version)
-};
-
-#elif defined(CONFIG_MX28)
-struct mxs_apbh_regs {
-	mxs_reg_32(hw_apbh_ctrl0)
-	mxs_reg_32(hw_apbh_ctrl1)
-	mxs_reg_32(hw_apbh_ctrl2)
-	mxs_reg_32(hw_apbh_channel_ctrl)
-	mxs_reg_32(hw_apbh_devsel)
-	mxs_reg_32(hw_apbh_dma_burst_size)
-	mxs_reg_32(hw_apbh_debug)
-
-	uint32_t	reserved[36];
-
-	union {
-	struct {
-		mxs_reg_32(hw_apbh_ch_curcmdar)
-		mxs_reg_32(hw_apbh_ch_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch_cmd)
-		mxs_reg_32(hw_apbh_ch_bar)
-		mxs_reg_32(hw_apbh_ch_sema)
-		mxs_reg_32(hw_apbh_ch_debug1)
-		mxs_reg_32(hw_apbh_ch_debug2)
-	} ch[16];
-	struct {
-		mxs_reg_32(hw_apbh_ch0_curcmdar)
-		mxs_reg_32(hw_apbh_ch0_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch0_cmd)
-		mxs_reg_32(hw_apbh_ch0_bar)
-		mxs_reg_32(hw_apbh_ch0_sema)
-		mxs_reg_32(hw_apbh_ch0_debug1)
-		mxs_reg_32(hw_apbh_ch0_debug2)
-		mxs_reg_32(hw_apbh_ch1_curcmdar)
-		mxs_reg_32(hw_apbh_ch1_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch1_cmd)
-		mxs_reg_32(hw_apbh_ch1_bar)
-		mxs_reg_32(hw_apbh_ch1_sema)
-		mxs_reg_32(hw_apbh_ch1_debug1)
-		mxs_reg_32(hw_apbh_ch1_debug2)
-		mxs_reg_32(hw_apbh_ch2_curcmdar)
-		mxs_reg_32(hw_apbh_ch2_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch2_cmd)
-		mxs_reg_32(hw_apbh_ch2_bar)
-		mxs_reg_32(hw_apbh_ch2_sema)
-		mxs_reg_32(hw_apbh_ch2_debug1)
-		mxs_reg_32(hw_apbh_ch2_debug2)
-		mxs_reg_32(hw_apbh_ch3_curcmdar)
-		mxs_reg_32(hw_apbh_ch3_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch3_cmd)
-		mxs_reg_32(hw_apbh_ch3_bar)
-		mxs_reg_32(hw_apbh_ch3_sema)
-		mxs_reg_32(hw_apbh_ch3_debug1)
-		mxs_reg_32(hw_apbh_ch3_debug2)
-		mxs_reg_32(hw_apbh_ch4_curcmdar)
-		mxs_reg_32(hw_apbh_ch4_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch4_cmd)
-		mxs_reg_32(hw_apbh_ch4_bar)
-		mxs_reg_32(hw_apbh_ch4_sema)
-		mxs_reg_32(hw_apbh_ch4_debug1)
-		mxs_reg_32(hw_apbh_ch4_debug2)
-		mxs_reg_32(hw_apbh_ch5_curcmdar)
-		mxs_reg_32(hw_apbh_ch5_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch5_cmd)
-		mxs_reg_32(hw_apbh_ch5_bar)
-		mxs_reg_32(hw_apbh_ch5_sema)
-		mxs_reg_32(hw_apbh_ch5_debug1)
-		mxs_reg_32(hw_apbh_ch5_debug2)
-		mxs_reg_32(hw_apbh_ch6_curcmdar)
-		mxs_reg_32(hw_apbh_ch6_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch6_cmd)
-		mxs_reg_32(hw_apbh_ch6_bar)
-		mxs_reg_32(hw_apbh_ch6_sema)
-		mxs_reg_32(hw_apbh_ch6_debug1)
-		mxs_reg_32(hw_apbh_ch6_debug2)
-		mxs_reg_32(hw_apbh_ch7_curcmdar)
-		mxs_reg_32(hw_apbh_ch7_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch7_cmd)
-		mxs_reg_32(hw_apbh_ch7_bar)
-		mxs_reg_32(hw_apbh_ch7_sema)
-		mxs_reg_32(hw_apbh_ch7_debug1)
-		mxs_reg_32(hw_apbh_ch7_debug2)
-		mxs_reg_32(hw_apbh_ch8_curcmdar)
-		mxs_reg_32(hw_apbh_ch8_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch8_cmd)
-		mxs_reg_32(hw_apbh_ch8_bar)
-		mxs_reg_32(hw_apbh_ch8_sema)
-		mxs_reg_32(hw_apbh_ch8_debug1)
-		mxs_reg_32(hw_apbh_ch8_debug2)
-		mxs_reg_32(hw_apbh_ch9_curcmdar)
-		mxs_reg_32(hw_apbh_ch9_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch9_cmd)
-		mxs_reg_32(hw_apbh_ch9_bar)
-		mxs_reg_32(hw_apbh_ch9_sema)
-		mxs_reg_32(hw_apbh_ch9_debug1)
-		mxs_reg_32(hw_apbh_ch9_debug2)
-		mxs_reg_32(hw_apbh_ch10_curcmdar)
-		mxs_reg_32(hw_apbh_ch10_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch10_cmd)
-		mxs_reg_32(hw_apbh_ch10_bar)
-		mxs_reg_32(hw_apbh_ch10_sema)
-		mxs_reg_32(hw_apbh_ch10_debug1)
-		mxs_reg_32(hw_apbh_ch10_debug2)
-		mxs_reg_32(hw_apbh_ch11_curcmdar)
-		mxs_reg_32(hw_apbh_ch11_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch11_cmd)
-		mxs_reg_32(hw_apbh_ch11_bar)
-		mxs_reg_32(hw_apbh_ch11_sema)
-		mxs_reg_32(hw_apbh_ch11_debug1)
-		mxs_reg_32(hw_apbh_ch11_debug2)
-		mxs_reg_32(hw_apbh_ch12_curcmdar)
-		mxs_reg_32(hw_apbh_ch12_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch12_cmd)
-		mxs_reg_32(hw_apbh_ch12_bar)
-		mxs_reg_32(hw_apbh_ch12_sema)
-		mxs_reg_32(hw_apbh_ch12_debug1)
-		mxs_reg_32(hw_apbh_ch12_debug2)
-		mxs_reg_32(hw_apbh_ch13_curcmdar)
-		mxs_reg_32(hw_apbh_ch13_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch13_cmd)
-		mxs_reg_32(hw_apbh_ch13_bar)
-		mxs_reg_32(hw_apbh_ch13_sema)
-		mxs_reg_32(hw_apbh_ch13_debug1)
-		mxs_reg_32(hw_apbh_ch13_debug2)
-		mxs_reg_32(hw_apbh_ch14_curcmdar)
-		mxs_reg_32(hw_apbh_ch14_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch14_cmd)
-		mxs_reg_32(hw_apbh_ch14_bar)
-		mxs_reg_32(hw_apbh_ch14_sema)
-		mxs_reg_32(hw_apbh_ch14_debug1)
-		mxs_reg_32(hw_apbh_ch14_debug2)
-		mxs_reg_32(hw_apbh_ch15_curcmdar)
-		mxs_reg_32(hw_apbh_ch15_nxtcmdar)
-		mxs_reg_32(hw_apbh_ch15_cmd)
-		mxs_reg_32(hw_apbh_ch15_bar)
-		mxs_reg_32(hw_apbh_ch15_sema)
-		mxs_reg_32(hw_apbh_ch15_debug1)
-		mxs_reg_32(hw_apbh_ch15_debug2)
-	};
-	};
-	mxs_reg_32(hw_apbh_version)
-};
-#endif
-
-#endif
-
-#define	APBH_CTRL0_SFTRST				(1 << 31)
-#define	APBH_CTRL0_CLKGATE				(1 << 30)
-#define	APBH_CTRL0_AHB_BURST8_EN			(1 << 29)
-#define	APBH_CTRL0_APB_BURST_EN				(1 << 28)
-#if defined(CONFIG_MX23)
-#define	APBH_CTRL0_RSVD0_MASK				(0xf << 24)
-#define	APBH_CTRL0_RSVD0_OFFSET				24
-#define	APBH_CTRL0_RESET_CHANNEL_MASK			(0xff << 16)
-#define	APBH_CTRL0_RESET_CHANNEL_OFFSET			16
-#define	APBH_CTRL0_CLKGATE_CHANNEL_MASK			(0xff << 8)
-#define	APBH_CTRL0_CLKGATE_CHANNEL_OFFSET		8
-#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP0			0x02
-#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP1			0x04
-#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND0		0x10
-#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND1		0x20
-#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND2		0x40
-#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND3		0x80
-#elif defined(CONFIG_MX28)
-#define	APBH_CTRL0_RSVD0_MASK				(0xfff << 16)
-#define	APBH_CTRL0_RSVD0_OFFSET				16
-#define	APBH_CTRL0_CLKGATE_CHANNEL_MASK			0xffff
-#define	APBH_CTRL0_CLKGATE_CHANNEL_OFFSET		0
-#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP0			0x0001
-#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP1			0x0002
-#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP2			0x0004
-#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP3			0x0008
-#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND0		0x0010
-#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND1		0x0020
-#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND2		0x0040
-#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND3		0x0080
-#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND4		0x0100
-#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND5		0x0200
-#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND6		0x0400
-#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND7		0x0800
-#define	APBH_CTRL0_CLKGATE_CHANNEL_HSADC		0x1000
-#define	APBH_CTRL0_CLKGATE_CHANNEL_LCDIF		0x2000
-#endif
-
-#define	APBH_CTRL1_CH15_CMDCMPLT_IRQ_EN			(1 << 31)
-#define	APBH_CTRL1_CH14_CMDCMPLT_IRQ_EN			(1 << 30)
-#define	APBH_CTRL1_CH13_CMDCMPLT_IRQ_EN			(1 << 29)
-#define	APBH_CTRL1_CH12_CMDCMPLT_IRQ_EN			(1 << 28)
-#define	APBH_CTRL1_CH11_CMDCMPLT_IRQ_EN			(1 << 27)
-#define	APBH_CTRL1_CH10_CMDCMPLT_IRQ_EN			(1 << 26)
-#define	APBH_CTRL1_CH9_CMDCMPLT_IRQ_EN			(1 << 25)
-#define	APBH_CTRL1_CH8_CMDCMPLT_IRQ_EN			(1 << 24)
-#define	APBH_CTRL1_CH7_CMDCMPLT_IRQ_EN			(1 << 23)
-#define	APBH_CTRL1_CH6_CMDCMPLT_IRQ_EN			(1 << 22)
-#define	APBH_CTRL1_CH5_CMDCMPLT_IRQ_EN			(1 << 21)
-#define	APBH_CTRL1_CH4_CMDCMPLT_IRQ_EN			(1 << 20)
-#define	APBH_CTRL1_CH3_CMDCMPLT_IRQ_EN			(1 << 19)
-#define	APBH_CTRL1_CH2_CMDCMPLT_IRQ_EN			(1 << 18)
-#define	APBH_CTRL1_CH1_CMDCMPLT_IRQ_EN			(1 << 17)
-#define	APBH_CTRL1_CH0_CMDCMPLT_IRQ_EN			(1 << 16)
-#define	APBH_CTRL1_CH_CMDCMPLT_IRQ_EN_OFFSET		16
-#define	APBH_CTRL1_CH_CMDCMPLT_IRQ_EN_MASK		(0xffff << 16)
-#define	APBH_CTRL1_CH15_CMDCMPLT_IRQ			(1 << 15)
-#define	APBH_CTRL1_CH14_CMDCMPLT_IRQ			(1 << 14)
-#define	APBH_CTRL1_CH13_CMDCMPLT_IRQ			(1 << 13)
-#define	APBH_CTRL1_CH12_CMDCMPLT_IRQ			(1 << 12)
-#define	APBH_CTRL1_CH11_CMDCMPLT_IRQ			(1 << 11)
-#define	APBH_CTRL1_CH10_CMDCMPLT_IRQ			(1 << 10)
-#define	APBH_CTRL1_CH9_CMDCMPLT_IRQ			(1 << 9)
-#define	APBH_CTRL1_CH8_CMDCMPLT_IRQ			(1 << 8)
-#define	APBH_CTRL1_CH7_CMDCMPLT_IRQ			(1 << 7)
-#define	APBH_CTRL1_CH6_CMDCMPLT_IRQ			(1 << 6)
-#define	APBH_CTRL1_CH5_CMDCMPLT_IRQ			(1 << 5)
-#define	APBH_CTRL1_CH4_CMDCMPLT_IRQ			(1 << 4)
-#define	APBH_CTRL1_CH3_CMDCMPLT_IRQ			(1 << 3)
-#define	APBH_CTRL1_CH2_CMDCMPLT_IRQ			(1 << 2)
-#define	APBH_CTRL1_CH1_CMDCMPLT_IRQ			(1 << 1)
-#define	APBH_CTRL1_CH0_CMDCMPLT_IRQ			(1 << 0)
-
-#define	APBH_CTRL2_CH15_ERROR_STATUS			(1 << 31)
-#define	APBH_CTRL2_CH14_ERROR_STATUS			(1 << 30)
-#define	APBH_CTRL2_CH13_ERROR_STATUS			(1 << 29)
-#define	APBH_CTRL2_CH12_ERROR_STATUS			(1 << 28)
-#define	APBH_CTRL2_CH11_ERROR_STATUS			(1 << 27)
-#define	APBH_CTRL2_CH10_ERROR_STATUS			(1 << 26)
-#define	APBH_CTRL2_CH9_ERROR_STATUS			(1 << 25)
-#define	APBH_CTRL2_CH8_ERROR_STATUS			(1 << 24)
-#define	APBH_CTRL2_CH7_ERROR_STATUS			(1 << 23)
-#define	APBH_CTRL2_CH6_ERROR_STATUS			(1 << 22)
-#define	APBH_CTRL2_CH5_ERROR_STATUS			(1 << 21)
-#define	APBH_CTRL2_CH4_ERROR_STATUS			(1 << 20)
-#define	APBH_CTRL2_CH3_ERROR_STATUS			(1 << 19)
-#define	APBH_CTRL2_CH2_ERROR_STATUS			(1 << 18)
-#define	APBH_CTRL2_CH1_ERROR_STATUS			(1 << 17)
-#define	APBH_CTRL2_CH0_ERROR_STATUS			(1 << 16)
-#define	APBH_CTRL2_CH15_ERROR_IRQ			(1 << 15)
-#define	APBH_CTRL2_CH14_ERROR_IRQ			(1 << 14)
-#define	APBH_CTRL2_CH13_ERROR_IRQ			(1 << 13)
-#define	APBH_CTRL2_CH12_ERROR_IRQ			(1 << 12)
-#define	APBH_CTRL2_CH11_ERROR_IRQ			(1 << 11)
-#define	APBH_CTRL2_CH10_ERROR_IRQ			(1 << 10)
-#define	APBH_CTRL2_CH9_ERROR_IRQ			(1 << 9)
-#define	APBH_CTRL2_CH8_ERROR_IRQ			(1 << 8)
-#define	APBH_CTRL2_CH7_ERROR_IRQ			(1 << 7)
-#define	APBH_CTRL2_CH6_ERROR_IRQ			(1 << 6)
-#define	APBH_CTRL2_CH5_ERROR_IRQ			(1 << 5)
-#define	APBH_CTRL2_CH4_ERROR_IRQ			(1 << 4)
-#define	APBH_CTRL2_CH3_ERROR_IRQ			(1 << 3)
-#define	APBH_CTRL2_CH2_ERROR_IRQ			(1 << 2)
-#define	APBH_CTRL2_CH1_ERROR_IRQ			(1 << 1)
-#define	APBH_CTRL2_CH0_ERROR_IRQ			(1 << 0)
-
-#if defined(CONFIG_MX28)
-#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_MASK		(0xffff << 16)
-#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_OFFSET		16
-#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_SSP0		(0x0001 << 16)
-#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_SSP1		(0x0002 << 16)
-#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_SSP2		(0x0004 << 16)
-#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_SSP3		(0x0008 << 16)
-#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND0		(0x0010 << 16)
-#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND1		(0x0020 << 16)
-#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND2		(0x0040 << 16)
-#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND3		(0x0080 << 16)
-#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND4		(0x0100 << 16)
-#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND5		(0x0200 << 16)
-#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND6		(0x0400 << 16)
-#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND7		(0x0800 << 16)
-#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_HSADC		(0x1000 << 16)
-#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_LCDIF		(0x2000 << 16)
-#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_MASK		0xffff
-#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_OFFSET		0
-#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_SSP0		0x0001
-#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_SSP1		0x0002
-#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_SSP2		0x0004
-#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_SSP3		0x0008
-#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND0		0x0010
-#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND1		0x0020
-#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND2		0x0040
-#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND3		0x0080
-#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND4		0x0100
-#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND5		0x0200
-#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND6		0x0400
-#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND7		0x0800
-#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_HSADC		0x1000
-#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_LCDIF		0x2000
-#endif
-
-#if defined(CONFIG_MX23)
-#define	APBH_DEVSEL_CH7_MASK				(0xf << 28)
-#define	APBH_DEVSEL_CH7_OFFSET				28
-#define	APBH_DEVSEL_CH6_MASK				(0xf << 24)
-#define	APBH_DEVSEL_CH6_OFFSET				24
-#define	APBH_DEVSEL_CH5_MASK				(0xf << 20)
-#define	APBH_DEVSEL_CH5_OFFSET				20
-#define	APBH_DEVSEL_CH4_MASK				(0xf << 16)
-#define	APBH_DEVSEL_CH4_OFFSET				16
-#define	APBH_DEVSEL_CH3_MASK				(0xf << 12)
-#define	APBH_DEVSEL_CH3_OFFSET				12
-#define	APBH_DEVSEL_CH2_MASK				(0xf << 8)
-#define	APBH_DEVSEL_CH2_OFFSET				8
-#define	APBH_DEVSEL_CH1_MASK				(0xf << 4)
-#define	APBH_DEVSEL_CH1_OFFSET				4
-#define	APBH_DEVSEL_CH0_MASK				(0xf << 0)
-#define	APBH_DEVSEL_CH0_OFFSET				0
-#elif defined(CONFIG_MX28)
-#define	APBH_DEVSEL_CH15_MASK				(0x3 << 30)
-#define	APBH_DEVSEL_CH15_OFFSET				30
-#define	APBH_DEVSEL_CH14_MASK				(0x3 << 28)
-#define	APBH_DEVSEL_CH14_OFFSET				28
-#define	APBH_DEVSEL_CH13_MASK				(0x3 << 26)
-#define	APBH_DEVSEL_CH13_OFFSET				26
-#define	APBH_DEVSEL_CH12_MASK				(0x3 << 24)
-#define	APBH_DEVSEL_CH12_OFFSET				24
-#define	APBH_DEVSEL_CH11_MASK				(0x3 << 22)
-#define	APBH_DEVSEL_CH11_OFFSET				22
-#define	APBH_DEVSEL_CH10_MASK				(0x3 << 20)
-#define	APBH_DEVSEL_CH10_OFFSET				20
-#define	APBH_DEVSEL_CH9_MASK				(0x3 << 18)
-#define	APBH_DEVSEL_CH9_OFFSET				18
-#define	APBH_DEVSEL_CH8_MASK				(0x3 << 16)
-#define	APBH_DEVSEL_CH8_OFFSET				16
-#define	APBH_DEVSEL_CH7_MASK				(0x3 << 14)
-#define	APBH_DEVSEL_CH7_OFFSET				14
-#define	APBH_DEVSEL_CH6_MASK				(0x3 << 12)
-#define	APBH_DEVSEL_CH6_OFFSET				12
-#define	APBH_DEVSEL_CH5_MASK				(0x3 << 10)
-#define	APBH_DEVSEL_CH5_OFFSET				10
-#define	APBH_DEVSEL_CH4_MASK				(0x3 << 8)
-#define	APBH_DEVSEL_CH4_OFFSET				8
-#define	APBH_DEVSEL_CH3_MASK				(0x3 << 6)
-#define	APBH_DEVSEL_CH3_OFFSET				6
-#define	APBH_DEVSEL_CH2_MASK				(0x3 << 4)
-#define	APBH_DEVSEL_CH2_OFFSET				4
-#define	APBH_DEVSEL_CH1_MASK				(0x3 << 2)
-#define	APBH_DEVSEL_CH1_OFFSET				2
-#define	APBH_DEVSEL_CH0_MASK				(0x3 << 0)
-#define	APBH_DEVSEL_CH0_OFFSET				0
-#endif
-
-#if defined(CONFIG_MX28)
-#define	APBH_DMA_BURST_SIZE_CH15_MASK			(0x3 << 30)
-#define	APBH_DMA_BURST_SIZE_CH15_OFFSET			30
-#define	APBH_DMA_BURST_SIZE_CH14_MASK			(0x3 << 28)
-#define	APBH_DMA_BURST_SIZE_CH14_OFFSET			28
-#define	APBH_DMA_BURST_SIZE_CH13_MASK			(0x3 << 26)
-#define	APBH_DMA_BURST_SIZE_CH13_OFFSET			26
-#define	APBH_DMA_BURST_SIZE_CH12_MASK			(0x3 << 24)
-#define	APBH_DMA_BURST_SIZE_CH12_OFFSET			24
-#define	APBH_DMA_BURST_SIZE_CH11_MASK			(0x3 << 22)
-#define	APBH_DMA_BURST_SIZE_CH11_OFFSET			22
-#define	APBH_DMA_BURST_SIZE_CH10_MASK			(0x3 << 20)
-#define	APBH_DMA_BURST_SIZE_CH10_OFFSET			20
-#define	APBH_DMA_BURST_SIZE_CH9_MASK			(0x3 << 18)
-#define	APBH_DMA_BURST_SIZE_CH9_OFFSET			18
-#define	APBH_DMA_BURST_SIZE_CH8_MASK			(0x3 << 16)
-#define	APBH_DMA_BURST_SIZE_CH8_OFFSET			16
-#define	APBH_DMA_BURST_SIZE_CH8_BURST0			(0x0 << 16)
-#define	APBH_DMA_BURST_SIZE_CH8_BURST4			(0x1 << 16)
-#define	APBH_DMA_BURST_SIZE_CH8_BURST8			(0x2 << 16)
-#define	APBH_DMA_BURST_SIZE_CH7_MASK			(0x3 << 14)
-#define	APBH_DMA_BURST_SIZE_CH7_OFFSET			14
-#define	APBH_DMA_BURST_SIZE_CH6_MASK			(0x3 << 12)
-#define	APBH_DMA_BURST_SIZE_CH6_OFFSET			12
-#define	APBH_DMA_BURST_SIZE_CH5_MASK			(0x3 << 10)
-#define	APBH_DMA_BURST_SIZE_CH5_OFFSET			10
-#define	APBH_DMA_BURST_SIZE_CH4_MASK			(0x3 << 8)
-#define	APBH_DMA_BURST_SIZE_CH4_OFFSET			8
-#define	APBH_DMA_BURST_SIZE_CH3_MASK			(0x3 << 6)
-#define	APBH_DMA_BURST_SIZE_CH3_OFFSET			6
-#define	APBH_DMA_BURST_SIZE_CH3_BURST0			(0x0 << 6)
-#define	APBH_DMA_BURST_SIZE_CH3_BURST4			(0x1 << 6)
-#define	APBH_DMA_BURST_SIZE_CH3_BURST8			(0x2 << 6)
-
-#define	APBH_DMA_BURST_SIZE_CH2_MASK			(0x3 << 4)
-#define	APBH_DMA_BURST_SIZE_CH2_OFFSET			4
-#define	APBH_DMA_BURST_SIZE_CH2_BURST0			(0x0 << 4)
-#define	APBH_DMA_BURST_SIZE_CH2_BURST4			(0x1 << 4)
-#define	APBH_DMA_BURST_SIZE_CH2_BURST8			(0x2 << 4)
-#define	APBH_DMA_BURST_SIZE_CH1_MASK			(0x3 << 2)
-#define	APBH_DMA_BURST_SIZE_CH1_OFFSET			2
-#define	APBH_DMA_BURST_SIZE_CH1_BURST0			(0x0 << 2)
-#define	APBH_DMA_BURST_SIZE_CH1_BURST4			(0x1 << 2)
-#define	APBH_DMA_BURST_SIZE_CH1_BURST8			(0x2 << 2)
-
-#define	APBH_DMA_BURST_SIZE_CH0_MASK			0x3
-#define	APBH_DMA_BURST_SIZE_CH0_OFFSET			0
-#define	APBH_DMA_BURST_SIZE_CH0_BURST0			0x0
-#define	APBH_DMA_BURST_SIZE_CH0_BURST4			0x1
-#define	APBH_DMA_BURST_SIZE_CH0_BURST8			0x2
-
-#define	APBH_DEBUG_GPMI_ONE_FIFO			(1 << 0)
-#endif
-
-#define	APBH_CHn_CURCMDAR_CMD_ADDR_MASK			0xffffffff
-#define	APBH_CHn_CURCMDAR_CMD_ADDR_OFFSET		0
-
-#define	APBH_CHn_NXTCMDAR_CMD_ADDR_MASK			0xffffffff
-#define	APBH_CHn_NXTCMDAR_CMD_ADDR_OFFSET		0
-
-#define	APBH_CHn_CMD_XFER_COUNT_MASK			(0xffff << 16)
-#define	APBH_CHn_CMD_XFER_COUNT_OFFSET			16
-#define	APBH_CHn_CMD_CMDWORDS_MASK			(0xf << 12)
-#define	APBH_CHn_CMD_CMDWORDS_OFFSET			12
-#define	APBH_CHn_CMD_HALTONTERMINATE			(1 << 8)
-#define	APBH_CHn_CMD_WAIT4ENDCMD			(1 << 7)
-#define	APBH_CHn_CMD_SEMAPHORE				(1 << 6)
-#define	APBH_CHn_CMD_NANDWAIT4READY			(1 << 5)
-#define	APBH_CHn_CMD_NANDLOCK				(1 << 4)
-#define	APBH_CHn_CMD_IRQONCMPLT				(1 << 3)
-#define	APBH_CHn_CMD_CHAIN				(1 << 2)
-#define	APBH_CHn_CMD_COMMAND_MASK			0x3
-#define	APBH_CHn_CMD_COMMAND_OFFSET			0
-#define	APBH_CHn_CMD_COMMAND_NO_DMA_XFER		0x0
-#define	APBH_CHn_CMD_COMMAND_DMA_WRITE			0x1
-#define	APBH_CHn_CMD_COMMAND_DMA_READ			0x2
-#define	APBH_CHn_CMD_COMMAND_DMA_SENSE			0x3
-
-#define	APBH_CHn_BAR_ADDRESS_MASK			0xffffffff
-#define	APBH_CHn_BAR_ADDRESS_OFFSET			0
-
-#define	APBH_CHn_SEMA_RSVD2_MASK			(0xff << 24)
-#define	APBH_CHn_SEMA_RSVD2_OFFSET			24
-#define	APBH_CHn_SEMA_PHORE_MASK			(0xff << 16)
-#define	APBH_CHn_SEMA_PHORE_OFFSET			16
-#define	APBH_CHn_SEMA_RSVD1_MASK			(0xff << 8)
-#define	APBH_CHn_SEMA_RSVD1_OFFSET			8
-#define	APBH_CHn_SEMA_INCREMENT_SEMA_MASK		(0xff << 0)
-#define	APBH_CHn_SEMA_INCREMENT_SEMA_OFFSET		0
-
-#define	APBH_CHn_DEBUG1_REQ				(1 << 31)
-#define	APBH_CHn_DEBUG1_BURST				(1 << 30)
-#define	APBH_CHn_DEBUG1_KICK				(1 << 29)
-#define	APBH_CHn_DEBUG1_END				(1 << 28)
-#define	APBH_CHn_DEBUG1_SENSE				(1 << 27)
-#define	APBH_CHn_DEBUG1_READY				(1 << 26)
-#define	APBH_CHn_DEBUG1_LOCK				(1 << 25)
-#define	APBH_CHn_DEBUG1_NEXTCMDADDRVALID		(1 << 24)
-#define	APBH_CHn_DEBUG1_RD_FIFO_EMPTY			(1 << 23)
-#define	APBH_CHn_DEBUG1_RD_FIFO_FULL			(1 << 22)
-#define	APBH_CHn_DEBUG1_WR_FIFO_EMPTY			(1 << 21)
-#define	APBH_CHn_DEBUG1_WR_FIFO_FULL			(1 << 20)
-#define	APBH_CHn_DEBUG1_RSVD1_MASK			(0x7fff << 5)
-#define	APBH_CHn_DEBUG1_RSVD1_OFFSET			5
-#define	APBH_CHn_DEBUG1_STATEMACHINE_MASK		0x1f
-#define	APBH_CHn_DEBUG1_STATEMACHINE_OFFSET		0
-#define	APBH_CHn_DEBUG1_STATEMACHINE_IDLE		0x00
-#define	APBH_CHn_DEBUG1_STATEMACHINE_REQ_CMD1		0x01
-#define	APBH_CHn_DEBUG1_STATEMACHINE_REQ_CMD3		0x02
-#define	APBH_CHn_DEBUG1_STATEMACHINE_REQ_CMD2		0x03
-#define	APBH_CHn_DEBUG1_STATEMACHINE_XFER_DECODE	0x04
-#define	APBH_CHn_DEBUG1_STATEMACHINE_REQ_WAIT		0x05
-#define	APBH_CHn_DEBUG1_STATEMACHINE_REQ_CMD4		0x06
-#define	APBH_CHn_DEBUG1_STATEMACHINE_PIO_REQ		0x07
-#define	APBH_CHn_DEBUG1_STATEMACHINE_READ_FLUSH		0x08
-#define	APBH_CHn_DEBUG1_STATEMACHINE_READ_WAIT		0x09
-#define	APBH_CHn_DEBUG1_STATEMACHINE_WRITE		0x0c
-#define	APBH_CHn_DEBUG1_STATEMACHINE_READ_REQ		0x0d
-#define	APBH_CHn_DEBUG1_STATEMACHINE_CHECK_CHAIN	0x0e
-#define	APBH_CHn_DEBUG1_STATEMACHINE_XFER_COMPLETE	0x0f
-#define	APBH_CHn_DEBUG1_STATEMACHINE_TERMINATE		0x14
-#define	APBH_CHn_DEBUG1_STATEMACHINE_WAIT_END		0x15
-#define	APBH_CHn_DEBUG1_STATEMACHINE_WRITE_WAIT		0x1c
-#define	APBH_CHn_DEBUG1_STATEMACHINE_HALT_AFTER_TERM	0x1d
-#define	APBH_CHn_DEBUG1_STATEMACHINE_CHECK_WAIT		0x1e
-#define	APBH_CHn_DEBUG1_STATEMACHINE_WAIT_READY		0x1f
-
-#define	APBH_CHn_DEBUG2_APB_BYTES_MASK			(0xffff << 16)
-#define	APBH_CHn_DEBUG2_APB_BYTES_OFFSET		16
-#define	APBH_CHn_DEBUG2_AHB_BYTES_MASK			0xffff
-#define	APBH_CHn_DEBUG2_AHB_BYTES_OFFSET		0
-
-#define	APBH_VERSION_MAJOR_MASK				(0xff << 24)
-#define	APBH_VERSION_MAJOR_OFFSET			24
-#define	APBH_VERSION_MINOR_MASK				(0xff << 16)
-#define	APBH_VERSION_MINOR_OFFSET			16
-#define	APBH_VERSION_STEP_MASK				0xffff
-#define	APBH_VERSION_STEP_OFFSET			0
-
-#endif	/* __REGS_APBH_H__ */
diff --git a/arch/arm/include/asm/arch-mxs/regs-bch.h b/arch/arm/include/asm/arch-mxs/regs-bch.h
deleted file mode 100644
index 40baa4d..0000000
--- a/arch/arm/include/asm/arch-mxs/regs-bch.h
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
- * Freescale i.MX28 BCH Register Definitions
- *
- * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
- * on behalf of DENX Software Engineering GmbH
- *
- * Based on code from LTIB:
- * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#ifndef __MX28_REGS_BCH_H__
-#define __MX28_REGS_BCH_H__
-
-#include <asm/arch/regs-common.h>
-
-#ifndef	__ASSEMBLY__
-struct mxs_bch_regs {
-	mxs_reg_32(hw_bch_ctrl)
-	mxs_reg_32(hw_bch_status0)
-	mxs_reg_32(hw_bch_mode)
-	mxs_reg_32(hw_bch_encodeptr)
-	mxs_reg_32(hw_bch_dataptr)
-	mxs_reg_32(hw_bch_metaptr)
-
-	uint32_t	reserved[4];
-
-	mxs_reg_32(hw_bch_layoutselect)
-	mxs_reg_32(hw_bch_flash0layout0)
-	mxs_reg_32(hw_bch_flash0layout1)
-	mxs_reg_32(hw_bch_flash1layout0)
-	mxs_reg_32(hw_bch_flash1layout1)
-	mxs_reg_32(hw_bch_flash2layout0)
-	mxs_reg_32(hw_bch_flash2layout1)
-	mxs_reg_32(hw_bch_flash3layout0)
-	mxs_reg_32(hw_bch_flash3layout1)
-	mxs_reg_32(hw_bch_dbgkesread)
-	mxs_reg_32(hw_bch_dbgcsferead)
-	mxs_reg_32(hw_bch_dbgsyndegread)
-	mxs_reg_32(hw_bch_dbgahbmread)
-	mxs_reg_32(hw_bch_blockname)
-	mxs_reg_32(hw_bch_version)
-};
-#endif
-
-#define	BCH_CTRL_SFTRST					(1 << 31)
-#define	BCH_CTRL_CLKGATE				(1 << 30)
-#define	BCH_CTRL_DEBUGSYNDROME				(1 << 22)
-#define	BCH_CTRL_M2M_LAYOUT_MASK			(0x3 << 18)
-#define	BCH_CTRL_M2M_LAYOUT_OFFSET			18
-#define	BCH_CTRL_M2M_ENCODE				(1 << 17)
-#define	BCH_CTRL_M2M_ENABLE				(1 << 16)
-#define	BCH_CTRL_DEBUG_STALL_IRQ_EN			(1 << 10)
-#define	BCH_CTRL_COMPLETE_IRQ_EN			(1 << 8)
-#define	BCH_CTRL_BM_ERROR_IRQ				(1 << 3)
-#define	BCH_CTRL_DEBUG_STALL_IRQ			(1 << 2)
-#define	BCH_CTRL_COMPLETE_IRQ				(1 << 0)
-
-#define	BCH_STATUS0_HANDLE_MASK				(0xfff << 20)
-#define	BCH_STATUS0_HANDLE_OFFSET			20
-#define	BCH_STATUS0_COMPLETED_CE_MASK			(0xf << 16)
-#define	BCH_STATUS0_COMPLETED_CE_OFFSET			16
-#define	BCH_STATUS0_STATUS_BLK0_MASK			(0xff << 8)
-#define	BCH_STATUS0_STATUS_BLK0_OFFSET			8
-#define	BCH_STATUS0_STATUS_BLK0_ZERO			(0x00 << 8)
-#define	BCH_STATUS0_STATUS_BLK0_ERROR1			(0x01 << 8)
-#define	BCH_STATUS0_STATUS_BLK0_ERROR2			(0x02 << 8)
-#define	BCH_STATUS0_STATUS_BLK0_ERROR3			(0x03 << 8)
-#define	BCH_STATUS0_STATUS_BLK0_ERROR4			(0x04 << 8)
-#define	BCH_STATUS0_STATUS_BLK0_UNCORRECTABLE		(0xfe << 8)
-#define	BCH_STATUS0_STATUS_BLK0_ERASED			(0xff << 8)
-#define	BCH_STATUS0_ALLONES				(1 << 4)
-#define	BCH_STATUS0_CORRECTED				(1 << 3)
-#define	BCH_STATUS0_UNCORRECTABLE			(1 << 2)
-
-#define	BCH_MODE_ERASE_THRESHOLD_MASK			0xff
-#define	BCH_MODE_ERASE_THRESHOLD_OFFSET			0
-
-#define	BCH_ENCODEPTR_ADDR_MASK				0xffffffff
-#define	BCH_ENCODEPTR_ADDR_OFFSET			0
-
-#define	BCH_DATAPTR_ADDR_MASK				0xffffffff
-#define	BCH_DATAPTR_ADDR_OFFSET				0
-
-#define	BCH_METAPTR_ADDR_MASK				0xffffffff
-#define	BCH_METAPTR_ADDR_OFFSET				0
-
-#define	BCH_LAYOUTSELECT_CS15_SELECT_MASK		(0x3 << 30)
-#define	BCH_LAYOUTSELECT_CS15_SELECT_OFFSET		30
-#define	BCH_LAYOUTSELECT_CS14_SELECT_MASK		(0x3 << 28)
-#define	BCH_LAYOUTSELECT_CS14_SELECT_OFFSET		28
-#define	BCH_LAYOUTSELECT_CS13_SELECT_MASK		(0x3 << 26)
-#define	BCH_LAYOUTSELECT_CS13_SELECT_OFFSET		26
-#define	BCH_LAYOUTSELECT_CS12_SELECT_MASK		(0x3 << 24)
-#define	BCH_LAYOUTSELECT_CS12_SELECT_OFFSET		24
-#define	BCH_LAYOUTSELECT_CS11_SELECT_MASK		(0x3 << 22)
-#define	BCH_LAYOUTSELECT_CS11_SELECT_OFFSET		22
-#define	BCH_LAYOUTSELECT_CS10_SELECT_MASK		(0x3 << 20)
-#define	BCH_LAYOUTSELECT_CS10_SELECT_OFFSET		20
-#define	BCH_LAYOUTSELECT_CS9_SELECT_MASK		(0x3 << 18)
-#define	BCH_LAYOUTSELECT_CS9_SELECT_OFFSET		18
-#define	BCH_LAYOUTSELECT_CS8_SELECT_MASK		(0x3 << 16)
-#define	BCH_LAYOUTSELECT_CS8_SELECT_OFFSET		16
-#define	BCH_LAYOUTSELECT_CS7_SELECT_MASK		(0x3 << 14)
-#define	BCH_LAYOUTSELECT_CS7_SELECT_OFFSET		14
-#define	BCH_LAYOUTSELECT_CS6_SELECT_MASK		(0x3 << 12)
-#define	BCH_LAYOUTSELECT_CS6_SELECT_OFFSET		12
-#define	BCH_LAYOUTSELECT_CS5_SELECT_MASK		(0x3 << 10)
-#define	BCH_LAYOUTSELECT_CS5_SELECT_OFFSET		10
-#define	BCH_LAYOUTSELECT_CS4_SELECT_MASK		(0x3 << 8)
-#define	BCH_LAYOUTSELECT_CS4_SELECT_OFFSET		8
-#define	BCH_LAYOUTSELECT_CS3_SELECT_MASK		(0x3 << 6)
-#define	BCH_LAYOUTSELECT_CS3_SELECT_OFFSET		6
-#define	BCH_LAYOUTSELECT_CS2_SELECT_MASK		(0x3 << 4)
-#define	BCH_LAYOUTSELECT_CS2_SELECT_OFFSET		4
-#define	BCH_LAYOUTSELECT_CS1_SELECT_MASK		(0x3 << 2)
-#define	BCH_LAYOUTSELECT_CS1_SELECT_OFFSET		2
-#define	BCH_LAYOUTSELECT_CS0_SELECT_MASK		(0x3 << 0)
-#define	BCH_LAYOUTSELECT_CS0_SELECT_OFFSET		0
-
-#define	BCH_FLASHLAYOUT0_NBLOCKS_MASK			(0xff << 24)
-#define	BCH_FLASHLAYOUT0_NBLOCKS_OFFSET			24
-#define	BCH_FLASHLAYOUT0_META_SIZE_MASK			(0xff << 16)
-#define	BCH_FLASHLAYOUT0_META_SIZE_OFFSET		16
-#define	BCH_FLASHLAYOUT0_ECC0_MASK			(0xf << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_OFFSET			12
-#define	BCH_FLASHLAYOUT0_ECC0_NONE			(0x0 << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_ECC2			(0x1 << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_ECC4			(0x2 << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_ECC6			(0x3 << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_ECC8			(0x4 << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_ECC10			(0x5 << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_ECC12			(0x6 << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_ECC14			(0x7 << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_ECC16			(0x8 << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_ECC18			(0x9 << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_ECC20			(0xa << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_ECC22			(0xb << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_ECC24			(0xc << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_ECC26			(0xd << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_ECC28			(0xe << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_ECC30			(0xf << 12)
-#define	BCH_FLASHLAYOUT0_ECC0_ECC32			(0x10 << 12)
-#define	BCH_FLASHLAYOUT0_GF13_0_GF14_1			(1 << 10)
-#define	BCH_FLASHLAYOUT0_DATA0_SIZE_MASK		0xfff
-#define	BCH_FLASHLAYOUT0_DATA0_SIZE_OFFSET		0
-
-#define	BCH_FLASHLAYOUT1_PAGE_SIZE_MASK			(0xffff << 16)
-#define	BCH_FLASHLAYOUT1_PAGE_SIZE_OFFSET		16
-#define	BCH_FLASHLAYOUT1_ECCN_MASK			(0xf << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_OFFSET			12
-#define	BCH_FLASHLAYOUT1_ECCN_NONE			(0x0 << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_ECC2			(0x1 << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_ECC4			(0x2 << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_ECC6			(0x3 << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_ECC8			(0x4 << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_ECC10			(0x5 << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_ECC12			(0x6 << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_ECC14			(0x7 << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_ECC16			(0x8 << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_ECC18			(0x9 << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_ECC20			(0xa << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_ECC22			(0xb << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_ECC24			(0xc << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_ECC26			(0xd << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_ECC28			(0xe << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_ECC30			(0xf << 12)
-#define	BCH_FLASHLAYOUT1_ECCN_ECC32			(0x10 << 12)
-#define	BCH_FLASHLAYOUT1_GF13_0_GF14_1			(1 << 10)
-#define	BCH_FLASHLAYOUT1_DATAN_SIZE_MASK		0xfff
-#define	BCH_FLASHLAYOUT1_DATAN_SIZE_OFFSET		0
-
-#define	BCH_DEBUG0_RSVD1_MASK				(0x1f << 27)
-#define	BCH_DEBUG0_RSVD1_OFFSET				27
-#define	BCH_DEBUG0_ROM_BIST_ENABLE			(1 << 26)
-#define	BCH_DEBUG0_ROM_BIST_COMPLETE			(1 << 25)
-#define	BCH_DEBUG0_KES_DEBUG_SYNDROME_SYMBOL_MASK	(0x1ff << 16)
-#define	BCH_DEBUG0_KES_DEBUG_SYNDROME_SYMBOL_OFFSET	16
-#define	BCH_DEBUG0_KES_DEBUG_SYNDROME_SYMBOL_NORMAL	(0x0 << 16)
-#define	BCH_DEBUG0_KES_DEBUG_SYNDROME_SYMBOL_TEST_MODE	(0x1 << 16)
-#define	BCH_DEBUG0_KES_DEBUG_SHIFT_SYND			(1 << 15)
-#define	BCH_DEBUG0_KES_DEBUG_PAYLOAD_FLAG		(1 << 14)
-#define	BCH_DEBUG0_KES_DEBUG_MODE4K			(1 << 13)
-#define	BCH_DEBUG0_KES_DEBUG_KICK			(1 << 12)
-#define	BCH_DEBUG0_KES_STANDALONE			(1 << 11)
-#define	BCH_DEBUG0_KES_DEBUG_STEP			(1 << 10)
-#define	BCH_DEBUG0_KES_DEBUG_STALL			(1 << 9)
-#define	BCH_DEBUG0_BM_KES_TEST_BYPASS			(1 << 8)
-#define	BCH_DEBUG0_RSVD0_MASK				(0x3 << 6)
-#define	BCH_DEBUG0_RSVD0_OFFSET				6
-#define	BCH_DEBUG0_DEBUG_REG_SELECT_MASK		0x3f
-#define	BCH_DEBUG0_DEBUG_REG_SELECT_OFFSET		0
-
-#define	BCH_DBGKESREAD_VALUES_MASK			0xffffffff
-#define	BCH_DBGKESREAD_VALUES_OFFSET			0
-
-#define	BCH_DBGCSFEREAD_VALUES_MASK			0xffffffff
-#define	BCH_DBGCSFEREAD_VALUES_OFFSET			0
-
-#define	BCH_DBGSYNDGENREAD_VALUES_MASK			0xffffffff
-#define	BCH_DBGSYNDGENREAD_VALUES_OFFSET		0
-
-#define	BCH_DBGAHBMREAD_VALUES_MASK			0xffffffff
-#define	BCH_DBGAHBMREAD_VALUES_OFFSET			0
-
-#define	BCH_BLOCKNAME_NAME_MASK				0xffffffff
-#define	BCH_BLOCKNAME_NAME_OFFSET			0
-
-#define	BCH_VERSION_MAJOR_MASK				(0xff << 24)
-#define	BCH_VERSION_MAJOR_OFFSET			24
-#define	BCH_VERSION_MINOR_MASK				(0xff << 16)
-#define	BCH_VERSION_MINOR_OFFSET			16
-#define	BCH_VERSION_STEP_MASK				0xffff
-#define	BCH_VERSION_STEP_OFFSET				0
-
-#endif	/* __MX28_REGS_BCH_H__ */
diff --git a/arch/arm/include/asm/arch-mxs/regs-clkctrl-mx23.h b/arch/arm/include/asm/arch-mxs/regs-clkctrl-mx23.h
index 62810ec..c3cba33 100644
--- a/arch/arm/include/asm/arch-mxs/regs-clkctrl-mx23.h
+++ b/arch/arm/include/asm/arch-mxs/regs-clkctrl-mx23.h
@@ -26,7 +26,7 @@
 #ifndef __MX23_REGS_CLKCTRL_H__
 #define __MX23_REGS_CLKCTRL_H__
 
-#include <asm/arch/regs-common.h>
+#include <asm/imx-common/regs-common.h>
 
 #ifndef	__ASSEMBLY__
 struct mxs_clkctrl_regs {
diff --git a/arch/arm/include/asm/arch-mxs/regs-clkctrl-mx28.h b/arch/arm/include/asm/arch-mxs/regs-clkctrl-mx28.h
index 23e9adc..1c2c82e 100644
--- a/arch/arm/include/asm/arch-mxs/regs-clkctrl-mx28.h
+++ b/arch/arm/include/asm/arch-mxs/regs-clkctrl-mx28.h
@@ -26,7 +26,7 @@
 #ifndef __MX28_REGS_CLKCTRL_H__
 #define __MX28_REGS_CLKCTRL_H__
 
-#include <asm/arch/regs-common.h>
+#include <asm/imx-common/regs-common.h>
 
 #ifndef	__ASSEMBLY__
 struct mxs_clkctrl_regs {
diff --git a/arch/arm/include/asm/arch-mxs/regs-common.h b/arch/arm/include/asm/arch-mxs/regs-common.h
deleted file mode 100644
index bcea419..0000000
--- a/arch/arm/include/asm/arch-mxs/regs-common.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Freescale i.MXS Register Accessors
- *
- * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
- * on behalf of DENX Software Engineering GmbH
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#ifndef __MXS_REGS_COMMON_H__
-#define __MXS_REGS_COMMON_H__
-
-/*
- * The i.MXS has interesting feature when it comes to register access. There
- * are four kinds of access to one particular register. Those are:
- *
- * 1) Common read/write access. To use this mode, just write to the address of
- *    the register.
- * 2) Set bits only access. To set bits, write which bits you want to set to the
- *    address of the register + 0x4.
- * 3) Clear bits only access. To clear bits, write which bits you want to clear
- *    to the address of the register + 0x8.
- * 4) Toggle bits only access. To toggle bits, write which bits you want to
- *    toggle to the address of the register + 0xc.
- *
- * IMPORTANT NOTE: Not all registers support accesses 2-4! Also, not all bits
- * can be set/cleared by pure write as in access type 1, some need to be
- * explicitly set/cleared by using access type 2-3.
- *
- * The following macros and structures allow the user to either access the
- * register in all aforementioned modes (by accessing reg_name, reg_name_set,
- * reg_name_clr, reg_name_tog) or pass the register structure further into
- * various functions with correct type information (by accessing reg_name_reg).
- *
- */
-
-#define	__mxs_reg_8(name)		\
-	uint8_t	name[4];		\
-	uint8_t	name##_set[4];		\
-	uint8_t	name##_clr[4];		\
-	uint8_t	name##_tog[4];		\
-
-#define	__mxs_reg_32(name)		\
-	uint32_t name;			\
-	uint32_t name##_set;		\
-	uint32_t name##_clr;		\
-	uint32_t name##_tog;
-
-struct mxs_register_8 {
-	__mxs_reg_8(reg)
-};
-
-struct mxs_register_32 {
-	__mxs_reg_32(reg)
-};
-
-#define	mxs_reg_8(name)				\
-	union {						\
-		struct { __mxs_reg_8(name) };		\
-		struct mxs_register_8 name##_reg;	\
-	};
-
-#define	mxs_reg_32(name)				\
-	union {						\
-		struct { __mxs_reg_32(name) };		\
-		struct mxs_register_32 name##_reg;	\
-	};
-
-#endif	/* __MXS_REGS_COMMON_H__ */
diff --git a/arch/arm/include/asm/arch-mxs/regs-digctl.h b/arch/arm/include/asm/arch-mxs/regs-digctl.h
index d043325..d4a3966 100644
--- a/arch/arm/include/asm/arch-mxs/regs-digctl.h
+++ b/arch/arm/include/asm/arch-mxs/regs-digctl.h
@@ -22,7 +22,7 @@
 #ifndef __MX28_REGS_DIGCTL_H__
 #define __MX28_REGS_DIGCTL_H__
 
-#include <asm/arch/regs-common.h>
+#include <asm/imx-common/regs-common.h>
 
 #ifndef	__ASSEMBLY__
 struct mxs_digctl_regs {
diff --git a/arch/arm/include/asm/arch-mxs/regs-gpmi.h b/arch/arm/include/asm/arch-mxs/regs-gpmi.h
deleted file mode 100644
index 624d618..0000000
--- a/arch/arm/include/asm/arch-mxs/regs-gpmi.h
+++ /dev/null
@@ -1,222 +0,0 @@
-/*
- * Freescale i.MX28 GPMI Register Definitions
- *
- * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
- * on behalf of DENX Software Engineering GmbH
- *
- * Based on code from LTIB:
- * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- *
- */
-
-#ifndef __MX28_REGS_GPMI_H__
-#define __MX28_REGS_GPMI_H__
-
-#include <asm/arch/regs-common.h>
-
-#ifndef	__ASSEMBLY__
-struct mxs_gpmi_regs {
-	mxs_reg_32(hw_gpmi_ctrl0)
-	mxs_reg_32(hw_gpmi_compare)
-	mxs_reg_32(hw_gpmi_eccctrl)
-	mxs_reg_32(hw_gpmi_ecccount)
-	mxs_reg_32(hw_gpmi_payload)
-	mxs_reg_32(hw_gpmi_auxiliary)
-	mxs_reg_32(hw_gpmi_ctrl1)
-	mxs_reg_32(hw_gpmi_timing0)
-	mxs_reg_32(hw_gpmi_timing1)
-
-	uint32_t	reserved[4];
-
-	mxs_reg_32(hw_gpmi_data)
-	mxs_reg_32(hw_gpmi_stat)
-	mxs_reg_32(hw_gpmi_debug)
-	mxs_reg_32(hw_gpmi_version)
-};
-#endif
-
-#define	GPMI_CTRL0_SFTRST				(1 << 31)
-#define	GPMI_CTRL0_CLKGATE				(1 << 30)
-#define	GPMI_CTRL0_RUN					(1 << 29)
-#define	GPMI_CTRL0_DEV_IRQ_EN				(1 << 28)
-#define	GPMI_CTRL0_LOCK_CS				(1 << 27)
-#define	GPMI_CTRL0_UDMA					(1 << 26)
-#define	GPMI_CTRL0_COMMAND_MODE_MASK			(0x3 << 24)
-#define	GPMI_CTRL0_COMMAND_MODE_OFFSET			24
-#define	GPMI_CTRL0_COMMAND_MODE_WRITE			(0x0 << 24)
-#define	GPMI_CTRL0_COMMAND_MODE_READ			(0x1 << 24)
-#define	GPMI_CTRL0_COMMAND_MODE_READ_AND_COMPARE	(0x2 << 24)
-#define	GPMI_CTRL0_COMMAND_MODE_WAIT_FOR_READY		(0x3 << 24)
-#define	GPMI_CTRL0_WORD_LENGTH				(1 << 23)
-#define	GPMI_CTRL0_CS_MASK				(0x7 << 20)
-#define	GPMI_CTRL0_CS_OFFSET				20
-#define	GPMI_CTRL0_ADDRESS_MASK				(0x7 << 17)
-#define	GPMI_CTRL0_ADDRESS_OFFSET			17
-#define	GPMI_CTRL0_ADDRESS_NAND_DATA			(0x0 << 17)
-#define	GPMI_CTRL0_ADDRESS_NAND_CLE			(0x1 << 17)
-#define	GPMI_CTRL0_ADDRESS_NAND_ALE			(0x2 << 17)
-#define	GPMI_CTRL0_ADDRESS_INCREMENT			(1 << 16)
-#define	GPMI_CTRL0_XFER_COUNT_MASK			0xffff
-#define	GPMI_CTRL0_XFER_COUNT_OFFSET			0
-
-#define	GPMI_COMPARE_MASK_MASK				(0xffff << 16)
-#define	GPMI_COMPARE_MASK_OFFSET			16
-#define	GPMI_COMPARE_REFERENCE_MASK			0xffff
-#define	GPMI_COMPARE_REFERENCE_OFFSET			0
-
-#define	GPMI_ECCCTRL_HANDLE_MASK			(0xffff << 16)
-#define	GPMI_ECCCTRL_HANDLE_OFFSET			16
-#define	GPMI_ECCCTRL_ECC_CMD_MASK			(0x3 << 13)
-#define	GPMI_ECCCTRL_ECC_CMD_OFFSET			13
-#define	GPMI_ECCCTRL_ECC_CMD_DECODE			(0x0 << 13)
-#define	GPMI_ECCCTRL_ECC_CMD_ENCODE			(0x1 << 13)
-#define	GPMI_ECCCTRL_ENABLE_ECC				(1 << 12)
-#define	GPMI_ECCCTRL_BUFFER_MASK_MASK			0x1ff
-#define	GPMI_ECCCTRL_BUFFER_MASK_OFFSET			0
-#define	GPMI_ECCCTRL_BUFFER_MASK_BCH_AUXONLY		0x100
-#define	GPMI_ECCCTRL_BUFFER_MASK_BCH_PAGE		0x1ff
-
-#define	GPMI_ECCCOUNT_COUNT_MASK			0xffff
-#define	GPMI_ECCCOUNT_COUNT_OFFSET			0
-
-#define	GPMI_PAYLOAD_ADDRESS_MASK			(0x3fffffff << 2)
-#define	GPMI_PAYLOAD_ADDRESS_OFFSET			2
-
-#define	GPMI_AUXILIARY_ADDRESS_MASK			(0x3fffffff << 2)
-#define	GPMI_AUXILIARY_ADDRESS_OFFSET			2
-
-#define	GPMI_CTRL1_DECOUPLE_CS				(1 << 24)
-#define	GPMI_CTRL1_WRN_DLY_SEL_MASK			(0x3 << 22)
-#define	GPMI_CTRL1_WRN_DLY_SEL_OFFSET			22
-#define	GPMI_CTRL1_TIMEOUT_IRQ_EN			(1 << 20)
-#define	GPMI_CTRL1_GANGED_RDYBUSY			(1 << 19)
-#define	GPMI_CTRL1_BCH_MODE				(1 << 18)
-#define	GPMI_CTRL1_DLL_ENABLE				(1 << 17)
-#define	GPMI_CTRL1_HALF_PERIOD				(1 << 16)
-#define	GPMI_CTRL1_RDN_DELAY_MASK			(0xf << 12)
-#define	GPMI_CTRL1_RDN_DELAY_OFFSET			12
-#define	GPMI_CTRL1_DMA2ECC_MODE				(1 << 11)
-#define	GPMI_CTRL1_DEV_IRQ				(1 << 10)
-#define	GPMI_CTRL1_TIMEOUT_IRQ				(1 << 9)
-#define	GPMI_CTRL1_BURST_EN				(1 << 8)
-#define	GPMI_CTRL1_ABORT_WAIT_REQUEST			(1 << 7)
-#define	GPMI_CTRL1_ABORT_WAIT_FOR_READY_CHANNEL_MASK	(0x7 << 4)
-#define	GPMI_CTRL1_ABORT_WAIT_FOR_READY_CHANNEL_OFFSET	4
-#define	GPMI_CTRL1_DEV_RESET				(1 << 3)
-#define	GPMI_CTRL1_ATA_IRQRDY_POLARITY			(1 << 2)
-#define	GPMI_CTRL1_CAMERA_MODE				(1 << 1)
-#define	GPMI_CTRL1_GPMI_MODE				(1 << 0)
-
-#define	GPMI_TIMING0_ADDRESS_SETUP_MASK			(0xff << 16)
-#define	GPMI_TIMING0_ADDRESS_SETUP_OFFSET		16
-#define	GPMI_TIMING0_DATA_HOLD_MASK			(0xff << 8)
-#define	GPMI_TIMING0_DATA_HOLD_OFFSET			8
-#define	GPMI_TIMING0_DATA_SETUP_MASK			0xff
-#define	GPMI_TIMING0_DATA_SETUP_OFFSET			0
-
-#define	GPMI_TIMING1_DEVICE_BUSY_TIMEOUT_MASK		(0xffff << 16)
-#define	GPMI_TIMING1_DEVICE_BUSY_TIMEOUT_OFFSET		16
-
-#define	GPMI_TIMING2_UDMA_TRP_MASK			(0xff << 24)
-#define	GPMI_TIMING2_UDMA_TRP_OFFSET			24
-#define	GPMI_TIMING2_UDMA_ENV_MASK			(0xff << 16)
-#define	GPMI_TIMING2_UDMA_ENV_OFFSET			16
-#define	GPMI_TIMING2_UDMA_HOLD_MASK			(0xff << 8)
-#define	GPMI_TIMING2_UDMA_HOLD_OFFSET			8
-#define	GPMI_TIMING2_UDMA_SETUP_MASK			0xff
-#define	GPMI_TIMING2_UDMA_SETUP_OFFSET			0
-
-#define	GPMI_DATA_DATA_MASK				0xffffffff
-#define	GPMI_DATA_DATA_OFFSET				0
-
-#define	GPMI_STAT_READY_BUSY_MASK			(0xff << 24)
-#define	GPMI_STAT_READY_BUSY_OFFSET			24
-#define	GPMI_STAT_RDY_TIMEOUT_MASK			(0xff << 16)
-#define	GPMI_STAT_RDY_TIMEOUT_OFFSET			16
-#define	GPMI_STAT_DEV7_ERROR				(1 << 15)
-#define	GPMI_STAT_DEV6_ERROR				(1 << 14)
-#define	GPMI_STAT_DEV5_ERROR				(1 << 13)
-#define	GPMI_STAT_DEV4_ERROR				(1 << 12)
-#define	GPMI_STAT_DEV3_ERROR				(1 << 11)
-#define	GPMI_STAT_DEV2_ERROR				(1 << 10)
-#define	GPMI_STAT_DEV1_ERROR				(1 << 9)
-#define	GPMI_STAT_DEV0_ERROR				(1 << 8)
-#define	GPMI_STAT_ATA_IRQ				(1 << 4)
-#define	GPMI_STAT_INVALID_BUFFER_MASK			(1 << 3)
-#define	GPMI_STAT_FIFO_EMPTY				(1 << 2)
-#define	GPMI_STAT_FIFO_FULL				(1 << 1)
-#define	GPMI_STAT_PRESENT				(1 << 0)
-
-#define	GPMI_DEBUG_WAIT_FOR_READY_END_MASK		(0xff << 24)
-#define	GPMI_DEBUG_WAIT_FOR_READY_END_OFFSET		24
-#define	GPMI_DEBUG_DMA_SENSE_MASK			(0xff << 16)
-#define	GPMI_DEBUG_DMA_SENSE_OFFSET			16
-#define	GPMI_DEBUG_DMAREQ_MASK				(0xff << 8)
-#define	GPMI_DEBUG_DMAREQ_OFFSET			8
-#define	GPMI_DEBUG_CMD_END_MASK				0xff
-#define	GPMI_DEBUG_CMD_END_OFFSET			0
-
-#define	GPMI_VERSION_MAJOR_MASK				(0xff << 24)
-#define	GPMI_VERSION_MAJOR_OFFSET			24
-#define	GPMI_VERSION_MINOR_MASK				(0xff << 16)
-#define	GPMI_VERSION_MINOR_OFFSET			16
-#define	GPMI_VERSION_STEP_MASK				0xffff
-#define	GPMI_VERSION_STEP_OFFSET			0
-
-#define	GPMI_DEBUG2_UDMA_STATE_MASK			(0xf << 24)
-#define	GPMI_DEBUG2_UDMA_STATE_OFFSET			24
-#define	GPMI_DEBUG2_BUSY				(1 << 23)
-#define	GPMI_DEBUG2_PIN_STATE_MASK			(0x7 << 20)
-#define	GPMI_DEBUG2_PIN_STATE_OFFSET			20
-#define	GPMI_DEBUG2_PIN_STATE_PSM_IDLE			(0x0 << 20)
-#define	GPMI_DEBUG2_PIN_STATE_PSM_BYTCNT		(0x1 << 20)
-#define	GPMI_DEBUG2_PIN_STATE_PSM_ADDR			(0x2 << 20)
-#define	GPMI_DEBUG2_PIN_STATE_PSM_STALL			(0x3 << 20)
-#define	GPMI_DEBUG2_PIN_STATE_PSM_STROBE		(0x4 << 20)
-#define	GPMI_DEBUG2_PIN_STATE_PSM_ATARDY		(0x5 << 20)
-#define	GPMI_DEBUG2_PIN_STATE_PSM_DHOLD			(0x6 << 20)
-#define	GPMI_DEBUG2_PIN_STATE_PSM_DONE			(0x7 << 20)
-#define	GPMI_DEBUG2_MAIN_STATE_MASK			(0xf << 16)
-#define	GPMI_DEBUG2_MAIN_STATE_OFFSET			16
-#define	GPMI_DEBUG2_MAIN_STATE_MSM_IDLE			(0x0 << 16)
-#define	GPMI_DEBUG2_MAIN_STATE_MSM_BYTCNT		(0x1 << 16)
-#define	GPMI_DEBUG2_MAIN_STATE_MSM_WAITFE		(0x2 << 16)
-#define	GPMI_DEBUG2_MAIN_STATE_MSM_WAITFR		(0x3 << 16)
-#define	GPMI_DEBUG2_MAIN_STATE_MSM_DMAREQ		(0x4 << 16)
-#define	GPMI_DEBUG2_MAIN_STATE_MSM_DMAACK		(0x5 << 16)
-#define	GPMI_DEBUG2_MAIN_STATE_MSM_WAITFF		(0x6 << 16)
-#define	GPMI_DEBUG2_MAIN_STATE_MSM_LDFIFO		(0x7 << 16)
-#define	GPMI_DEBUG2_MAIN_STATE_MSM_LDDMAR		(0x8 << 16)
-#define	GPMI_DEBUG2_MAIN_STATE_MSM_RDCMP		(0x9 << 16)
-#define	GPMI_DEBUG2_MAIN_STATE_MSM_DONE			(0xa << 16)
-#define	GPMI_DEBUG2_SYND2GPMI_BE_MASK			(0xf << 12)
-#define	GPMI_DEBUG2_SYND2GPMI_BE_OFFSET			12
-#define	GPMI_DEBUG2_GPMI2SYND_VALID			(1 << 11)
-#define	GPMI_DEBUG2_GPMI2SYND_READY			(1 << 10)
-#define	GPMI_DEBUG2_SYND2GPMI_VALID			(1 << 9)
-#define	GPMI_DEBUG2_SYND2GPMI_READY			(1 << 8)
-#define	GPMI_DEBUG2_VIEW_DELAYED_RDN			(1 << 7)
-#define	GPMI_DEBUG2_UPDATE_WINDOW			(1 << 6)
-#define	GPMI_DEBUG2_RDN_TAP_MASK			0x3f
-#define	GPMI_DEBUG2_RDN_TAP_OFFSET			0
-
-#define	GPMI_DEBUG3_APB_WORD_CNTR_MASK			(0xffff << 16)
-#define	GPMI_DEBUG3_APB_WORD_CNTR_OFFSET		16
-#define	GPMI_DEBUG3_DEV_WORD_CNTR_MASK			0xffff
-#define	GPMI_DEBUG3_DEV_WORD_CNTR_OFFSET		0
-
-#endif	/* __MX28_REGS_GPMI_H__ */
diff --git a/arch/arm/include/asm/arch-mxs/regs-i2c.h b/arch/arm/include/asm/arch-mxs/regs-i2c.h
index 067cfd3..d062b5b 100644
--- a/arch/arm/include/asm/arch-mxs/regs-i2c.h
+++ b/arch/arm/include/asm/arch-mxs/regs-i2c.h
@@ -23,7 +23,7 @@
 #ifndef __MX28_REGS_I2C_H__
 #define __MX28_REGS_I2C_H__
 
-#include <asm/arch/regs-common.h>
+#include <asm/imx-common/regs-common.h>
 
 #ifndef	__ASSEMBLY__
 struct mxs_i2c_regs {
diff --git a/arch/arm/include/asm/arch-mxs/regs-lcdif.h b/arch/arm/include/asm/arch-mxs/regs-lcdif.h
index b90b2d4..e3e3864 100644
--- a/arch/arm/include/asm/arch-mxs/regs-lcdif.h
+++ b/arch/arm/include/asm/arch-mxs/regs-lcdif.h
@@ -26,7 +26,7 @@
 #ifndef __MX28_REGS_LCDIF_H__
 #define __MX28_REGS_LCDIF_H__
 
-#include <asm/arch/regs-common.h>
+#include <asm/imx-common/regs-common.h>
 
 #ifndef	__ASSEMBLY__
 struct mxs_lcdif_regs {
diff --git a/arch/arm/include/asm/arch-mxs/regs-lradc.h b/arch/arm/include/asm/arch-mxs/regs-lradc.h
index 28d8382..23fd0e3 100644
--- a/arch/arm/include/asm/arch-mxs/regs-lradc.h
+++ b/arch/arm/include/asm/arch-mxs/regs-lradc.h
@@ -26,7 +26,7 @@
 #ifndef __MX28_REGS_LRADC_H__
 #define __MX28_REGS_LRADC_H__
 
-#include <asm/arch/regs-common.h>
+#include <asm/imx-common/regs-common.h>
 
 #ifndef	__ASSEMBLY__
 struct mxs_lradc_regs {
diff --git a/arch/arm/include/asm/arch-mxs/regs-ocotp.h b/arch/arm/include/asm/arch-mxs/regs-ocotp.h
index 3269892..5af3855 100644
--- a/arch/arm/include/asm/arch-mxs/regs-ocotp.h
+++ b/arch/arm/include/asm/arch-mxs/regs-ocotp.h
@@ -26,7 +26,7 @@
 #ifndef __MX28_REGS_OCOTP_H__
 #define __MX28_REGS_OCOTP_H__
 
-#include <asm/arch/regs-common.h>
+#include <asm/imx-common/regs-common.h>
 
 #ifndef	__ASSEMBLY__
 struct mxs_ocotp_regs {
diff --git a/arch/arm/include/asm/arch-mxs/regs-pinctrl.h b/arch/arm/include/asm/arch-mxs/regs-pinctrl.h
index d584170..191093b 100644
--- a/arch/arm/include/asm/arch-mxs/regs-pinctrl.h
+++ b/arch/arm/include/asm/arch-mxs/regs-pinctrl.h
@@ -26,7 +26,7 @@
 #ifndef __MX28_REGS_PINCTRL_H__
 #define __MX28_REGS_PINCTRL_H__
 
-#include <asm/arch/regs-common.h>
+#include <asm/imx-common/regs-common.h>
 
 #ifndef	__ASSEMBLY__
 struct mxs_pinctrl_regs {
diff --git a/arch/arm/include/asm/arch-mxs/regs-power-mx23.h b/arch/arm/include/asm/arch-mxs/regs-power-mx23.h
index 51a981a..a7430c4 100644
--- a/arch/arm/include/asm/arch-mxs/regs-power-mx23.h
+++ b/arch/arm/include/asm/arch-mxs/regs-power-mx23.h
@@ -22,7 +22,7 @@
 #ifndef __MX23_REGS_POWER_H__
 #define __MX23_REGS_POWER_H__
 
-#include <asm/arch/regs-common.h>
+#include <asm/imx-common/regs-common.h>
 
 #ifndef	__ASSEMBLY__
 struct mxs_power_regs {
diff --git a/arch/arm/include/asm/arch-mxs/regs-power-mx28.h b/arch/arm/include/asm/arch-mxs/regs-power-mx28.h
index 257ee88..4a73b1c 100644
--- a/arch/arm/include/asm/arch-mxs/regs-power-mx28.h
+++ b/arch/arm/include/asm/arch-mxs/regs-power-mx28.h
@@ -22,7 +22,7 @@
 #ifndef __MX28_REGS_POWER_H__
 #define __MX28_REGS_POWER_H__
 
-#include <asm/arch/regs-common.h>
+#include <asm/imx-common/regs-common.h>
 
 #ifndef	__ASSEMBLY__
 struct mxs_power_regs {
diff --git a/arch/arm/include/asm/arch-mxs/regs-rtc.h b/arch/arm/include/asm/arch-mxs/regs-rtc.h
index 6b2dd33..1926546 100644
--- a/arch/arm/include/asm/arch-mxs/regs-rtc.h
+++ b/arch/arm/include/asm/arch-mxs/regs-rtc.h
@@ -23,7 +23,7 @@
 #ifndef __MX28_REGS_RTC_H__
 #define __MX28_REGS_RTC_H__
 
-#include <asm/arch/regs-common.h>
+#include <asm/imx-common/regs-common.h>
 
 #ifndef	__ASSEMBLY__
 struct mxs_rtc_regs {
diff --git a/arch/arm/include/asm/arch-mxs/regs-ssp.h b/arch/arm/include/asm/arch-mxs/regs-ssp.h
index 9b30f56..a9e17b2 100644
--- a/arch/arm/include/asm/arch-mxs/regs-ssp.h
+++ b/arch/arm/include/asm/arch-mxs/regs-ssp.h
@@ -25,7 +25,7 @@
 #ifndef __MX28_REGS_SSP_H__
 #define __MX28_REGS_SSP_H__
 
-#include <asm/arch/regs-common.h>
+#include <asm/imx-common/regs-common.h>
 
 #ifndef	__ASSEMBLY__
 #if defined(CONFIG_MX23)
diff --git a/arch/arm/include/asm/arch-mxs/regs-timrot.h b/arch/arm/include/asm/arch-mxs/regs-timrot.h
index 529a3bc..f5d2b8e 100644
--- a/arch/arm/include/asm/arch-mxs/regs-timrot.h
+++ b/arch/arm/include/asm/arch-mxs/regs-timrot.h
@@ -25,7 +25,7 @@
 #ifndef __MX28_REGS_TIMROT_H__
 #define __MX28_REGS_TIMROT_H__
 
-#include <asm/arch/regs-common.h>
+#include <asm/imx-common/regs-common.h>
 
 #ifndef	__ASSEMBLY__
 struct mxs_timrot_regs {
diff --git a/arch/arm/include/asm/imx-common/dma.h b/arch/arm/include/asm/imx-common/dma.h
new file mode 100644
index 0000000..d665a0a
--- /dev/null
+++ b/arch/arm/include/asm/imx-common/dma.h
@@ -0,0 +1,162 @@
+/*
+ * Freescale i.MX28 APBH DMA
+ *
+ * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
+ * on behalf of DENX Software Engineering GmbH
+ *
+ * Based on code from LTIB:
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef __DMA_H__
+#define __DMA_H__
+
+#include <linux/list.h>
+#include <linux/compiler.h>
+
+#ifndef	CONFIG_ARCH_DMA_PIO_WORDS
+#define	DMA_PIO_WORDS		15
+#else
+#define	DMA_PIO_WORDS		CONFIG_ARCH_DMA_PIO_WORDS
+#endif
+
+#define MXS_DMA_ALIGNMENT	32
+
+/*
+ * MXS DMA channels
+ */
+#if defined(CONFIG_MX28)
+enum {
+	MXS_DMA_CHANNEL_AHB_APBH_SSP0 = 0,
+	MXS_DMA_CHANNEL_AHB_APBH_SSP1,
+	MXS_DMA_CHANNEL_AHB_APBH_SSP2,
+	MXS_DMA_CHANNEL_AHB_APBH_SSP3,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI0,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI1,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI2,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI3,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI4,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI5,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI6,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI7,
+	MXS_DMA_CHANNEL_AHB_APBH_SSP,
+	MXS_MAX_DMA_CHANNELS,
+};
+#elif defined(CONFIG_MX6)
+enum {
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI0 = 0,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI1,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI2,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI3,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI4,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI5,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI6,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI7,
+	MXS_MAX_DMA_CHANNELS,
+};
+#endif
+
+/*
+ * MXS DMA hardware command.
+ *
+ * This structure describes the in-memory layout of an entire DMA command,
+ * including space for the maximum number of PIO accesses. See the appropriate
+ * reference manual for a detailed description of what these fields mean to the
+ * DMA hardware.
+ */
+#define	MXS_DMA_DESC_COMMAND_MASK	0x3
+#define	MXS_DMA_DESC_COMMAND_OFFSET	0
+#define	MXS_DMA_DESC_COMMAND_NO_DMAXFER	0x0
+#define	MXS_DMA_DESC_COMMAND_DMA_WRITE	0x1
+#define	MXS_DMA_DESC_COMMAND_DMA_READ	0x2
+#define	MXS_DMA_DESC_COMMAND_DMA_SENSE	0x3
+#define	MXS_DMA_DESC_CHAIN		(1 << 2)
+#define	MXS_DMA_DESC_IRQ		(1 << 3)
+#define	MXS_DMA_DESC_NAND_LOCK		(1 << 4)
+#define	MXS_DMA_DESC_NAND_WAIT_4_READY	(1 << 5)
+#define	MXS_DMA_DESC_DEC_SEM		(1 << 6)
+#define	MXS_DMA_DESC_WAIT4END		(1 << 7)
+#define	MXS_DMA_DESC_HALT_ON_TERMINATE	(1 << 8)
+#define	MXS_DMA_DESC_TERMINATE_FLUSH	(1 << 9)
+#define	MXS_DMA_DESC_PIO_WORDS_MASK	(0xf << 12)
+#define	MXS_DMA_DESC_PIO_WORDS_OFFSET	12
+#define	MXS_DMA_DESC_BYTES_MASK		(0xffff << 16)
+#define	MXS_DMA_DESC_BYTES_OFFSET	16
+
+struct mxs_dma_cmd {
+	unsigned long		next;
+	unsigned long		data;
+	union {
+		dma_addr_t	address;
+		unsigned long	alternate;
+	};
+	unsigned long		pio_words[DMA_PIO_WORDS];
+};
+
+/*
+ * MXS DMA command descriptor.
+ *
+ * This structure incorporates an MXS DMA hardware command structure, along
+ * with metadata.
+ */
+#define	MXS_DMA_DESC_FIRST	(1 << 0)
+#define	MXS_DMA_DESC_LAST	(1 << 1)
+#define	MXS_DMA_DESC_READY	(1 << 31)
+
+struct mxs_dma_desc {
+	struct mxs_dma_cmd	cmd;
+	unsigned int		flags;
+	dma_addr_t		address;
+	void			*buffer;
+	struct list_head	node;
+} __aligned(MXS_DMA_ALIGNMENT);
+
+/**
+ * MXS DMA channel
+ *
+ * This structure represents a single DMA channel. The MXS platform code
+ * maintains an array of these structures to represent every DMA channel in the
+ * system (see mxs_dma_channels).
+ */
+#define	MXS_DMA_FLAGS_IDLE	0
+#define	MXS_DMA_FLAGS_BUSY	(1 << 0)
+#define	MXS_DMA_FLAGS_FREE	0
+#define	MXS_DMA_FLAGS_ALLOCATED	(1 << 16)
+#define	MXS_DMA_FLAGS_VALID	(1 << 31)
+
+struct mxs_dma_chan {
+	const char *name;
+	unsigned long dev;
+	struct mxs_dma_device *dma;
+	unsigned int flags;
+	unsigned int active_num;
+	unsigned int pending_num;
+	struct list_head active;
+	struct list_head done;
+};
+
+struct mxs_dma_desc *mxs_dma_desc_alloc(void);
+void mxs_dma_desc_free(struct mxs_dma_desc *);
+int mxs_dma_desc_append(int channel, struct mxs_dma_desc *pdesc);
+
+int mxs_dma_go(int chan);
+void mxs_dma_init(void);
+int mxs_dma_init_channel(int chan);
+int mxs_dma_release(int chan);
+
+#endif	/* __DMA_H__ */
diff --git a/arch/arm/include/asm/imx-common/imx_pwm.h b/arch/arm/include/asm/imx-common/imx_pwm.h
new file mode 100644
index 0000000..2e4a52a
--- /dev/null
+++ b/arch/arm/include/asm/imx-common/imx_pwm.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __IMX_PWM_H__
+#define __IMX_PWM_H__
+
+struct pwm_device {
+	unsigned long mmio_base;
+	unsigned int pwm_id;
+	int pwmo_invert;
+	void (*enable_pwm_pad)(void);
+	void (*disable_pwm_pad)(void);
+	void (*enable_pwm_clk)(void);
+	void (*disable_pwm_clk)(void);
+};
+
+int imx_pwm_config(struct pwm_device pwm, int duty_ns, int period_ns);
+int imx_pwm_enable(struct pwm_device pwm);
+int imx_pwm_disable(struct pwm_device pwm);
+
+#endif
diff --git a/arch/arm/include/asm/imx-common/regs-apbh.h b/arch/arm/include/asm/imx-common/regs-apbh.h
new file mode 100644
index 0000000..bcec6e0
--- /dev/null
+++ b/arch/arm/include/asm/imx-common/regs-apbh.h
@@ -0,0 +1,602 @@
+/*
+ * Freescale i.MX28 APBH Register Definitions
+ *
+ * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
+ * on behalf of DENX Software Engineering GmbH
+ *
+ * Based on code from LTIB:
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef __REGS_APBH_H__
+#define __REGS_APBH_H__
+
+#include <asm/imx-common/regs-common.h>
+
+#ifndef	__ASSEMBLY__
+
+#if defined(CONFIG_MX23)
+struct mxs_apbh_regs {
+	mxs_reg_32(hw_apbh_ctrl0)
+	mxs_reg_32(hw_apbh_ctrl1)
+	mxs_reg_32(hw_apbh_ctrl2)
+	mxs_reg_32(hw_apbh_channel_ctrl)
+
+	union {
+	struct {
+		mxs_reg_32(hw_apbh_ch_curcmdar)
+		mxs_reg_32(hw_apbh_ch_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch_cmd)
+		mxs_reg_32(hw_apbh_ch_bar)
+		mxs_reg_32(hw_apbh_ch_sema)
+		mxs_reg_32(hw_apbh_ch_debug1)
+		mxs_reg_32(hw_apbh_ch_debug2)
+	} ch[8];
+	struct {
+		mxs_reg_32(hw_apbh_ch0_curcmdar)
+		mxs_reg_32(hw_apbh_ch0_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch0_cmd)
+		mxs_reg_32(hw_apbh_ch0_bar)
+		mxs_reg_32(hw_apbh_ch0_sema)
+		mxs_reg_32(hw_apbh_ch0_debug1)
+		mxs_reg_32(hw_apbh_ch0_debug2)
+		mxs_reg_32(hw_apbh_ch1_curcmdar)
+		mxs_reg_32(hw_apbh_ch1_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch1_cmd)
+		mxs_reg_32(hw_apbh_ch1_bar)
+		mxs_reg_32(hw_apbh_ch1_sema)
+		mxs_reg_32(hw_apbh_ch1_debug1)
+		mxs_reg_32(hw_apbh_ch1_debug2)
+		mxs_reg_32(hw_apbh_ch2_curcmdar)
+		mxs_reg_32(hw_apbh_ch2_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch2_cmd)
+		mxs_reg_32(hw_apbh_ch2_bar)
+		mxs_reg_32(hw_apbh_ch2_sema)
+		mxs_reg_32(hw_apbh_ch2_debug1)
+		mxs_reg_32(hw_apbh_ch2_debug2)
+		mxs_reg_32(hw_apbh_ch3_curcmdar)
+		mxs_reg_32(hw_apbh_ch3_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch3_cmd)
+		mxs_reg_32(hw_apbh_ch3_bar)
+		mxs_reg_32(hw_apbh_ch3_sema)
+		mxs_reg_32(hw_apbh_ch3_debug1)
+		mxs_reg_32(hw_apbh_ch3_debug2)
+		mxs_reg_32(hw_apbh_ch4_curcmdar)
+		mxs_reg_32(hw_apbh_ch4_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch4_cmd)
+		mxs_reg_32(hw_apbh_ch4_bar)
+		mxs_reg_32(hw_apbh_ch4_sema)
+		mxs_reg_32(hw_apbh_ch4_debug1)
+		mxs_reg_32(hw_apbh_ch4_debug2)
+		mxs_reg_32(hw_apbh_ch5_curcmdar)
+		mxs_reg_32(hw_apbh_ch5_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch5_cmd)
+		mxs_reg_32(hw_apbh_ch5_bar)
+		mxs_reg_32(hw_apbh_ch5_sema)
+		mxs_reg_32(hw_apbh_ch5_debug1)
+		mxs_reg_32(hw_apbh_ch5_debug2)
+		mxs_reg_32(hw_apbh_ch6_curcmdar)
+		mxs_reg_32(hw_apbh_ch6_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch6_cmd)
+		mxs_reg_32(hw_apbh_ch6_bar)
+		mxs_reg_32(hw_apbh_ch6_sema)
+		mxs_reg_32(hw_apbh_ch6_debug1)
+		mxs_reg_32(hw_apbh_ch6_debug2)
+		mxs_reg_32(hw_apbh_ch7_curcmdar)
+		mxs_reg_32(hw_apbh_ch7_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch7_cmd)
+		mxs_reg_32(hw_apbh_ch7_bar)
+		mxs_reg_32(hw_apbh_ch7_sema)
+		mxs_reg_32(hw_apbh_ch7_debug1)
+		mxs_reg_32(hw_apbh_ch7_debug2)
+	};
+	};
+	mxs_reg_32(hw_apbh_version)
+};
+
+#elif (defined(CONFIG_MX28) || defined(CONFIG_MX6))
+struct mxs_apbh_regs {
+	mxs_reg_32(hw_apbh_ctrl0)
+	mxs_reg_32(hw_apbh_ctrl1)
+	mxs_reg_32(hw_apbh_ctrl2)
+	mxs_reg_32(hw_apbh_channel_ctrl)
+	mxs_reg_32(hw_apbh_devsel)
+	mxs_reg_32(hw_apbh_dma_burst_size)
+	mxs_reg_32(hw_apbh_debug)
+
+	uint32_t	reserved[36];
+
+	union {
+	struct {
+		mxs_reg_32(hw_apbh_ch_curcmdar)
+		mxs_reg_32(hw_apbh_ch_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch_cmd)
+		mxs_reg_32(hw_apbh_ch_bar)
+		mxs_reg_32(hw_apbh_ch_sema)
+		mxs_reg_32(hw_apbh_ch_debug1)
+		mxs_reg_32(hw_apbh_ch_debug2)
+	} ch[16];
+	struct {
+		mxs_reg_32(hw_apbh_ch0_curcmdar)
+		mxs_reg_32(hw_apbh_ch0_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch0_cmd)
+		mxs_reg_32(hw_apbh_ch0_bar)
+		mxs_reg_32(hw_apbh_ch0_sema)
+		mxs_reg_32(hw_apbh_ch0_debug1)
+		mxs_reg_32(hw_apbh_ch0_debug2)
+		mxs_reg_32(hw_apbh_ch1_curcmdar)
+		mxs_reg_32(hw_apbh_ch1_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch1_cmd)
+		mxs_reg_32(hw_apbh_ch1_bar)
+		mxs_reg_32(hw_apbh_ch1_sema)
+		mxs_reg_32(hw_apbh_ch1_debug1)
+		mxs_reg_32(hw_apbh_ch1_debug2)
+		mxs_reg_32(hw_apbh_ch2_curcmdar)
+		mxs_reg_32(hw_apbh_ch2_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch2_cmd)
+		mxs_reg_32(hw_apbh_ch2_bar)
+		mxs_reg_32(hw_apbh_ch2_sema)
+		mxs_reg_32(hw_apbh_ch2_debug1)
+		mxs_reg_32(hw_apbh_ch2_debug2)
+		mxs_reg_32(hw_apbh_ch3_curcmdar)
+		mxs_reg_32(hw_apbh_ch3_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch3_cmd)
+		mxs_reg_32(hw_apbh_ch3_bar)
+		mxs_reg_32(hw_apbh_ch3_sema)
+		mxs_reg_32(hw_apbh_ch3_debug1)
+		mxs_reg_32(hw_apbh_ch3_debug2)
+		mxs_reg_32(hw_apbh_ch4_curcmdar)
+		mxs_reg_32(hw_apbh_ch4_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch4_cmd)
+		mxs_reg_32(hw_apbh_ch4_bar)
+		mxs_reg_32(hw_apbh_ch4_sema)
+		mxs_reg_32(hw_apbh_ch4_debug1)
+		mxs_reg_32(hw_apbh_ch4_debug2)
+		mxs_reg_32(hw_apbh_ch5_curcmdar)
+		mxs_reg_32(hw_apbh_ch5_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch5_cmd)
+		mxs_reg_32(hw_apbh_ch5_bar)
+		mxs_reg_32(hw_apbh_ch5_sema)
+		mxs_reg_32(hw_apbh_ch5_debug1)
+		mxs_reg_32(hw_apbh_ch5_debug2)
+		mxs_reg_32(hw_apbh_ch6_curcmdar)
+		mxs_reg_32(hw_apbh_ch6_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch6_cmd)
+		mxs_reg_32(hw_apbh_ch6_bar)
+		mxs_reg_32(hw_apbh_ch6_sema)
+		mxs_reg_32(hw_apbh_ch6_debug1)
+		mxs_reg_32(hw_apbh_ch6_debug2)
+		mxs_reg_32(hw_apbh_ch7_curcmdar)
+		mxs_reg_32(hw_apbh_ch7_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch7_cmd)
+		mxs_reg_32(hw_apbh_ch7_bar)
+		mxs_reg_32(hw_apbh_ch7_sema)
+		mxs_reg_32(hw_apbh_ch7_debug1)
+		mxs_reg_32(hw_apbh_ch7_debug2)
+		mxs_reg_32(hw_apbh_ch8_curcmdar)
+		mxs_reg_32(hw_apbh_ch8_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch8_cmd)
+		mxs_reg_32(hw_apbh_ch8_bar)
+		mxs_reg_32(hw_apbh_ch8_sema)
+		mxs_reg_32(hw_apbh_ch8_debug1)
+		mxs_reg_32(hw_apbh_ch8_debug2)
+		mxs_reg_32(hw_apbh_ch9_curcmdar)
+		mxs_reg_32(hw_apbh_ch9_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch9_cmd)
+		mxs_reg_32(hw_apbh_ch9_bar)
+		mxs_reg_32(hw_apbh_ch9_sema)
+		mxs_reg_32(hw_apbh_ch9_debug1)
+		mxs_reg_32(hw_apbh_ch9_debug2)
+		mxs_reg_32(hw_apbh_ch10_curcmdar)
+		mxs_reg_32(hw_apbh_ch10_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch10_cmd)
+		mxs_reg_32(hw_apbh_ch10_bar)
+		mxs_reg_32(hw_apbh_ch10_sema)
+		mxs_reg_32(hw_apbh_ch10_debug1)
+		mxs_reg_32(hw_apbh_ch10_debug2)
+		mxs_reg_32(hw_apbh_ch11_curcmdar)
+		mxs_reg_32(hw_apbh_ch11_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch11_cmd)
+		mxs_reg_32(hw_apbh_ch11_bar)
+		mxs_reg_32(hw_apbh_ch11_sema)
+		mxs_reg_32(hw_apbh_ch11_debug1)
+		mxs_reg_32(hw_apbh_ch11_debug2)
+		mxs_reg_32(hw_apbh_ch12_curcmdar)
+		mxs_reg_32(hw_apbh_ch12_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch12_cmd)
+		mxs_reg_32(hw_apbh_ch12_bar)
+		mxs_reg_32(hw_apbh_ch12_sema)
+		mxs_reg_32(hw_apbh_ch12_debug1)
+		mxs_reg_32(hw_apbh_ch12_debug2)
+		mxs_reg_32(hw_apbh_ch13_curcmdar)
+		mxs_reg_32(hw_apbh_ch13_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch13_cmd)
+		mxs_reg_32(hw_apbh_ch13_bar)
+		mxs_reg_32(hw_apbh_ch13_sema)
+		mxs_reg_32(hw_apbh_ch13_debug1)
+		mxs_reg_32(hw_apbh_ch13_debug2)
+		mxs_reg_32(hw_apbh_ch14_curcmdar)
+		mxs_reg_32(hw_apbh_ch14_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch14_cmd)
+		mxs_reg_32(hw_apbh_ch14_bar)
+		mxs_reg_32(hw_apbh_ch14_sema)
+		mxs_reg_32(hw_apbh_ch14_debug1)
+		mxs_reg_32(hw_apbh_ch14_debug2)
+		mxs_reg_32(hw_apbh_ch15_curcmdar)
+		mxs_reg_32(hw_apbh_ch15_nxtcmdar)
+		mxs_reg_32(hw_apbh_ch15_cmd)
+		mxs_reg_32(hw_apbh_ch15_bar)
+		mxs_reg_32(hw_apbh_ch15_sema)
+		mxs_reg_32(hw_apbh_ch15_debug1)
+		mxs_reg_32(hw_apbh_ch15_debug2)
+	};
+	};
+	mxs_reg_32(hw_apbh_version)
+};
+#endif
+
+#endif
+
+#define	APBH_CTRL0_SFTRST				(1 << 31)
+#define	APBH_CTRL0_CLKGATE				(1 << 30)
+#define	APBH_CTRL0_AHB_BURST8_EN			(1 << 29)
+#define	APBH_CTRL0_APB_BURST_EN				(1 << 28)
+#if defined(CONFIG_MX23)
+#define	APBH_CTRL0_RSVD0_MASK				(0xf << 24)
+#define	APBH_CTRL0_RSVD0_OFFSET				24
+#define	APBH_CTRL0_RESET_CHANNEL_MASK			(0xff << 16)
+#define	APBH_CTRL0_RESET_CHANNEL_OFFSET			16
+#define	APBH_CTRL0_CLKGATE_CHANNEL_MASK			(0xff << 8)
+#define	APBH_CTRL0_CLKGATE_CHANNEL_OFFSET		8
+#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP0			0x02
+#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP1			0x04
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND0		0x10
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND1		0x20
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND2		0x40
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND3		0x80
+#elif defined(CONFIG_MX28)
+#define	APBH_CTRL0_RSVD0_MASK				(0xfff << 16)
+#define	APBH_CTRL0_RSVD0_OFFSET				16
+#define	APBH_CTRL0_CLKGATE_CHANNEL_MASK			0xffff
+#define	APBH_CTRL0_CLKGATE_CHANNEL_OFFSET		0
+#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP0			0x0001
+#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP1			0x0002
+#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP2			0x0004
+#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP3			0x0008
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND0		0x0010
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND1		0x0020
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND2		0x0040
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND3		0x0080
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND4		0x0100
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND5		0x0200
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND6		0x0400
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND7		0x0800
+#define	APBH_CTRL0_CLKGATE_CHANNEL_HSADC		0x1000
+#define	APBH_CTRL0_CLKGATE_CHANNEL_LCDIF		0x2000
+#elif defined(CONFIG_MX6)
+#define	APBH_CTRL0_CLKGATE_CHANNEL_OFFSET		0
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND0		0x0001
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND1		0x0002
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND2		0x0004
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND3		0x0008
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND4		0x0010
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND5		0x0020
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND6		0x0040
+#define	APBH_CTRL0_CLKGATE_CHANNEL_NAND7		0x0080
+#define	APBH_CTRL0_CLKGATE_CHANNEL_SSP			0x0100
+#endif
+
+#define	APBH_CTRL1_CH15_CMDCMPLT_IRQ_EN			(1 << 31)
+#define	APBH_CTRL1_CH14_CMDCMPLT_IRQ_EN			(1 << 30)
+#define	APBH_CTRL1_CH13_CMDCMPLT_IRQ_EN			(1 << 29)
+#define	APBH_CTRL1_CH12_CMDCMPLT_IRQ_EN			(1 << 28)
+#define	APBH_CTRL1_CH11_CMDCMPLT_IRQ_EN			(1 << 27)
+#define	APBH_CTRL1_CH10_CMDCMPLT_IRQ_EN			(1 << 26)
+#define	APBH_CTRL1_CH9_CMDCMPLT_IRQ_EN			(1 << 25)
+#define	APBH_CTRL1_CH8_CMDCMPLT_IRQ_EN			(1 << 24)
+#define	APBH_CTRL1_CH7_CMDCMPLT_IRQ_EN			(1 << 23)
+#define	APBH_CTRL1_CH6_CMDCMPLT_IRQ_EN			(1 << 22)
+#define	APBH_CTRL1_CH5_CMDCMPLT_IRQ_EN			(1 << 21)
+#define	APBH_CTRL1_CH4_CMDCMPLT_IRQ_EN			(1 << 20)
+#define	APBH_CTRL1_CH3_CMDCMPLT_IRQ_EN			(1 << 19)
+#define	APBH_CTRL1_CH2_CMDCMPLT_IRQ_EN			(1 << 18)
+#define	APBH_CTRL1_CH1_CMDCMPLT_IRQ_EN			(1 << 17)
+#define	APBH_CTRL1_CH0_CMDCMPLT_IRQ_EN			(1 << 16)
+#define	APBH_CTRL1_CH_CMDCMPLT_IRQ_EN_OFFSET		16
+#define	APBH_CTRL1_CH_CMDCMPLT_IRQ_EN_MASK		(0xffff << 16)
+#define	APBH_CTRL1_CH15_CMDCMPLT_IRQ			(1 << 15)
+#define	APBH_CTRL1_CH14_CMDCMPLT_IRQ			(1 << 14)
+#define	APBH_CTRL1_CH13_CMDCMPLT_IRQ			(1 << 13)
+#define	APBH_CTRL1_CH12_CMDCMPLT_IRQ			(1 << 12)
+#define	APBH_CTRL1_CH11_CMDCMPLT_IRQ			(1 << 11)
+#define	APBH_CTRL1_CH10_CMDCMPLT_IRQ			(1 << 10)
+#define	APBH_CTRL1_CH9_CMDCMPLT_IRQ			(1 << 9)
+#define	APBH_CTRL1_CH8_CMDCMPLT_IRQ			(1 << 8)
+#define	APBH_CTRL1_CH7_CMDCMPLT_IRQ			(1 << 7)
+#define	APBH_CTRL1_CH6_CMDCMPLT_IRQ			(1 << 6)
+#define	APBH_CTRL1_CH5_CMDCMPLT_IRQ			(1 << 5)
+#define	APBH_CTRL1_CH4_CMDCMPLT_IRQ			(1 << 4)
+#define	APBH_CTRL1_CH3_CMDCMPLT_IRQ			(1 << 3)
+#define	APBH_CTRL1_CH2_CMDCMPLT_IRQ			(1 << 2)
+#define	APBH_CTRL1_CH1_CMDCMPLT_IRQ			(1 << 1)
+#define	APBH_CTRL1_CH0_CMDCMPLT_IRQ			(1 << 0)
+
+#define	APBH_CTRL2_CH15_ERROR_STATUS			(1 << 31)
+#define	APBH_CTRL2_CH14_ERROR_STATUS			(1 << 30)
+#define	APBH_CTRL2_CH13_ERROR_STATUS			(1 << 29)
+#define	APBH_CTRL2_CH12_ERROR_STATUS			(1 << 28)
+#define	APBH_CTRL2_CH11_ERROR_STATUS			(1 << 27)
+#define	APBH_CTRL2_CH10_ERROR_STATUS			(1 << 26)
+#define	APBH_CTRL2_CH9_ERROR_STATUS			(1 << 25)
+#define	APBH_CTRL2_CH8_ERROR_STATUS			(1 << 24)
+#define	APBH_CTRL2_CH7_ERROR_STATUS			(1 << 23)
+#define	APBH_CTRL2_CH6_ERROR_STATUS			(1 << 22)
+#define	APBH_CTRL2_CH5_ERROR_STATUS			(1 << 21)
+#define	APBH_CTRL2_CH4_ERROR_STATUS			(1 << 20)
+#define	APBH_CTRL2_CH3_ERROR_STATUS			(1 << 19)
+#define	APBH_CTRL2_CH2_ERROR_STATUS			(1 << 18)
+#define	APBH_CTRL2_CH1_ERROR_STATUS			(1 << 17)
+#define	APBH_CTRL2_CH0_ERROR_STATUS			(1 << 16)
+#define	APBH_CTRL2_CH15_ERROR_IRQ			(1 << 15)
+#define	APBH_CTRL2_CH14_ERROR_IRQ			(1 << 14)
+#define	APBH_CTRL2_CH13_ERROR_IRQ			(1 << 13)
+#define	APBH_CTRL2_CH12_ERROR_IRQ			(1 << 12)
+#define	APBH_CTRL2_CH11_ERROR_IRQ			(1 << 11)
+#define	APBH_CTRL2_CH10_ERROR_IRQ			(1 << 10)
+#define	APBH_CTRL2_CH9_ERROR_IRQ			(1 << 9)
+#define	APBH_CTRL2_CH8_ERROR_IRQ			(1 << 8)
+#define	APBH_CTRL2_CH7_ERROR_IRQ			(1 << 7)
+#define	APBH_CTRL2_CH6_ERROR_IRQ			(1 << 6)
+#define	APBH_CTRL2_CH5_ERROR_IRQ			(1 << 5)
+#define	APBH_CTRL2_CH4_ERROR_IRQ			(1 << 4)
+#define	APBH_CTRL2_CH3_ERROR_IRQ			(1 << 3)
+#define	APBH_CTRL2_CH2_ERROR_IRQ			(1 << 2)
+#define	APBH_CTRL2_CH1_ERROR_IRQ			(1 << 1)
+#define	APBH_CTRL2_CH0_ERROR_IRQ			(1 << 0)
+
+#if defined(CONFIG_MX28)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_MASK		(0xffff << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_OFFSET		16
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_SSP0		(0x0001 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_SSP1		(0x0002 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_SSP2		(0x0004 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_SSP3		(0x0008 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND0		(0x0010 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND1		(0x0020 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND2		(0x0040 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND3		(0x0080 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND4		(0x0100 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND5		(0x0200 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND6		(0x0400 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_NAND7		(0x0800 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_HSADC		(0x1000 << 16)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_LCDIF		(0x2000 << 16)
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_MASK		0xffff
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_OFFSET		0
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_SSP0		0x0001
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_SSP1		0x0002
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_SSP2		0x0004
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_SSP3		0x0008
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND0		0x0010
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND1		0x0020
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND2		0x0040
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND3		0x0080
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND4		0x0100
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND5		0x0200
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND6		0x0400
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_NAND7		0x0800
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_HSADC		0x1000
+#define	APBH_CHANNEL_CTRL_FREEZE_CHANNEL_LCDIF		0x2000
+#endif
+
+#if defined(CONFIG_MX6)
+#define	APBH_CHANNEL_CTRL_RESET_CHANNEL_OFFSET		16
+#endif
+
+#if defined(CONFIG_MX23)
+#define	APBH_DEVSEL_CH7_MASK				(0xf << 28)
+#define	APBH_DEVSEL_CH7_OFFSET				28
+#define	APBH_DEVSEL_CH6_MASK				(0xf << 24)
+#define	APBH_DEVSEL_CH6_OFFSET				24
+#define	APBH_DEVSEL_CH5_MASK				(0xf << 20)
+#define	APBH_DEVSEL_CH5_OFFSET				20
+#define	APBH_DEVSEL_CH4_MASK				(0xf << 16)
+#define	APBH_DEVSEL_CH4_OFFSET				16
+#define	APBH_DEVSEL_CH3_MASK				(0xf << 12)
+#define	APBH_DEVSEL_CH3_OFFSET				12
+#define	APBH_DEVSEL_CH2_MASK				(0xf << 8)
+#define	APBH_DEVSEL_CH2_OFFSET				8
+#define	APBH_DEVSEL_CH1_MASK				(0xf << 4)
+#define	APBH_DEVSEL_CH1_OFFSET				4
+#define	APBH_DEVSEL_CH0_MASK				(0xf << 0)
+#define	APBH_DEVSEL_CH0_OFFSET				0
+#elif defined(CONFIG_MX28)
+#define	APBH_DEVSEL_CH15_MASK				(0x3 << 30)
+#define	APBH_DEVSEL_CH15_OFFSET				30
+#define	APBH_DEVSEL_CH14_MASK				(0x3 << 28)
+#define	APBH_DEVSEL_CH14_OFFSET				28
+#define	APBH_DEVSEL_CH13_MASK				(0x3 << 26)
+#define	APBH_DEVSEL_CH13_OFFSET				26
+#define	APBH_DEVSEL_CH12_MASK				(0x3 << 24)
+#define	APBH_DEVSEL_CH12_OFFSET				24
+#define	APBH_DEVSEL_CH11_MASK				(0x3 << 22)
+#define	APBH_DEVSEL_CH11_OFFSET				22
+#define	APBH_DEVSEL_CH10_MASK				(0x3 << 20)
+#define	APBH_DEVSEL_CH10_OFFSET				20
+#define	APBH_DEVSEL_CH9_MASK				(0x3 << 18)
+#define	APBH_DEVSEL_CH9_OFFSET				18
+#define	APBH_DEVSEL_CH8_MASK				(0x3 << 16)
+#define	APBH_DEVSEL_CH8_OFFSET				16
+#define	APBH_DEVSEL_CH7_MASK				(0x3 << 14)
+#define	APBH_DEVSEL_CH7_OFFSET				14
+#define	APBH_DEVSEL_CH6_MASK				(0x3 << 12)
+#define	APBH_DEVSEL_CH6_OFFSET				12
+#define	APBH_DEVSEL_CH5_MASK				(0x3 << 10)
+#define	APBH_DEVSEL_CH5_OFFSET				10
+#define	APBH_DEVSEL_CH4_MASK				(0x3 << 8)
+#define	APBH_DEVSEL_CH4_OFFSET				8
+#define	APBH_DEVSEL_CH3_MASK				(0x3 << 6)
+#define	APBH_DEVSEL_CH3_OFFSET				6
+#define	APBH_DEVSEL_CH2_MASK				(0x3 << 4)
+#define	APBH_DEVSEL_CH2_OFFSET				4
+#define	APBH_DEVSEL_CH1_MASK				(0x3 << 2)
+#define	APBH_DEVSEL_CH1_OFFSET				2
+#define	APBH_DEVSEL_CH0_MASK				(0x3 << 0)
+#define	APBH_DEVSEL_CH0_OFFSET				0
+#endif
+
+#if defined(CONFIG_MX28)
+#define	APBH_DMA_BURST_SIZE_CH15_MASK			(0x3 << 30)
+#define	APBH_DMA_BURST_SIZE_CH15_OFFSET			30
+#define	APBH_DMA_BURST_SIZE_CH14_MASK			(0x3 << 28)
+#define	APBH_DMA_BURST_SIZE_CH14_OFFSET			28
+#define	APBH_DMA_BURST_SIZE_CH13_MASK			(0x3 << 26)
+#define	APBH_DMA_BURST_SIZE_CH13_OFFSET			26
+#define	APBH_DMA_BURST_SIZE_CH12_MASK			(0x3 << 24)
+#define	APBH_DMA_BURST_SIZE_CH12_OFFSET			24
+#define	APBH_DMA_BURST_SIZE_CH11_MASK			(0x3 << 22)
+#define	APBH_DMA_BURST_SIZE_CH11_OFFSET			22
+#define	APBH_DMA_BURST_SIZE_CH10_MASK			(0x3 << 20)
+#define	APBH_DMA_BURST_SIZE_CH10_OFFSET			20
+#define	APBH_DMA_BURST_SIZE_CH9_MASK			(0x3 << 18)
+#define	APBH_DMA_BURST_SIZE_CH9_OFFSET			18
+#define	APBH_DMA_BURST_SIZE_CH8_MASK			(0x3 << 16)
+#define	APBH_DMA_BURST_SIZE_CH8_OFFSET			16
+#define	APBH_DMA_BURST_SIZE_CH8_BURST0			(0x0 << 16)
+#define	APBH_DMA_BURST_SIZE_CH8_BURST4			(0x1 << 16)
+#define	APBH_DMA_BURST_SIZE_CH8_BURST8			(0x2 << 16)
+#define	APBH_DMA_BURST_SIZE_CH7_MASK			(0x3 << 14)
+#define	APBH_DMA_BURST_SIZE_CH7_OFFSET			14
+#define	APBH_DMA_BURST_SIZE_CH6_MASK			(0x3 << 12)
+#define	APBH_DMA_BURST_SIZE_CH6_OFFSET			12
+#define	APBH_DMA_BURST_SIZE_CH5_MASK			(0x3 << 10)
+#define	APBH_DMA_BURST_SIZE_CH5_OFFSET			10
+#define	APBH_DMA_BURST_SIZE_CH4_MASK			(0x3 << 8)
+#define	APBH_DMA_BURST_SIZE_CH4_OFFSET			8
+#define	APBH_DMA_BURST_SIZE_CH3_MASK			(0x3 << 6)
+#define	APBH_DMA_BURST_SIZE_CH3_OFFSET			6
+#define	APBH_DMA_BURST_SIZE_CH3_BURST0			(0x0 << 6)
+#define	APBH_DMA_BURST_SIZE_CH3_BURST4			(0x1 << 6)
+#define	APBH_DMA_BURST_SIZE_CH3_BURST8			(0x2 << 6)
+
+#define	APBH_DMA_BURST_SIZE_CH2_MASK			(0x3 << 4)
+#define	APBH_DMA_BURST_SIZE_CH2_OFFSET			4
+#define	APBH_DMA_BURST_SIZE_CH2_BURST0			(0x0 << 4)
+#define	APBH_DMA_BURST_SIZE_CH2_BURST4			(0x1 << 4)
+#define	APBH_DMA_BURST_SIZE_CH2_BURST8			(0x2 << 4)
+#define	APBH_DMA_BURST_SIZE_CH1_MASK			(0x3 << 2)
+#define	APBH_DMA_BURST_SIZE_CH1_OFFSET			2
+#define	APBH_DMA_BURST_SIZE_CH1_BURST0			(0x0 << 2)
+#define	APBH_DMA_BURST_SIZE_CH1_BURST4			(0x1 << 2)
+#define	APBH_DMA_BURST_SIZE_CH1_BURST8			(0x2 << 2)
+
+#define	APBH_DMA_BURST_SIZE_CH0_MASK			0x3
+#define	APBH_DMA_BURST_SIZE_CH0_OFFSET			0
+#define	APBH_DMA_BURST_SIZE_CH0_BURST0			0x0
+#define	APBH_DMA_BURST_SIZE_CH0_BURST4			0x1
+#define	APBH_DMA_BURST_SIZE_CH0_BURST8			0x2
+
+#define	APBH_DEBUG_GPMI_ONE_FIFO			(1 << 0)
+#endif
+
+#define	APBH_CHn_CURCMDAR_CMD_ADDR_MASK			0xffffffff
+#define	APBH_CHn_CURCMDAR_CMD_ADDR_OFFSET		0
+
+#define	APBH_CHn_NXTCMDAR_CMD_ADDR_MASK			0xffffffff
+#define	APBH_CHn_NXTCMDAR_CMD_ADDR_OFFSET		0
+
+#define	APBH_CHn_CMD_XFER_COUNT_MASK			(0xffff << 16)
+#define	APBH_CHn_CMD_XFER_COUNT_OFFSET			16
+#define	APBH_CHn_CMD_CMDWORDS_MASK			(0xf << 12)
+#define	APBH_CHn_CMD_CMDWORDS_OFFSET			12
+#define	APBH_CHn_CMD_HALTONTERMINATE			(1 << 8)
+#define	APBH_CHn_CMD_WAIT4ENDCMD			(1 << 7)
+#define	APBH_CHn_CMD_SEMAPHORE				(1 << 6)
+#define	APBH_CHn_CMD_NANDWAIT4READY			(1 << 5)
+#define	APBH_CHn_CMD_NANDLOCK				(1 << 4)
+#define	APBH_CHn_CMD_IRQONCMPLT				(1 << 3)
+#define	APBH_CHn_CMD_CHAIN				(1 << 2)
+#define	APBH_CHn_CMD_COMMAND_MASK			0x3
+#define	APBH_CHn_CMD_COMMAND_OFFSET			0
+#define	APBH_CHn_CMD_COMMAND_NO_DMA_XFER		0x0
+#define	APBH_CHn_CMD_COMMAND_DMA_WRITE			0x1
+#define	APBH_CHn_CMD_COMMAND_DMA_READ			0x2
+#define	APBH_CHn_CMD_COMMAND_DMA_SENSE			0x3
+
+#define	APBH_CHn_BAR_ADDRESS_MASK			0xffffffff
+#define	APBH_CHn_BAR_ADDRESS_OFFSET			0
+
+#define	APBH_CHn_SEMA_RSVD2_MASK			(0xff << 24)
+#define	APBH_CHn_SEMA_RSVD2_OFFSET			24
+#define	APBH_CHn_SEMA_PHORE_MASK			(0xff << 16)
+#define	APBH_CHn_SEMA_PHORE_OFFSET			16
+#define	APBH_CHn_SEMA_RSVD1_MASK			(0xff << 8)
+#define	APBH_CHn_SEMA_RSVD1_OFFSET			8
+#define	APBH_CHn_SEMA_INCREMENT_SEMA_MASK		(0xff << 0)
+#define	APBH_CHn_SEMA_INCREMENT_SEMA_OFFSET		0
+
+#define	APBH_CHn_DEBUG1_REQ				(1 << 31)
+#define	APBH_CHn_DEBUG1_BURST				(1 << 30)
+#define	APBH_CHn_DEBUG1_KICK				(1 << 29)
+#define	APBH_CHn_DEBUG1_END				(1 << 28)
+#define	APBH_CHn_DEBUG1_SENSE				(1 << 27)
+#define	APBH_CHn_DEBUG1_READY				(1 << 26)
+#define	APBH_CHn_DEBUG1_LOCK				(1 << 25)
+#define	APBH_CHn_DEBUG1_NEXTCMDADDRVALID		(1 << 24)
+#define	APBH_CHn_DEBUG1_RD_FIFO_EMPTY			(1 << 23)
+#define	APBH_CHn_DEBUG1_RD_FIFO_FULL			(1 << 22)
+#define	APBH_CHn_DEBUG1_WR_FIFO_EMPTY			(1 << 21)
+#define	APBH_CHn_DEBUG1_WR_FIFO_FULL			(1 << 20)
+#define	APBH_CHn_DEBUG1_RSVD1_MASK			(0x7fff << 5)
+#define	APBH_CHn_DEBUG1_RSVD1_OFFSET			5
+#define	APBH_CHn_DEBUG1_STATEMACHINE_MASK		0x1f
+#define	APBH_CHn_DEBUG1_STATEMACHINE_OFFSET		0
+#define	APBH_CHn_DEBUG1_STATEMACHINE_IDLE		0x00
+#define	APBH_CHn_DEBUG1_STATEMACHINE_REQ_CMD1		0x01
+#define	APBH_CHn_DEBUG1_STATEMACHINE_REQ_CMD3		0x02
+#define	APBH_CHn_DEBUG1_STATEMACHINE_REQ_CMD2		0x03
+#define	APBH_CHn_DEBUG1_STATEMACHINE_XFER_DECODE	0x04
+#define	APBH_CHn_DEBUG1_STATEMACHINE_REQ_WAIT		0x05
+#define	APBH_CHn_DEBUG1_STATEMACHINE_REQ_CMD4		0x06
+#define	APBH_CHn_DEBUG1_STATEMACHINE_PIO_REQ		0x07
+#define	APBH_CHn_DEBUG1_STATEMACHINE_READ_FLUSH		0x08
+#define	APBH_CHn_DEBUG1_STATEMACHINE_READ_WAIT		0x09
+#define	APBH_CHn_DEBUG1_STATEMACHINE_WRITE		0x0c
+#define	APBH_CHn_DEBUG1_STATEMACHINE_READ_REQ		0x0d
+#define	APBH_CHn_DEBUG1_STATEMACHINE_CHECK_CHAIN	0x0e
+#define	APBH_CHn_DEBUG1_STATEMACHINE_XFER_COMPLETE	0x0f
+#define	APBH_CHn_DEBUG1_STATEMACHINE_TERMINATE		0x14
+#define	APBH_CHn_DEBUG1_STATEMACHINE_WAIT_END		0x15
+#define	APBH_CHn_DEBUG1_STATEMACHINE_WRITE_WAIT		0x1c
+#define	APBH_CHn_DEBUG1_STATEMACHINE_HALT_AFTER_TERM	0x1d
+#define	APBH_CHn_DEBUG1_STATEMACHINE_CHECK_WAIT		0x1e
+#define	APBH_CHn_DEBUG1_STATEMACHINE_WAIT_READY		0x1f
+
+#define	APBH_CHn_DEBUG2_APB_BYTES_MASK			(0xffff << 16)
+#define	APBH_CHn_DEBUG2_APB_BYTES_OFFSET		16
+#define	APBH_CHn_DEBUG2_AHB_BYTES_MASK			0xffff
+#define	APBH_CHn_DEBUG2_AHB_BYTES_OFFSET		0
+
+#define	APBH_VERSION_MAJOR_MASK				(0xff << 24)
+#define	APBH_VERSION_MAJOR_OFFSET			24
+#define	APBH_VERSION_MINOR_MASK				(0xff << 16)
+#define	APBH_VERSION_MINOR_OFFSET			16
+#define	APBH_VERSION_STEP_MASK				0xffff
+#define	APBH_VERSION_STEP_OFFSET			0
+
+#endif	/* __REGS_APBH_H__ */
diff --git a/arch/arm/include/asm/imx-common/regs-bch.h b/arch/arm/include/asm/imx-common/regs-bch.h
new file mode 100644
index 0000000..dbe7ac8
--- /dev/null
+++ b/arch/arm/include/asm/imx-common/regs-bch.h
@@ -0,0 +1,240 @@
+/*
+ * Freescale i.MX28 BCH Register Definitions
+ *
+ * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
+ * on behalf of DENX Software Engineering GmbH
+ *
+ * Based on code from LTIB:
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef __MX28_REGS_BCH_H__
+#define __MX28_REGS_BCH_H__
+
+#include <asm/imx-common/regs-common.h>
+
+#ifndef	__ASSEMBLY__
+struct mxs_bch_regs {
+	mxs_reg_32(hw_bch_ctrl)
+	mxs_reg_32(hw_bch_status0)
+	mxs_reg_32(hw_bch_mode)
+	mxs_reg_32(hw_bch_encodeptr)
+	mxs_reg_32(hw_bch_dataptr)
+	mxs_reg_32(hw_bch_metaptr)
+
+	uint32_t	reserved[4];
+
+	mxs_reg_32(hw_bch_layoutselect)
+	mxs_reg_32(hw_bch_flash0layout0)
+	mxs_reg_32(hw_bch_flash0layout1)
+	mxs_reg_32(hw_bch_flash1layout0)
+	mxs_reg_32(hw_bch_flash1layout1)
+	mxs_reg_32(hw_bch_flash2layout0)
+	mxs_reg_32(hw_bch_flash2layout1)
+	mxs_reg_32(hw_bch_flash3layout0)
+	mxs_reg_32(hw_bch_flash3layout1)
+	mxs_reg_32(hw_bch_dbgkesread)
+	mxs_reg_32(hw_bch_dbgcsferead)
+	mxs_reg_32(hw_bch_dbgsyndegread)
+	mxs_reg_32(hw_bch_dbgahbmread)
+	mxs_reg_32(hw_bch_blockname)
+	mxs_reg_32(hw_bch_version)
+};
+#endif
+
+#define	BCH_CTRL_SFTRST					(1 << 31)
+#define	BCH_CTRL_CLKGATE				(1 << 30)
+#define	BCH_CTRL_DEBUGSYNDROME				(1 << 22)
+#define	BCH_CTRL_M2M_LAYOUT_MASK			(0x3 << 18)
+#define	BCH_CTRL_M2M_LAYOUT_OFFSET			18
+#define	BCH_CTRL_M2M_ENCODE				(1 << 17)
+#define	BCH_CTRL_M2M_ENABLE				(1 << 16)
+#define	BCH_CTRL_DEBUG_STALL_IRQ_EN			(1 << 10)
+#define	BCH_CTRL_COMPLETE_IRQ_EN			(1 << 8)
+#define	BCH_CTRL_BM_ERROR_IRQ				(1 << 3)
+#define	BCH_CTRL_DEBUG_STALL_IRQ			(1 << 2)
+#define	BCH_CTRL_COMPLETE_IRQ				(1 << 0)
+
+#define	BCH_STATUS0_HANDLE_MASK				(0xfff << 20)
+#define	BCH_STATUS0_HANDLE_OFFSET			20
+#define	BCH_STATUS0_COMPLETED_CE_MASK			(0xf << 16)
+#define	BCH_STATUS0_COMPLETED_CE_OFFSET			16
+#define	BCH_STATUS0_STATUS_BLK0_MASK			(0xff << 8)
+#define	BCH_STATUS0_STATUS_BLK0_OFFSET			8
+#define	BCH_STATUS0_STATUS_BLK0_ZERO			(0x00 << 8)
+#define	BCH_STATUS0_STATUS_BLK0_ERROR1			(0x01 << 8)
+#define	BCH_STATUS0_STATUS_BLK0_ERROR2			(0x02 << 8)
+#define	BCH_STATUS0_STATUS_BLK0_ERROR3			(0x03 << 8)
+#define	BCH_STATUS0_STATUS_BLK0_ERROR4			(0x04 << 8)
+#define	BCH_STATUS0_STATUS_BLK0_UNCORRECTABLE		(0xfe << 8)
+#define	BCH_STATUS0_STATUS_BLK0_ERASED			(0xff << 8)
+#define	BCH_STATUS0_ALLONES				(1 << 4)
+#define	BCH_STATUS0_CORRECTED				(1 << 3)
+#define	BCH_STATUS0_UNCORRECTABLE			(1 << 2)
+
+#define	BCH_MODE_ERASE_THRESHOLD_MASK			0xff
+#define	BCH_MODE_ERASE_THRESHOLD_OFFSET			0
+
+#define	BCH_ENCODEPTR_ADDR_MASK				0xffffffff
+#define	BCH_ENCODEPTR_ADDR_OFFSET			0
+
+#define	BCH_DATAPTR_ADDR_MASK				0xffffffff
+#define	BCH_DATAPTR_ADDR_OFFSET				0
+
+#define	BCH_METAPTR_ADDR_MASK				0xffffffff
+#define	BCH_METAPTR_ADDR_OFFSET				0
+
+#define	BCH_LAYOUTSELECT_CS15_SELECT_MASK		(0x3 << 30)
+#define	BCH_LAYOUTSELECT_CS15_SELECT_OFFSET		30
+#define	BCH_LAYOUTSELECT_CS14_SELECT_MASK		(0x3 << 28)
+#define	BCH_LAYOUTSELECT_CS14_SELECT_OFFSET		28
+#define	BCH_LAYOUTSELECT_CS13_SELECT_MASK		(0x3 << 26)
+#define	BCH_LAYOUTSELECT_CS13_SELECT_OFFSET		26
+#define	BCH_LAYOUTSELECT_CS12_SELECT_MASK		(0x3 << 24)
+#define	BCH_LAYOUTSELECT_CS12_SELECT_OFFSET		24
+#define	BCH_LAYOUTSELECT_CS11_SELECT_MASK		(0x3 << 22)
+#define	BCH_LAYOUTSELECT_CS11_SELECT_OFFSET		22
+#define	BCH_LAYOUTSELECT_CS10_SELECT_MASK		(0x3 << 20)
+#define	BCH_LAYOUTSELECT_CS10_SELECT_OFFSET		20
+#define	BCH_LAYOUTSELECT_CS9_SELECT_MASK		(0x3 << 18)
+#define	BCH_LAYOUTSELECT_CS9_SELECT_OFFSET		18
+#define	BCH_LAYOUTSELECT_CS8_SELECT_MASK		(0x3 << 16)
+#define	BCH_LAYOUTSELECT_CS8_SELECT_OFFSET		16
+#define	BCH_LAYOUTSELECT_CS7_SELECT_MASK		(0x3 << 14)
+#define	BCH_LAYOUTSELECT_CS7_SELECT_OFFSET		14
+#define	BCH_LAYOUTSELECT_CS6_SELECT_MASK		(0x3 << 12)
+#define	BCH_LAYOUTSELECT_CS6_SELECT_OFFSET		12
+#define	BCH_LAYOUTSELECT_CS5_SELECT_MASK		(0x3 << 10)
+#define	BCH_LAYOUTSELECT_CS5_SELECT_OFFSET		10
+#define	BCH_LAYOUTSELECT_CS4_SELECT_MASK		(0x3 << 8)
+#define	BCH_LAYOUTSELECT_CS4_SELECT_OFFSET		8
+#define	BCH_LAYOUTSELECT_CS3_SELECT_MASK		(0x3 << 6)
+#define	BCH_LAYOUTSELECT_CS3_SELECT_OFFSET		6
+#define	BCH_LAYOUTSELECT_CS2_SELECT_MASK		(0x3 << 4)
+#define	BCH_LAYOUTSELECT_CS2_SELECT_OFFSET		4
+#define	BCH_LAYOUTSELECT_CS1_SELECT_MASK		(0x3 << 2)
+#define	BCH_LAYOUTSELECT_CS1_SELECT_OFFSET		2
+#define	BCH_LAYOUTSELECT_CS0_SELECT_MASK		(0x3 << 0)
+#define	BCH_LAYOUTSELECT_CS0_SELECT_OFFSET		0
+
+#define	BCH_FLASHLAYOUT0_NBLOCKS_MASK			(0xff << 24)
+#define	BCH_FLASHLAYOUT0_NBLOCKS_OFFSET			24
+#define	BCH_FLASHLAYOUT0_META_SIZE_MASK			(0xff << 16)
+#define	BCH_FLASHLAYOUT0_META_SIZE_OFFSET		16
+#if defined(CONFIG_MX6)
+#define	BCH_FLASHLAYOUT0_ECC0_MASK			(0x1f << 11)
+#define	BCH_FLASHLAYOUT0_ECC0_OFFSET			11
+#else
+#define	BCH_FLASHLAYOUT0_ECC0_MASK			(0xf << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_OFFSET			12
+#endif
+#define	BCH_FLASHLAYOUT0_ECC0_NONE			(0x0 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC2			(0x1 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC4			(0x2 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC6			(0x3 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC8			(0x4 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC10			(0x5 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC12			(0x6 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC14			(0x7 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC16			(0x8 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC18			(0x9 << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC20			(0xa << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC22			(0xb << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC24			(0xc << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC26			(0xd << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC28			(0xe << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC30			(0xf << 12)
+#define	BCH_FLASHLAYOUT0_ECC0_ECC32			(0x10 << 12)
+#define	BCH_FLASHLAYOUT0_GF13_0_GF14_1			(1 << 10)
+#define	BCH_FLASHLAYOUT0_DATA0_SIZE_MASK		0xfff
+#define	BCH_FLASHLAYOUT0_DATA0_SIZE_OFFSET		0
+
+#define	BCH_FLASHLAYOUT1_PAGE_SIZE_MASK			(0xffff << 16)
+#define	BCH_FLASHLAYOUT1_PAGE_SIZE_OFFSET		16
+#if defined(CONFIG_MX6)
+#define	BCH_FLASHLAYOUT1_ECCN_MASK			(0x1f << 11)
+#define	BCH_FLASHLAYOUT1_ECCN_OFFSET			11
+#else
+#define	BCH_FLASHLAYOUT1_ECCN_MASK			(0xf << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_OFFSET			12
+#endif
+#define	BCH_FLASHLAYOUT1_ECCN_NONE			(0x0 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC2			(0x1 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC4			(0x2 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC6			(0x3 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC8			(0x4 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC10			(0x5 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC12			(0x6 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC14			(0x7 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC16			(0x8 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC18			(0x9 << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC20			(0xa << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC22			(0xb << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC24			(0xc << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC26			(0xd << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC28			(0xe << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC30			(0xf << 12)
+#define	BCH_FLASHLAYOUT1_ECCN_ECC32			(0x10 << 12)
+#define	BCH_FLASHLAYOUT1_GF13_0_GF14_1			(1 << 10)
+#define	BCH_FLASHLAYOUT1_DATAN_SIZE_MASK		0xfff
+#define	BCH_FLASHLAYOUT1_DATAN_SIZE_OFFSET		0
+
+#define	BCH_DEBUG0_RSVD1_MASK				(0x1f << 27)
+#define	BCH_DEBUG0_RSVD1_OFFSET				27
+#define	BCH_DEBUG0_ROM_BIST_ENABLE			(1 << 26)
+#define	BCH_DEBUG0_ROM_BIST_COMPLETE			(1 << 25)
+#define	BCH_DEBUG0_KES_DEBUG_SYNDROME_SYMBOL_MASK	(0x1ff << 16)
+#define	BCH_DEBUG0_KES_DEBUG_SYNDROME_SYMBOL_OFFSET	16
+#define	BCH_DEBUG0_KES_DEBUG_SYNDROME_SYMBOL_NORMAL	(0x0 << 16)
+#define	BCH_DEBUG0_KES_DEBUG_SYNDROME_SYMBOL_TEST_MODE	(0x1 << 16)
+#define	BCH_DEBUG0_KES_DEBUG_SHIFT_SYND			(1 << 15)
+#define	BCH_DEBUG0_KES_DEBUG_PAYLOAD_FLAG		(1 << 14)
+#define	BCH_DEBUG0_KES_DEBUG_MODE4K			(1 << 13)
+#define	BCH_DEBUG0_KES_DEBUG_KICK			(1 << 12)
+#define	BCH_DEBUG0_KES_STANDALONE			(1 << 11)
+#define	BCH_DEBUG0_KES_DEBUG_STEP			(1 << 10)
+#define	BCH_DEBUG0_KES_DEBUG_STALL			(1 << 9)
+#define	BCH_DEBUG0_BM_KES_TEST_BYPASS			(1 << 8)
+#define	BCH_DEBUG0_RSVD0_MASK				(0x3 << 6)
+#define	BCH_DEBUG0_RSVD0_OFFSET				6
+#define	BCH_DEBUG0_DEBUG_REG_SELECT_MASK		0x3f
+#define	BCH_DEBUG0_DEBUG_REG_SELECT_OFFSET		0
+
+#define	BCH_DBGKESREAD_VALUES_MASK			0xffffffff
+#define	BCH_DBGKESREAD_VALUES_OFFSET			0
+
+#define	BCH_DBGCSFEREAD_VALUES_MASK			0xffffffff
+#define	BCH_DBGCSFEREAD_VALUES_OFFSET			0
+
+#define	BCH_DBGSYNDGENREAD_VALUES_MASK			0xffffffff
+#define	BCH_DBGSYNDGENREAD_VALUES_OFFSET		0
+
+#define	BCH_DBGAHBMREAD_VALUES_MASK			0xffffffff
+#define	BCH_DBGAHBMREAD_VALUES_OFFSET			0
+
+#define	BCH_BLOCKNAME_NAME_MASK				0xffffffff
+#define	BCH_BLOCKNAME_NAME_OFFSET			0
+
+#define	BCH_VERSION_MAJOR_MASK				(0xff << 24)
+#define	BCH_VERSION_MAJOR_OFFSET			24
+#define	BCH_VERSION_MINOR_MASK				(0xff << 16)
+#define	BCH_VERSION_MINOR_OFFSET			16
+#define	BCH_VERSION_STEP_MASK				0xffff
+#define	BCH_VERSION_STEP_OFFSET				0
+
+#endif	/* __MX28_REGS_BCH_H__ */
diff --git a/arch/arm/include/asm/imx-common/regs-common.h b/arch/arm/include/asm/imx-common/regs-common.h
new file mode 100644
index 0000000..bcea419
--- /dev/null
+++ b/arch/arm/include/asm/imx-common/regs-common.h
@@ -0,0 +1,82 @@
+/*
+ * Freescale i.MXS Register Accessors
+ *
+ * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
+ * on behalf of DENX Software Engineering GmbH
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef __MXS_REGS_COMMON_H__
+#define __MXS_REGS_COMMON_H__
+
+/*
+ * The i.MXS has interesting feature when it comes to register access. There
+ * are four kinds of access to one particular register. Those are:
+ *
+ * 1) Common read/write access. To use this mode, just write to the address of
+ *    the register.
+ * 2) Set bits only access. To set bits, write which bits you want to set to the
+ *    address of the register + 0x4.
+ * 3) Clear bits only access. To clear bits, write which bits you want to clear
+ *    to the address of the register + 0x8.
+ * 4) Toggle bits only access. To toggle bits, write which bits you want to
+ *    toggle to the address of the register + 0xc.
+ *
+ * IMPORTANT NOTE: Not all registers support accesses 2-4! Also, not all bits
+ * can be set/cleared by pure write as in access type 1, some need to be
+ * explicitly set/cleared by using access type 2-3.
+ *
+ * The following macros and structures allow the user to either access the
+ * register in all aforementioned modes (by accessing reg_name, reg_name_set,
+ * reg_name_clr, reg_name_tog) or pass the register structure further into
+ * various functions with correct type information (by accessing reg_name_reg).
+ *
+ */
+
+#define	__mxs_reg_8(name)		\
+	uint8_t	name[4];		\
+	uint8_t	name##_set[4];		\
+	uint8_t	name##_clr[4];		\
+	uint8_t	name##_tog[4];		\
+
+#define	__mxs_reg_32(name)		\
+	uint32_t name;			\
+	uint32_t name##_set;		\
+	uint32_t name##_clr;		\
+	uint32_t name##_tog;
+
+struct mxs_register_8 {
+	__mxs_reg_8(reg)
+};
+
+struct mxs_register_32 {
+	__mxs_reg_32(reg)
+};
+
+#define	mxs_reg_8(name)				\
+	union {						\
+		struct { __mxs_reg_8(name) };		\
+		struct mxs_register_8 name##_reg;	\
+	};
+
+#define	mxs_reg_32(name)				\
+	union {						\
+		struct { __mxs_reg_32(name) };		\
+		struct mxs_register_32 name##_reg;	\
+	};
+
+#endif	/* __MXS_REGS_COMMON_H__ */
diff --git a/arch/arm/include/asm/imx-common/regs-gpmi.h b/arch/arm/include/asm/imx-common/regs-gpmi.h
new file mode 100644
index 0000000..3409b94
--- /dev/null
+++ b/arch/arm/include/asm/imx-common/regs-gpmi.h
@@ -0,0 +1,222 @@
+/*
+ * Freescale i.MX28 GPMI Register Definitions
+ *
+ * Copyright (C) 2011 Marek Vasut <marek.vasut@gmail.com>
+ * on behalf of DENX Software Engineering GmbH
+ *
+ * Based on code from LTIB:
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#ifndef __MX28_REGS_GPMI_H__
+#define __MX28_REGS_GPMI_H__
+
+#include <asm/imx-common/regs-common.h>
+
+#ifndef	__ASSEMBLY__
+struct mxs_gpmi_regs {
+	mxs_reg_32(hw_gpmi_ctrl0)
+	mxs_reg_32(hw_gpmi_compare)
+	mxs_reg_32(hw_gpmi_eccctrl)
+	mxs_reg_32(hw_gpmi_ecccount)
+	mxs_reg_32(hw_gpmi_payload)
+	mxs_reg_32(hw_gpmi_auxiliary)
+	mxs_reg_32(hw_gpmi_ctrl1)
+	mxs_reg_32(hw_gpmi_timing0)
+	mxs_reg_32(hw_gpmi_timing1)
+
+	uint32_t	reserved[4];
+
+	mxs_reg_32(hw_gpmi_data)
+	mxs_reg_32(hw_gpmi_stat)
+	mxs_reg_32(hw_gpmi_debug)
+	mxs_reg_32(hw_gpmi_version)
+};
+#endif
+
+#define	GPMI_CTRL0_SFTRST				(1 << 31)
+#define	GPMI_CTRL0_CLKGATE				(1 << 30)
+#define	GPMI_CTRL0_RUN					(1 << 29)
+#define	GPMI_CTRL0_DEV_IRQ_EN				(1 << 28)
+#define	GPMI_CTRL0_LOCK_CS				(1 << 27)
+#define	GPMI_CTRL0_UDMA					(1 << 26)
+#define	GPMI_CTRL0_COMMAND_MODE_MASK			(0x3 << 24)
+#define	GPMI_CTRL0_COMMAND_MODE_OFFSET			24
+#define	GPMI_CTRL0_COMMAND_MODE_WRITE			(0x0 << 24)
+#define	GPMI_CTRL0_COMMAND_MODE_READ			(0x1 << 24)
+#define	GPMI_CTRL0_COMMAND_MODE_READ_AND_COMPARE	(0x2 << 24)
+#define	GPMI_CTRL0_COMMAND_MODE_WAIT_FOR_READY		(0x3 << 24)
+#define	GPMI_CTRL0_WORD_LENGTH				(1 << 23)
+#define	GPMI_CTRL0_CS_MASK				(0x7 << 20)
+#define	GPMI_CTRL0_CS_OFFSET				20
+#define	GPMI_CTRL0_ADDRESS_MASK				(0x7 << 17)
+#define	GPMI_CTRL0_ADDRESS_OFFSET			17
+#define	GPMI_CTRL0_ADDRESS_NAND_DATA			(0x0 << 17)
+#define	GPMI_CTRL0_ADDRESS_NAND_CLE			(0x1 << 17)
+#define	GPMI_CTRL0_ADDRESS_NAND_ALE			(0x2 << 17)
+#define	GPMI_CTRL0_ADDRESS_INCREMENT			(1 << 16)
+#define	GPMI_CTRL0_XFER_COUNT_MASK			0xffff
+#define	GPMI_CTRL0_XFER_COUNT_OFFSET			0
+
+#define	GPMI_COMPARE_MASK_MASK				(0xffff << 16)
+#define	GPMI_COMPARE_MASK_OFFSET			16
+#define	GPMI_COMPARE_REFERENCE_MASK			0xffff
+#define	GPMI_COMPARE_REFERENCE_OFFSET			0
+
+#define	GPMI_ECCCTRL_HANDLE_MASK			(0xffff << 16)
+#define	GPMI_ECCCTRL_HANDLE_OFFSET			16
+#define	GPMI_ECCCTRL_ECC_CMD_MASK			(0x3 << 13)
+#define	GPMI_ECCCTRL_ECC_CMD_OFFSET			13
+#define	GPMI_ECCCTRL_ECC_CMD_DECODE			(0x0 << 13)
+#define	GPMI_ECCCTRL_ECC_CMD_ENCODE			(0x1 << 13)
+#define	GPMI_ECCCTRL_ENABLE_ECC				(1 << 12)
+#define	GPMI_ECCCTRL_BUFFER_MASK_MASK			0x1ff
+#define	GPMI_ECCCTRL_BUFFER_MASK_OFFSET			0
+#define	GPMI_ECCCTRL_BUFFER_MASK_BCH_AUXONLY		0x100
+#define	GPMI_ECCCTRL_BUFFER_MASK_BCH_PAGE		0x1ff
+
+#define	GPMI_ECCCOUNT_COUNT_MASK			0xffff
+#define	GPMI_ECCCOUNT_COUNT_OFFSET			0
+
+#define	GPMI_PAYLOAD_ADDRESS_MASK			(0x3fffffff << 2)
+#define	GPMI_PAYLOAD_ADDRESS_OFFSET			2
+
+#define	GPMI_AUXILIARY_ADDRESS_MASK			(0x3fffffff << 2)
+#define	GPMI_AUXILIARY_ADDRESS_OFFSET			2
+
+#define	GPMI_CTRL1_DECOUPLE_CS				(1 << 24)
+#define	GPMI_CTRL1_WRN_DLY_SEL_MASK			(0x3 << 22)
+#define	GPMI_CTRL1_WRN_DLY_SEL_OFFSET			22
+#define	GPMI_CTRL1_TIMEOUT_IRQ_EN			(1 << 20)
+#define	GPMI_CTRL1_GANGED_RDYBUSY			(1 << 19)
+#define	GPMI_CTRL1_BCH_MODE				(1 << 18)
+#define	GPMI_CTRL1_DLL_ENABLE				(1 << 17)
+#define	GPMI_CTRL1_HALF_PERIOD				(1 << 16)
+#define	GPMI_CTRL1_RDN_DELAY_MASK			(0xf << 12)
+#define	GPMI_CTRL1_RDN_DELAY_OFFSET			12
+#define	GPMI_CTRL1_DMA2ECC_MODE				(1 << 11)
+#define	GPMI_CTRL1_DEV_IRQ				(1 << 10)
+#define	GPMI_CTRL1_TIMEOUT_IRQ				(1 << 9)
+#define	GPMI_CTRL1_BURST_EN				(1 << 8)
+#define	GPMI_CTRL1_ABORT_WAIT_REQUEST			(1 << 7)
+#define	GPMI_CTRL1_ABORT_WAIT_FOR_READY_CHANNEL_MASK	(0x7 << 4)
+#define	GPMI_CTRL1_ABORT_WAIT_FOR_READY_CHANNEL_OFFSET	4
+#define	GPMI_CTRL1_DEV_RESET				(1 << 3)
+#define	GPMI_CTRL1_ATA_IRQRDY_POLARITY			(1 << 2)
+#define	GPMI_CTRL1_CAMERA_MODE				(1 << 1)
+#define	GPMI_CTRL1_GPMI_MODE				(1 << 0)
+
+#define	GPMI_TIMING0_ADDRESS_SETUP_MASK			(0xff << 16)
+#define	GPMI_TIMING0_ADDRESS_SETUP_OFFSET		16
+#define	GPMI_TIMING0_DATA_HOLD_MASK			(0xff << 8)
+#define	GPMI_TIMING0_DATA_HOLD_OFFSET			8
+#define	GPMI_TIMING0_DATA_SETUP_MASK			0xff
+#define	GPMI_TIMING0_DATA_SETUP_OFFSET			0
+
+#define	GPMI_TIMING1_DEVICE_BUSY_TIMEOUT_MASK		(0xffff << 16)
+#define	GPMI_TIMING1_DEVICE_BUSY_TIMEOUT_OFFSET		16
+
+#define	GPMI_TIMING2_UDMA_TRP_MASK			(0xff << 24)
+#define	GPMI_TIMING2_UDMA_TRP_OFFSET			24
+#define	GPMI_TIMING2_UDMA_ENV_MASK			(0xff << 16)
+#define	GPMI_TIMING2_UDMA_ENV_OFFSET			16
+#define	GPMI_TIMING2_UDMA_HOLD_MASK			(0xff << 8)
+#define	GPMI_TIMING2_UDMA_HOLD_OFFSET			8
+#define	GPMI_TIMING2_UDMA_SETUP_MASK			0xff
+#define	GPMI_TIMING2_UDMA_SETUP_OFFSET			0
+
+#define	GPMI_DATA_DATA_MASK				0xffffffff
+#define	GPMI_DATA_DATA_OFFSET				0
+
+#define	GPMI_STAT_READY_BUSY_MASK			(0xff << 24)
+#define	GPMI_STAT_READY_BUSY_OFFSET			24
+#define	GPMI_STAT_RDY_TIMEOUT_MASK			(0xff << 16)
+#define	GPMI_STAT_RDY_TIMEOUT_OFFSET			16
+#define	GPMI_STAT_DEV7_ERROR				(1 << 15)
+#define	GPMI_STAT_DEV6_ERROR				(1 << 14)
+#define	GPMI_STAT_DEV5_ERROR				(1 << 13)
+#define	GPMI_STAT_DEV4_ERROR				(1 << 12)
+#define	GPMI_STAT_DEV3_ERROR				(1 << 11)
+#define	GPMI_STAT_DEV2_ERROR				(1 << 10)
+#define	GPMI_STAT_DEV1_ERROR				(1 << 9)
+#define	GPMI_STAT_DEV0_ERROR				(1 << 8)
+#define	GPMI_STAT_ATA_IRQ				(1 << 4)
+#define	GPMI_STAT_INVALID_BUFFER_MASK			(1 << 3)
+#define	GPMI_STAT_FIFO_EMPTY				(1 << 2)
+#define	GPMI_STAT_FIFO_FULL				(1 << 1)
+#define	GPMI_STAT_PRESENT				(1 << 0)
+
+#define	GPMI_DEBUG_WAIT_FOR_READY_END_MASK		(0xff << 24)
+#define	GPMI_DEBUG_WAIT_FOR_READY_END_OFFSET		24
+#define	GPMI_DEBUG_DMA_SENSE_MASK			(0xff << 16)
+#define	GPMI_DEBUG_DMA_SENSE_OFFSET			16
+#define	GPMI_DEBUG_DMAREQ_MASK				(0xff << 8)
+#define	GPMI_DEBUG_DMAREQ_OFFSET			8
+#define	GPMI_DEBUG_CMD_END_MASK				0xff
+#define	GPMI_DEBUG_CMD_END_OFFSET			0
+
+#define	GPMI_VERSION_MAJOR_MASK				(0xff << 24)
+#define	GPMI_VERSION_MAJOR_OFFSET			24
+#define	GPMI_VERSION_MINOR_MASK				(0xff << 16)
+#define	GPMI_VERSION_MINOR_OFFSET			16
+#define	GPMI_VERSION_STEP_MASK				0xffff
+#define	GPMI_VERSION_STEP_OFFSET			0
+
+#define	GPMI_DEBUG2_UDMA_STATE_MASK			(0xf << 24)
+#define	GPMI_DEBUG2_UDMA_STATE_OFFSET			24
+#define	GPMI_DEBUG2_BUSY				(1 << 23)
+#define	GPMI_DEBUG2_PIN_STATE_MASK			(0x7 << 20)
+#define	GPMI_DEBUG2_PIN_STATE_OFFSET			20
+#define	GPMI_DEBUG2_PIN_STATE_PSM_IDLE			(0x0 << 20)
+#define	GPMI_DEBUG2_PIN_STATE_PSM_BYTCNT		(0x1 << 20)
+#define	GPMI_DEBUG2_PIN_STATE_PSM_ADDR			(0x2 << 20)
+#define	GPMI_DEBUG2_PIN_STATE_PSM_STALL			(0x3 << 20)
+#define	GPMI_DEBUG2_PIN_STATE_PSM_STROBE		(0x4 << 20)
+#define	GPMI_DEBUG2_PIN_STATE_PSM_ATARDY		(0x5 << 20)
+#define	GPMI_DEBUG2_PIN_STATE_PSM_DHOLD			(0x6 << 20)
+#define	GPMI_DEBUG2_PIN_STATE_PSM_DONE			(0x7 << 20)
+#define	GPMI_DEBUG2_MAIN_STATE_MASK			(0xf << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_OFFSET			16
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_IDLE			(0x0 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_BYTCNT		(0x1 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_WAITFE		(0x2 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_WAITFR		(0x3 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_DMAREQ		(0x4 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_DMAACK		(0x5 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_WAITFF		(0x6 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_LDFIFO		(0x7 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_LDDMAR		(0x8 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_RDCMP		(0x9 << 16)
+#define	GPMI_DEBUG2_MAIN_STATE_MSM_DONE			(0xa << 16)
+#define	GPMI_DEBUG2_SYND2GPMI_BE_MASK			(0xf << 12)
+#define	GPMI_DEBUG2_SYND2GPMI_BE_OFFSET			12
+#define	GPMI_DEBUG2_GPMI2SYND_VALID			(1 << 11)
+#define	GPMI_DEBUG2_GPMI2SYND_READY			(1 << 10)
+#define	GPMI_DEBUG2_SYND2GPMI_VALID			(1 << 9)
+#define	GPMI_DEBUG2_SYND2GPMI_READY			(1 << 8)
+#define	GPMI_DEBUG2_VIEW_DELAYED_RDN			(1 << 7)
+#define	GPMI_DEBUG2_UPDATE_WINDOW			(1 << 6)
+#define	GPMI_DEBUG2_RDN_TAP_MASK			0x3f
+#define	GPMI_DEBUG2_RDN_TAP_OFFSET			0
+
+#define	GPMI_DEBUG3_APB_WORD_CNTR_MASK			(0xffff << 16)
+#define	GPMI_DEBUG3_APB_WORD_CNTR_OFFSET		16
+#define	GPMI_DEBUG3_DEV_WORD_CNTR_MASK			0xffff
+#define	GPMI_DEBUG3_DEV_WORD_CNTR_OFFSET		0
+
+#endif	/* __MX28_REGS_GPMI_H__ */
diff --git a/board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg b/board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg
index c86cd40..1b6a7cb 100644
--- a/board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg
+++ b/board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg
@@ -137,20 +137,20 @@ DATA 4 0x021b0020 0x00005800
 DATA 4 0x021b0818 0x00022227
 DATA 4 0x021b4818 0x00022227
 
-DATA 4 0x021b083c 0x434B0350
-DATA 4 0x021b0840 0x034C0359
-DATA 4 0x021b483c 0x434B0350
-DATA 4 0x021b4840 0x03650348
-DATA 4 0x021b0848 0x4436383B
-DATA 4 0x021b4848 0x39393341
-DATA 4 0x021b0850 0x35373933
-DATA 4 0x021b4850 0x48254A36
-
-DATA 4 0x021b080c 0x001F001F
-DATA 4 0x021b0810 0x001F001F
-
-DATA 4 0x021b480c 0x00440044
-DATA 4 0x021b4810 0x00440044
+DATA 4 0x021b083c 0x42720306
+DATA 4 0x021b0840 0x026F0266
+DATA 4 0x021b483c 0x4273030A
+DATA 4 0x021b4840 0x02740240
+DATA 4 0x021b0848 0x45393B3E
+DATA 4 0x021b4848 0x403A3747
+DATA 4 0x021b0850 0x40434541
+DATA 4 0x021b4850 0x473E4A3B
+
+DATA 4 0x021b080c 0x0011000E
+DATA 4 0x021b0810 0x000E001B
+
+DATA 4 0x021b480c 0x00190015
+DATA 4 0x021b4810 0x00070018
 
 DATA 4 0x021b08b8 0x00000800
 DATA 4 0x021b48b8 0x00000800
diff --git a/board/gateworks/gw_ventana/1066mhz_4x128mx16.cfg b/board/gateworks/gw_ventana/1066mhz_4x128mx16.cfg
new file mode 100644
index 0000000..1966d9a
--- /dev/null
+++ b/board/gateworks/gw_ventana/1066mhz_4x128mx16.cfg
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2013 Gateworks Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ */
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00020036
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x555A7974
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xDB538F64
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x005A1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x09444040
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00025576
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000027
+DATA 4, MX6_MMDC_P0_MDCTL, 0x831A0000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04088032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00428031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x19308030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00005800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x42720306
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x026F0266
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x4273030A
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x02740240
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x45393B3E
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x403A3747
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x40434541
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x473E4A3B
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x0011000E
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x000E001B
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x00190015
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x00070018
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff --git a/board/gateworks/gw_ventana/Makefile b/board/gateworks/gw_ventana/Makefile
new file mode 100644
index 0000000..32c4dca
--- /dev/null
+++ b/board/gateworks/gw_ventana/Makefile
@@ -0,0 +1,39 @@
+#
+# (C) Copyright 2013 Gateworks Corporation
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB    = $(obj)lib$(BOARD).o
+
+COBJS  := gw_ventana.o
+
+SRCS   := $(COBJS:.o=.c)
+OBJS   := $(addprefix $(obj),$(COBJS))
+
+$(LIB):        $(obj).depend $(OBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/gateworks/gw_ventana/README b/board/gateworks/gw_ventana/README
new file mode 100644
index 0000000..7e05df2
--- /dev/null
+++ b/board/gateworks/gw_ventana/README
@@ -0,0 +1,72 @@
+U-Boot for the Gateworks Ventana Product Family boards
+
+This file contains information for the port of U-Boot to the Gateworks 
+Ventan Product family boards.
+
+1. Boot source, boot from SD card
+---------------------------------
+
+The recent mainline U-Boot for the Freescale i.MX6q SabreLite board supports
+boot from SD card only. However, by default, the SabreLite
+boards boot from the SPI NOR flash. These boards need to be reflashed with
+a small SD card loader to support boot from SD card. This small SD card loader
+will be flashed into the SPI NOR. The board will still boot from SPI NOR, but
+the loader will in turn request the BootROM to load the U-Boot from SD card.
+
+The SD card loader is available from
+
+https://wiki.linaro.org/Boards/MX6QSabreLite
+
+under a open-source 3-clause BSD license.
+
+To update the SPI-NOR on the SabreLite board without the Freescale
+manufacturing tool use the following procedure:
+
+1. Write this SD card loader onto a large SD card using:
+
+ sudo dd if=iMX6DQ_SPI_to_uSDHC3.bin of=/dev/sXx
+
+Note: Replace sXx with the device representing the SD card in your system.
+
+Note: This writes SD card loader at address 0
+
+2. Put this SD card into the slot for the large SD card (SD3 on the bottom of
+the board). Make sure SW1 switch is at position "00", so that it can boot
+from the fuses.
+
+3. Power-up the SabreLite, press 'space' to enter command mode in the U-Boot
+(the default one the board is shipped with, starting from the SPI NOR) and
+enter the following commands:
+
+ MX6Q SABRELITE U-Boot > mmc dev 0
+ MX6Q SABRELITE U-Boot > mmc read 0x10800000 0 200
+ MX6Q SABRELITE U-Boot > sf probe 1
+ MX6Q SABRELITE U-Boot > sf erase 0 0x40000
+ MX6Q SABRELITE U-Boot > sf write 0x10800000 0 0x40000
+
+4. done.
+
+In case you somehow do not succeed with this procedure you will have to use
+the Freescale manufacturing tool in order to reflash the SPI-NOR.
+
+Note: The board now boots from full size SD3 on the bottom of the board. NOT
+      the micro SD4/BOOT slot on the top of the board. I.e. you have to use
+      full size SD cards.
+
+This information is taken from
+
+https://wiki.linaro.org/Boards/MX6QSabreLite
+
+2. Build
+--------
+
+To build U-Boot for the SabreLite board:
+
+ make gw_ventana_config
+ make u-boot.imx
+
+To copy the resulting u-boot.imx to the SD card:
+
+ sudo dd if=u-boot.imx of=/dev/sXx bs=512 seek=2&&sudo sync
+
+Note: Replace sXx with the device representing the SD card in your system.
diff --git a/board/gateworks/gw_ventana/clocks.cfg b/board/gateworks/gw_ventana/clocks.cfg
new file mode 100644
index 0000000..4d6f4a3
--- /dev/null
+++ b/board/gateworks/gw_ventana/clocks.cfg
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2013 Gateworks Corporation 
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+
+/* set the default clock gate to save power */
+DATA 4, CCM_CCGR0, 0x00C03F3F
+DATA 4, CCM_CCGR1, 0x0030FC03
+DATA 4, CCM_CCGR2, 0x0FFFC000
+DATA 4, CCM_CCGR3, 0x3FF00000
+DATA 4, CCM_CCGR4, 0xFFFFF300 /* enable NAND/GPMI/BCH clocks */
+DATA 4, CCM_CCGR5, 0x0F0000C3
+DATA 4, CCM_CCGR6, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, MX6_IOMUXC_GPR4, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, MX6_IOMUXC_GPR6, 0x007F007F
+DATA 4, MX6_IOMUXC_GPR7, 0x007F007F
diff --git a/board/gateworks/gw_ventana/ddr-setup.cfg b/board/gateworks/gw_ventana/ddr-setup.cfg
new file mode 100644
index 0000000..7346bf2
--- /dev/null
+++ b/board/gateworks/gw_ventana/ddr-setup.cfg
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2013 Gateworks Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+
+/*
+ * DDR3 settings
+ * MX6Q    ddr is limited to 1066 Mhz	currently 1056 MHz(528 MHz clock),
+ *	   memory bus width: 64 bits	x16/x32/x64
+ * MX6DL   ddr is limited to 800 MHz(400 MHz clock)
+ *	   memory bus width: 64 bits	x16/x32/x64
+ * MX6SOLO ddr is limited to 800 MHz(400 MHz clock)
+ *	   memory bus width: 32 bits	x16/x32
+ */
+DATA 4, MX6_IOM_DRAM_SDQS0, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS1, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS2, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS3, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS4, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS5, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS6, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS7, 0x00000030
+
+DATA 4, MX6_IOM_GRP_B0DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B1DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B2DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B3DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B4DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B5DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B6DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B7DS, 0x00000030
+DATA 4, MX6_IOM_GRP_ADDDS, 0x00000030
+/* 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe */
+DATA 4, MX6_IOM_GRP_CTLDS, 0x00000030
+
+DATA 4, MX6_IOM_DRAM_DQM0, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM1, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM2, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM3, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM4, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM5, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM6, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM7, 0x00020030
+
+DATA 4, MX6_IOM_DRAM_CAS, 0x00020030
+DATA 4, MX6_IOM_DRAM_RAS, 0x00020030
+DATA 4, MX6_IOM_DRAM_SDCLK_0, 0x00020030
+DATA 4, MX6_IOM_DRAM_SDCLK_1, 0x00020030
+
+DATA 4, MX6_IOM_DRAM_RESET, 0x000e0030
+DATA 4, MX6_IOM_DRAM_SDCKE0, 0x00003000
+DATA 4, MX6_IOM_DRAM_SDCKE1, 0x00003000
+
+DATA 4, MX6_IOM_DRAM_SDODT0, 0x00003030
+DATA 4, MX6_IOM_DRAM_SDODT1, 0x00003030
+
+/* (differential input) */
+DATA 4, MX6_IOM_DDRMODE_CTL, 0x00020000
+/* (differential input) */
+DATA 4, MX6_IOM_GRP_DDRMODE, 0x00020000
+/* disable ddr pullups */
+DATA 4, MX6_IOM_GRP_DDRPKE, 0x00000000
+DATA 4, MX6_IOM_DRAM_SDBA2, 0x00000000
+/* 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe */
+DATA 4, MX6_IOM_GRP_DDR_TYPE, 0x000C0000
+
+/* Read data DQ Byte0-3 delay */
+DATA 4, MX6_MMDC_P0_MPRDDQBY0DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY1DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY2DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY3DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY0DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY1DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY2DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY3DL, 0x33333333
+
+/*
+ * MDMISC	mirroring	interleaved (row/bank/col)
+ */
+DATA 4, MX6_MMDC_P0_MDMISC, 0x00081740
+
+/*
+ * MDSCR	con_req
+ */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
diff --git a/board/gateworks/gw_ventana/gw_ventana.c b/board/gateworks/gw_ventana/gw_ventana.c
new file mode 100644
index 0000000..dd337b4
--- /dev/null
+++ b/board/gateworks/gw_ventana/gw_ventana.c
@@ -0,0 +1,1563 @@
+/*
+ * Copyright (C) 2013 Gateworks Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6x_pins.h>
+#include <asm/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/imx_pwm.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/sys_proto.h>
+#include <linux/list.h>
+#include <linux/ctype.h>
+#include <linux/fb.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <micrel.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <ipu_pixfmt.h>
+#include <i2c.h>
+#include <fdt_support.h>
+#include <jffs2/load_kernel.h>
+#include <mtd_node.h>
+#include <spi_flash.h>
+#include <hwconfig.h>
+
+#include "ventana_eeprom.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |	       \
+       PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |	       \
+       PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |	       \
+       PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |	       \
+       PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED	  |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+/* UART1, RS485 */
+iomux_v3_cfg_t const uart1_pads[] = {
+	MX6Q_PAD_SD3_DAT6__UART1_RXD | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6Q_PAD_SD3_DAT7__UART1_TXD | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+/* UART2, Console */
+iomux_v3_cfg_t const uart2_pads[] = {
+       MX6Q_PAD_SD4_DAT7__UART2_TXD | MUX_PAD_CTRL(UART_PAD_CTRL),
+       MX6Q_PAD_SD4_DAT4__UART2_RXD | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+#if 0 // depends on GW5400A vs GW5400B
+/* UART3, GPS */
+iomux_v3_cfg_t const uart3_pads[] = {
+       MX6Q_PAD_SD4_CMD__UART3_TXD | MUX_PAD_CTRL(UART_PAD_CTRL),
+       MX6Q_PAD_SD4_CLK__UART3_RXD | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+#endif
+
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+
+/* I2C1, GSC */
+struct i2c_pads_info i2c_pad_info0 = {
+	.scl = {
+		.i2c_mode = MX6Q_PAD_EIM_D21__I2C1_SCL | PC,
+		.gpio_mode = MX6Q_PAD_EIM_D21__GPIO_3_21 | PC,
+		.gp = IMX_GPIO_NR(3, 21)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_EIM_D28__I2C1_SDA | PC,
+		.gpio_mode = MX6Q_PAD_EIM_D28__GPIO_3_28 | PC,
+		.gp = IMX_GPIO_NR(3, 28)
+	}
+};
+
+/* I2C2, PFUSE, PCIe Switch/Clock/Mezz */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6Q_PAD_KEY_COL3__I2C2_SCL | PC,
+		.gpio_mode = MX6Q_PAD_KEY_COL3__GPIO_4_12 | PC,
+		.gp = IMX_GPIO_NR(4, 12)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_KEY_ROW3__I2C2_SDA | PC,
+		.gpio_mode = MX6Q_PAD_KEY_ROW3__GPIO_4_13 | PC,
+		.gp = IMX_GPIO_NR(4, 13)
+	}
+};
+
+/* I2C3, Accel, Audio Codec, Video Decoder, Video Encoder, MIPI, LVDS, DIO */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6Q_PAD_GPIO_3__I2C3_SCL | PC,
+		.gpio_mode = MX6Q_PAD_GPIO_3__GPIO_1_3 | PC,
+		.gp = IMX_GPIO_NR(1, 3)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_GPIO_6__I2C3_SDA | PC,
+		.gpio_mode = MX6Q_PAD_GPIO_6__GPIO_1_6 | PC,
+		.gp = IMX_GPIO_NR(1, 6)
+	}
+};
+
+/* MMC */
+iomux_v3_cfg_t const usdhc3_pads[] = {
+       MX6Q_PAD_SD3_CLK__USDHC3_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+       MX6Q_PAD_SD3_CMD__USDHC3_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+       MX6Q_PAD_SD3_DAT0__USDHC3_DAT0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+       MX6Q_PAD_SD3_DAT1__USDHC3_DAT1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+       MX6Q_PAD_SD3_DAT2__USDHC3_DAT2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+       MX6Q_PAD_SD3_DAT3__USDHC3_DAT3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+       MX6Q_PAD_SD3_DAT5__GPIO_7_0    | MUX_PAD_CTRL(NO_PAD_CTRL), /* CD */
+};
+
+/* ENET */
+iomux_v3_cfg_t const enet_pads[] = {
+	MX6Q_PAD_ENET_MDIO__ENET_MDIO		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_ENET_MDC__ENET_MDC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_TXC__ENET_RGMII_TXC	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_TD0__ENET_RGMII_TD0	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_TD1__ENET_RGMII_TD1	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_TD2__ENET_RGMII_TD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_TD3__ENET_RGMII_TD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_TX_CTL__RGMII_TX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_ENET_REF_CLK__ENET_TX_CLK	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_RXC__ENET_RGMII_RXC	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_RD0__ENET_RGMII_RD0	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_RD1__ENET_RGMII_RD1	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_RD2__ENET_RGMII_RD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_RD3__ENET_RGMII_RD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_ENET_TXD0__GPIO_1_30 | MUX_PAD_CTRL(NO_PAD_CTRL), /* PHY nRST */
+};
+
+/* NAND */
+iomux_v3_cfg_t const nfc_pads[] = {
+	MX6Q_PAD_NANDF_CLE__RAWNAND_CLE     | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6Q_PAD_NANDF_ALE__RAWNAND_ALE     | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6Q_PAD_NANDF_WP_B__RAWNAND_RESETN | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6Q_PAD_NANDF_RB0__RAWNAND_READY0  | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6Q_PAD_NANDF_CS0__RAWNAND_CE0N    | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6Q_PAD_SD4_CMD__RAWNAND_RDN       | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6Q_PAD_SD4_CLK__RAWNAND_WRN       | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6Q_PAD_NANDF_D0__RAWNAND_D0       | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6Q_PAD_NANDF_D1__RAWNAND_D1       | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6Q_PAD_NANDF_D2__RAWNAND_D2       | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6Q_PAD_NANDF_D3__RAWNAND_D3       | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6Q_PAD_NANDF_D4__RAWNAND_D4       | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6Q_PAD_NANDF_D5__RAWNAND_D5       | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6Q_PAD_NANDF_D6__RAWNAND_D6       | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6Q_PAD_NANDF_D7__RAWNAND_D7       | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+#ifdef CONFIG_CMD_NAND
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(nfc_pads,
+		ARRAY_SIZE(nfc_pads));
+
+	/* config gpmi and bch clock to 100 MHz */
+	clrsetbits_le32(&mxc_ccm->cs2cdr,
+		MXC_CCM_CS2CDR_ENFC_CLK_PODF_MASK |
+		MXC_CCM_CS2CDR_ENFC_CLK_PRED_MASK |
+		MXC_CCM_CS2CDR_ENFC_CLK_SEL_MASK,
+		MXC_CCM_CS2CDR_ENFC_CLK_PODF(0) |
+		MXC_CCM_CS2CDR_ENFC_CLK_PRED(3) |
+		MXC_CCM_CS2CDR_ENFC_CLK_SEL(3));
+
+	/* enable gpmi and bch clock gating */
+	setbits_le32(&mxc_ccm->CCGR4,
+		MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
+		MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
+		MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
+		MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
+		MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_OFFSET);
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+static void setup_iomux_enet(void)
+{
+	imx_iomux_v3_setup_multiple_pads(enet_pads, ARRAY_SIZE(enet_pads));
+
+	/* toggle PHY_RST# */
+	gpio_direction_output(IMX_GPIO_NR(1, 30), 0);
+	mdelay(2);
+	gpio_set_value(IMX_GPIO_NR(1, 30), 1);
+}
+
+iomux_v3_cfg_t const usb_pads[] = {
+	/* HUB reset */
+	MX6Q_PAD_SD1_DAT0__GPIO_1_16 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* USBOTG_PWR enable */
+	MX6Q_PAD_EIM_D22__USBOH3_USBOTG_PWR,
+};
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+	imx_iomux_v3_setup_multiple_pads(uart2_pads, ARRAY_SIZE(uart2_pads));
+#if 0 // depends on GW5400A vs GW5400B
+	imx_iomux_v3_setup_multiple_pads(uart3_pads, ARRAY_SIZE(uart3_pads));
+#endif
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_pads, ARRAY_SIZE(usb_pads));
+
+	/* Reset USB hub */
+	gpio_direction_output(IMX_GPIO_NR(1, 16), 0);
+	mdelay(2);
+	gpio_set_value(IMX_GPIO_NR(1, 16), 1);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg usdhc_cfg[1] = {
+       {USDHC3_BASE_ADDR},
+};
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	if (cfg->esdhc_base == USDHC3_BASE_ADDR) {
+		/* Card Detect */
+		gpio_direction_input(IMX_GPIO_NR(7, 0));
+		ret = !gpio_get_value(IMX_GPIO_NR(7, 0));
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	s32 status = 0;
+	u32 index = 0;
+
+	usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+
+	for (index = 0; index < CONFIG_SYS_FSL_USDHC_NUM; ++index) {
+		switch (index) {
+			case 0:
+				imx_iomux_v3_setup_multiple_pads(
+					usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+				break;
+			default:
+				printf("Warning: you configured more USDHC controllers"
+					"(%d) then supported by the board (%d)\n",
+					index + 1, CONFIG_SYS_FSL_USDHC_NUM);
+				return status;
+		}
+
+		status |= fsl_esdhc_initialize(bis, &usdhc_cfg[index]);
+	}
+
+	return status;
+}
+#endif
+
+/* Gateworks System Controller I2C access may NAK when busy - use
+ * retries.
+ */
+int gsc_i2c_read(uchar chip, uint addr, int alen, uchar *buf, int len)
+{
+	int retry = 3;
+	int n = 0;
+	int ret;
+
+	while (n++ < retry) {
+		ret = i2c_read(chip, addr, alen, buf, len);
+		if (!ret)
+			break;
+		printf("%s: 0x%02x 0x%02x retry%d: %d\n", __func__, chip, addr, n, ret);
+		if (ret != -ENODEV)
+			break;
+		mdelay(10);
+	}
+	return ret;
+}
+
+int gsc_i2c_write(uchar chip, uint addr, int alen, uchar *buf, int len)
+{
+	int retry = 3;
+	int n = 0;
+	int ret;
+
+	while (n++ < retry) {
+		ret = i2c_write(chip, addr, alen, buf, len);
+		if (!ret)
+			break;
+		printf("%s: 0x%02x 0x%02x retry%d: %d\n", __func__, chip, addr, n, ret);
+		if (ret != -ENODEV)
+			break;
+		mdelay(10);
+	}
+	mdelay(1);
+	return ret;
+}
+
+/*
+ * For SPL boot some boards need i2c before SDRAM is initialized so force
+ * variables to live in SRAM
+ */
+static struct ventana_board_info __attribute__((section(".data"))) ventana_info;
+
+/* read ventana EEPROM and return structure or NULL on error
+ * should be called once, the first time eeprom data is needed
+ */
+static void
+read_eeprom(void)
+{
+	int i;
+	int chksum;
+	struct ventana_board_info *info = &ventana_info;
+	unsigned char *buf = (unsigned char *) &ventana_info;
+	int n = 0;
+
+	memset(info, 0, sizeof(ventana_info));
+
+	// wait for bus and device exist - we will not boot w/o our EEPROM
+	while(1) {
+		if (0 == i2c_set_bus_num(0) && 0 == i2c_probe(0x51))
+			break;
+		mdelay(1);
+		n++;
+/*
+		if (n > 2000) {
+			printf("EEPROM: Failed to probe EEPROM\n");
+			info->model[0] = 0;
+			return;
+		}
+*/
+	}
+
+	// read eeprom config section
+	if (gsc_i2c_read(0x51, 0x00, 1, buf, sizeof(ventana_info))) {
+		printf("EEPROM: Failed to read EEPROM\n");
+		info->model[0] = 0;
+		return;
+	}
+
+	// sanity checks
+	if (info->model[0] != 'G' || info->model[1] != 'W') {
+		printf("EEPROM: Invalid Model in EEPROM\n");
+		info->model[0] = 0;
+		return;
+	}
+
+	// validate checksum
+	for (chksum = 0, i = 0; i < sizeof(*info)-2; i++)
+		chksum += buf[i];
+	if ((info->chksum[0] != chksum>>8) || (info->chksum[1] != (chksum&0xff))) {
+		printf("EEPROM: Failed EEPROM checksum\n");
+		info->model[0] = 0;
+		return;
+	}
+}
+
+#ifdef CONFIG_CMD_GSC
+int read_hwmon(const char *name, uint reg, uint size, uint low, uint high)
+{
+	unsigned char buf[3];
+	uint ui;
+	int ret;
+
+	printf("%-8s:", name);
+	memset(buf, 0, sizeof(buf));
+	if (gsc_i2c_read(0x29, reg, 1, buf, size)) {
+		printf("fRD\n");
+		ret = -1;
+	} else {
+		ret = 0;
+		ui = buf[0] | (buf[1]<<8) | (buf[2]<<16);
+		if (ui == 0xffffff)
+			printf("fVL");
+		else if (ui < low) {
+			printf("%d fLO", ui);
+			ret = -2;
+		}
+		else if (ui > high) {
+			printf("%d fHI", ui);
+			ret = -3;
+		}
+		else
+			printf("%d", ui);
+	}
+	printf("\n");
+
+	return ret;
+}
+
+int do_gsc(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	i2c_set_bus_num(0);
+	read_hwmon("Temp",     0x00, 2, 0, 9000);
+	read_hwmon("VIN",      0x02, 3, 8000, 60000);
+	read_hwmon("VDD_3P3",  0x05, 3, 3300*0.9, 3300*1.1);
+	read_hwmon("VBATT",    0x08, 3, 2000*0.9, 3000*1.1);
+	read_hwmon("VDD_CORE", 0x0e, 3, 1375*0.9, 1375*1.1);
+	read_hwmon("VDD_SOC",  0x11, 3, 1375*0.9, 1375*1.1);
+	read_hwmon("VDD_HIGH", 0x14, 3, 3000*0.9, 3000*1.1);
+	read_hwmon("VDD_DDR",  0x17, 3, 1500*0.9, 1500*1.1);
+	read_hwmon("VDD_5P0",  0x0b, 3, 5000*0.9, 5000*1.1);
+	read_hwmon("VDD_2P5",  0x23, 3, 2500*0.9, 2500*1.1);
+	read_hwmon("VDD_1P8",  0x1d, 3, 1800*0.9, 1800*1.1);
+	read_hwmon("VDD_1P0",  0x20, 3, 1000*0.9, 1000*1.1);
+
+	return 0;
+}
+
+U_BOOT_CMD(gsc, 1, 1, do_gsc,
+  "GSC test",
+  ""
+);
+#endif // CONFIG_CMD_GSC
+
+
+/* get_mac from env string, with default
+ */
+static void get_mac(char *envvar, unsigned char *def)
+{
+	char str[20];
+	char *env = getenv(envvar);
+
+	if (!env) {
+		sprintf(str, "%02X:%02X:%02X:%02X:%02X:%02X",
+			def[0], def[1], def[2], def[3], def[4], def[5]);
+		setenv(envvar, str);
+	}
+}
+
+
+/* this is passed in as ATAG_REVISION which is reported from linux
+ * /proc/cpuinfo 'Revision' field (see arch/arm/kernel/setup.c)
+ *
+ * the value 0x63000 is needed for imx-lib/vpu_lib.h cpu_is_mx6q function
+ * to return true to setup proper firmware filename for loading binary firmware
+ * 0x61xxx is imx6dl
+ * 0x63xxx is imx6q
+ */
+u32 get_board_rev(void)
+{
+	return 0x63000;
+}
+
+#ifdef CONFIG_SERIAL_TAG
+/* called when setting up ATAGS before booting kernel
+ * populate serialnum from the following (in order of priority):
+ *   serial# env var
+ *   eeprom
+ */
+void get_board_serial(struct tag_serialnr *serialnr)
+{
+  char *serial = getenv("serial#");
+
+  if (serial) {
+    serialnr->high = 0;
+    serialnr->low = simple_strtoul(serial, NULL, 10);
+  } else if (ventana_info.model[0]) {
+    serialnr->high = 0;
+		serialnr->low = ventana_info.serial;
+	} else {
+    serialnr->high = 0;
+    serialnr->low = 0;
+  }
+}
+#endif
+
+#ifdef CONFIG_MXC_SPI
+iomux_v3_cfg_t const ecspi1_pads[] = {
+	/* SS1 */
+	MX6Q_PAD_EIM_D19__GPIO_3_19   | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6Q_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6Q_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6Q_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+};
+
+static void setup_spi(void)
+{
+	gpio_direction_output(CONFIG_SF_DEFAULT_CS, 1);
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads,
+					 ARRAY_SIZE(ecspi1_pads));
+}
+#endif
+
+int board_phy_config(struct phy_device *phydev)
+{
+	unsigned short val;
+
+	/* Marvel 88E1510 */
+	if (phydev->phy_id == 0x1410dd1) {
+		/* Errata 3.1 - PHY initialization */
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 0x00ff);
+		phy_write(phydev, MDIO_DEVAD_NONE, 17, 0x214b);
+		phy_write(phydev, MDIO_DEVAD_NONE, 16, 0x2144);
+		phy_write(phydev, MDIO_DEVAD_NONE, 17, 0x0c28);
+		phy_write(phydev, MDIO_DEVAD_NONE, 16, 0x2146);
+		phy_write(phydev, MDIO_DEVAD_NONE, 17, 0xb233);
+		phy_write(phydev, MDIO_DEVAD_NONE, 16, 0x214d);
+		phy_write(phydev, MDIO_DEVAD_NONE, 17, 0xcc0c);
+		phy_write(phydev, MDIO_DEVAD_NONE, 16, 0x2159);
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 0x00fb);
+		phy_write(phydev, MDIO_DEVAD_NONE,  7, 0xc00d);
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 0);
+
+		/* LED configuration (See datasheet section 2.26.4)
+		 * LED[0] (SPD:Amber) R16_3.3:0 to 0111: on-GbE link
+		 * LED[1] (LNK:Green) R16_3.7:4 to 0001: on-link, blink-activity
+		 */
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 3);
+		val = phy_read(phydev, MDIO_DEVAD_NONE, 16);
+		val &= 0xff00;
+		val |= 0x0017;
+		phy_write(phydev, MDIO_DEVAD_NONE, 16, val);
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 0);
+
+#if 0 // untested
+		/* Errata 4.4: improving link times with non IEEE compliant link partners */
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 0x00fc);
+		val = phy_read(phydev, MDIO_DEVAD_NONE, 1);
+		val |= 1<<15;
+		phy_write(phydev, MDIO_DEVAD_NONE, 1, val);
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 0);
+#endif
+
+#if 0 // do not seem to need this on gw5400
+		/* introduce tx/rx clock delay */
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 2);
+		val = phy_read(phydev, MDIO_DEVAD_NONE, 21);
+		val &= ~(1<<4); /* tx clock delay */
+		val &= ~(1<<5); /* rx clock delay */
+		phy_write(phydev, MDIO_DEVAD_NONE, 21, val);
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 0);
+#endif
+
+#if 0 // only needed if making changes above which require reset
+		/* soft reset PHY */
+		val = phy_read(phydev, MDIO_DEVAD_NONE, 0);
+		val |= (1<<15);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0, val);
+#endif
+	}
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_enet();
+
+	ret = cpu_eth_init(bis);
+	if (ret)
+		printf("FEC MXC: %s:failed\n", __func__);
+
+	return 0;
+}
+
+static void setup_board_gpio(const char* model)
+{
+	if (strncmp(model, "GW54", 4) == 0) {
+		if (strncmp(model, "GW5400-A", 8) == 0) {
+			// PANLEDG#
+			imx_iomux_v3_setup_pad(MX6Q_PAD_KEY_COL0__GPIO_4_6);
+			gpio_direction_output(IMX_GPIO_NR(4, 6), 1);  // grn off
+
+			// PANLEDR#
+			imx_iomux_v3_setup_pad(MX6Q_PAD_KEY_COL2__GPIO_4_10);
+			gpio_direction_output(IMX_GPIO_NR(4, 10), 1); // red off
+
+			// MX6_LOCLED#
+			imx_iomux_v3_setup_pad(MX6Q_PAD_KEY_ROW4__GPIO_4_15);
+			gpio_direction_output(IMX_GPIO_NR(4, 15), 1); // loc off
+
+			// MIPI DIO
+			imx_iomux_v3_setup_pad(MX6Q_PAD_SD1_DAT3__GPIO_1_21);
+
+			// UART1 Transmit Enable
+			imx_iomux_v3_setup_pad(MX6Q_PAD_EIM_D24__GPIO_3_24);
+
+			// Expansion IO0 - PWREN#
+			imx_iomux_v3_setup_pad(MX6Q_PAD_KEY_ROW0__GPIO_4_7);
+			gpio_direction_output(IMX_GPIO_NR(4, 7), 0);
+
+			// Expansion IO1 - IRQ#
+			imx_iomux_v3_setup_pad(MX6Q_PAD_KEY_ROW1__GPIO_4_9);
+			gpio_direction_input(IMX_GPIO_NR(4, 9));
+		}
+
+		else if ( (strncmp(model, "GW5400", 6) == 0)
+		       || (strncmp(model, "GW5410", 6) == 0)
+		) {
+			// PANLEDG#
+			imx_iomux_v3_setup_pad(MX6Q_PAD_KEY_COL0__GPIO_4_6);
+			gpio_direction_output(IMX_GPIO_NR(4, 6), 1);  // grn off
+
+			// PANLEDR#
+			imx_iomux_v3_setup_pad(MX6Q_PAD_KEY_ROW0__GPIO_4_7);
+			gpio_direction_output(IMX_GPIO_NR(4, 7), 1);  // grn off
+
+			// MX6_LOCLED#
+			imx_iomux_v3_setup_pad(MX6Q_PAD_KEY_ROW4__GPIO_4_15);
+			gpio_direction_output(IMX_GPIO_NR(4, 15), 1);  // grn off
+
+			// UART1 Transmit Enable
+			imx_iomux_v3_setup_pad(MX6Q_PAD_SD3_DAT4__GPIO_7_1);
+
+			// Expansion IO0 - PWREN#
+			imx_iomux_v3_setup_pad(MX6Q_PAD_EIM_A19__GPIO_2_19);
+			gpio_direction_output(IMX_GPIO_NR(2, 19), 0);
+
+			// Expansion IO1 - IRQ#
+			imx_iomux_v3_setup_pad(MX6Q_PAD_EIM_A20__GPIO_2_18);
+			gpio_direction_input(IMX_GPIO_NR(2, 18));
+
+			// MSATA Enable
+			imx_iomux_v3_setup_pad(MX6Q_PAD_SD4_DAT0__GPIO_2_8);
+			gpio_direction_output(IMX_GPIO_NR(2, 8), (hwconfig("msata"))?1:0);
+			printf("MSATA: %s\n", (hwconfig("msata")?"enabled":"disabled"));
+		}
+
+		// UART2_EN#
+		imx_iomux_v3_setup_pad(MX6Q_PAD_SD4_DAT3__GPIO_2_11);
+		printf("RS232: %s\n", (hwconfig("rs232"))?"enabled":"disabled");
+		gpio_direction_output(IMX_GPIO_NR(2, 11), (hwconfig("rs232"))?1:0);
+
+		// DIOI2C_DIS#
+		imx_iomux_v3_setup_pad(MX6Q_PAD_GPIO_19__GPIO_4_5);
+		gpio_direction_output(IMX_GPIO_NR(4,  5), 0);
+
+		/* configure board general purpose IO's based on hwconfig
+		 */
+		// MX6_DIO0
+		if (hwconfig("dio0")) {
+			if (hwconfig_subarg_cmp("dio0", "mode", "gpio")) {
+				printf("DIO0:  gpio\n");
+				imx_iomux_v3_setup_pad(MX6Q_PAD_GPIO_9__GPIO_1_9);
+				gpio_direction_input(IMX_GPIO_NR(1, 9));
+			} else if (hwconfig_subarg_cmp("dio0", "mode", "pwm")) {
+				printf("DIO0:  pwm\n");
+				imx_iomux_v3_setup_pad(MX6Q_PAD_GPIO_9__PWM1_PWMO);
+			}
+		}
+		// MX6_DIO1
+		if (hwconfig("dio1")) {
+			if (hwconfig_subarg_cmp("dio1", "mode", "gpio")) {
+				printf("DIO1:  gpio\n");
+				imx_iomux_v3_setup_pad(MX6Q_PAD_SD1_DAT2__GPIO_1_19);
+				gpio_direction_input(IMX_GPIO_NR(1, 19));
+			} else if (hwconfig_subarg_cmp("dio1", "mode", "pwm")) {
+				printf("DIO1:  pwm\n");
+				imx_iomux_v3_setup_pad(MX6Q_PAD_SD1_DAT2__PWM2_PWMO);
+			}
+		}
+		// MX6_DIO2
+		if (hwconfig("dio2")) {
+			if (hwconfig_subarg_cmp("dio2", "mode", "gpio")) {
+				printf("DIO2:  gpio\n");
+				imx_iomux_v3_setup_pad(MX6Q_PAD_SD4_DAT1__GPIO_2_9);
+				gpio_direction_input(IMX_GPIO_NR(2, 9));
+			} else if (hwconfig_subarg_cmp("dio2", "mode", "pwm")) {
+				printf("DIO2:  pwm\n");
+				imx_iomux_v3_setup_pad(MX6Q_PAD_SD4_DAT1__PWM3_PWMO);
+			}
+		}
+		// MX6_DIO3
+		if (hwconfig("dio3")) {
+			if (hwconfig_subarg_cmp("dio3", "mode", "gpio")) {
+				printf("DIO3:  gpio\n");
+				imx_iomux_v3_setup_pad(MX6Q_PAD_SD4_DAT2__GPIO_2_10);
+				gpio_direction_input(IMX_GPIO_NR(2, 10));
+			} else if (hwconfig_subarg_cmp("dio3", "mode", "pwm")) {
+				printf("DIO3:  pwm\n");
+				imx_iomux_v3_setup_pad(MX6Q_PAD_SD4_DAT2__PWM4_PWMO);
+			}
+		}
+	}
+}
+
+static int setup_pcie(void)
+{
+	/* disable spread-spectrum clock: kernel hang when enabled - not clear why */
+	imx_iomux_v3_setup_pad(MX6Q_PAD_SD1_CLK__GPIO_1_20 | MUX_PAD_CTRL(NO_PAD_CTRL));
+	gpio_direction_output(IMX_GPIO_NR(1, 20), 0); // PCIECK_SSON
+
+	/* toggle PCI_RST# */
+	imx_iomux_v3_setup_pad(MX6Q_PAD_ENET_TXD1__GPIO_1_29 | MUX_PAD_CTRL(NO_PAD_CTRL));
+	gpio_direction_output(IMX_GPIO_NR(1, 29), 0); // PCIESWT_RST#
+	mdelay(1);
+	gpio_direction_output(IMX_GPIO_NR(1, 29), 1); // PCIESWT_RST#
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_SATA
+static int setup_sata(void)
+{
+	struct iomuxc_base_regs *const iomuxc_regs
+		= (struct iomuxc_base_regs *) IOMUXC_BASE_ADDR;
+	int ret = enable_sata_clock();
+	if (ret)
+		return ret;
+
+	clrsetbits_le32(&iomuxc_regs->gpr[13],
+			IOMUXC_GPR13_SATA_MASK,
+			IOMUXC_GPR13_SATA_PHY_8_RXEQ_3P0DB
+			|IOMUXC_GPR13_SATA_PHY_7_SATA2M
+			|IOMUXC_GPR13_SATA_SPEED_3G
+			|(3<<IOMUXC_GPR13_SATA_PHY_6_SHIFT)
+			|IOMUXC_GPR13_SATA_SATA_PHY_5_SS_DISABLED
+			|IOMUXC_GPR13_SATA_SATA_PHY_4_ATTEN_9_16
+			|IOMUXC_GPR13_SATA_PHY_3_TXBOOST_0P00_DB
+			|IOMUXC_GPR13_SATA_PHY_2_TX_1P104V
+			|IOMUXC_GPR13_SATA_PHY_1_SLOW);
+
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_VIDEO_IPUV3)
+
+static iomux_v3_cfg_t const backlight_pads[] = {
+	/* Backlight on MIPI connector: J16 */
+	MX6Q_PAD_SD2_CMD__GPIO_1_11 | MUX_PAD_CTRL(NO_PAD_CTRL),
+#define MIPI_BACKLIGHT_GP IMX_GPIO_NR(1, 11)
+
+	/* Backlight CABEN on LVDS connector: J6 */
+	MX6Q_PAD_SD2_CLK__GPIO_1_10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+#define LVDS_BACKLIGHT_GP IMX_GPIO_NR(1, 10)
+};
+
+static struct pwm_device pwm3 = {
+	.pwm_id = 3,
+	.pwmo_invert = 0,
+};
+
+/* Parallel RGB Input (Analog Video In) */
+static iomux_v3_cfg_t const vidin_pads[] = {
+	MX6Q_PAD_EIM_EB2__IPU2_CSI1_D_19,
+	MX6Q_PAD_EIM_D16__IPU2_CSI1_D_18,
+	MX6Q_PAD_EIM_D18__IPU2_CSI1_D_17,
+	MX6Q_PAD_EIM_D19__IPU2_CSI1_D_16,
+	MX6Q_PAD_EIM_D20__IPU2_CSI1_D_15,
+	MX6Q_PAD_EIM_D26__IPU2_CSI1_D_14,
+	MX6Q_PAD_EIM_D27__IPU2_CSI1_D_13,
+	MX6Q_PAD_EIM_A17__IPU2_CSI1_D_12,
+	MX6Q_PAD_EIM_D29__IPU2_CSI1_VSYNC,
+	MX6Q_PAD_EIM_EB3__IPU2_CSI1_HSYNC,
+	MX6Q_PAD_EIM_A16__IPU2_CSI1_PIXCLK,
+};
+
+/* Parallel RGB Output (Analog Video Out) */
+static iomux_v3_cfg_t const vidout_pads[] = {
+	MX6Q_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK,
+	MX6Q_PAD_DI0_PIN2__IPU1_DI0_PIN2,
+	MX6Q_PAD_DI0_PIN3__IPU1_DI0_PIN3,
+	MX6Q_PAD_DISP0_DAT0__IPU1_DISP0_DAT_0,
+	MX6Q_PAD_DISP0_DAT1__IPU1_DISP0_DAT_1,
+	MX6Q_PAD_DISP0_DAT2__IPU1_DISP0_DAT_2,
+	MX6Q_PAD_DISP0_DAT3__IPU1_DISP0_DAT_3,
+	MX6Q_PAD_DISP0_DAT4__IPU1_DISP0_DAT_4,
+	MX6Q_PAD_DISP0_DAT5__IPU1_DISP0_DAT_5,
+	MX6Q_PAD_DISP0_DAT6__IPU1_DISP0_DAT_6,
+	MX6Q_PAD_DISP0_DAT7__IPU1_DISP0_DAT_7,
+	MX6Q_PAD_DISP0_DAT8__IPU1_DISP0_DAT_8,
+	MX6Q_PAD_DISP0_DAT9__IPU1_DISP0_DAT_9,
+	MX6Q_PAD_DISP0_DAT10__IPU1_DISP0_DAT_10,
+	MX6Q_PAD_DISP0_DAT11__IPU1_DISP0_DAT_11,
+	MX6Q_PAD_DISP0_DAT12__IPU1_DISP0_DAT_12,
+	MX6Q_PAD_DISP0_DAT13__IPU1_DISP0_DAT_13,
+	MX6Q_PAD_DISP0_DAT14__IPU1_DISP0_DAT_14,
+	MX6Q_PAD_DISP0_DAT15__IPU1_DISP0_DAT_15,
+};
+
+struct display_info_t {
+	int	bus;
+	int	addr;
+	int	pixfmt;
+	int	(*detect)(struct display_info_t const *dev);
+	void	(*enable)(struct display_info_t const *dev);
+	struct	fb_videomode mode;
+};
+
+
+static int detect_hdmi(struct display_info_t const *dev)
+{
+	return __raw_readb(HDMI_ARB_BASE_ADDR+HDMI_PHY_STAT0) & HDMI_PHY_HPD;
+}
+
+static void enable_hdmi(struct display_info_t const *dev)
+{
+	u8 reg;
+	reg = __raw_readb(
+			HDMI_ARB_BASE_ADDR
+			+HDMI_PHY_CONF0);
+	reg |= HDMI_PHY_CONF0_PDZ_MASK;
+	__raw_writeb(reg,
+		     HDMI_ARB_BASE_ADDR
+			+HDMI_PHY_CONF0);
+	udelay(3000);
+	reg |= HDMI_PHY_CONF0_ENTMDS_MASK;
+	__raw_writeb(reg,
+		     HDMI_ARB_BASE_ADDR
+			+HDMI_PHY_CONF0);
+	udelay(3000);
+	reg |= HDMI_PHY_CONF0_GEN2_TXPWRON_MASK;
+	__raw_writeb(reg,
+		     HDMI_ARB_BASE_ADDR
+			+HDMI_PHY_CONF0);
+	__raw_writeb(HDMI_MC_PHYRSTZ_ASSERT,
+		     HDMI_ARB_BASE_ADDR+HDMI_MC_PHYRSTZ);
+}
+
+static int detect_i2c(struct display_info_t const *dev)
+{
+	return ((0 == i2c_set_bus_num(dev->bus))
+		&&
+		(0 == i2c_probe(dev->addr)));
+}
+
+static void enable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)
+				IOMUXC_BASE_ADDR;
+
+	/* set CH0 data width to 24bit (IOMUXC_GPR2:5 0=18bit, 1=24bit) */
+	u32 reg = readl(&iomux->gpr[2]);
+	reg |= IOMUXC_GPR2_DATA_WIDTH_CH0_24BIT;
+	writel(reg, &iomux->gpr[2]);
+
+	/* Disable CABC:
+	 * when enabled this feature sets backlight automatically according to content
+	 * which may cause annoying unstable backlight issue
+	 */
+	gpio_direction_output(LVDS_BACKLIGHT_GP, 0);
+
+	/* pwm */
+	imx_iomux_v3_setup_pad(MX6Q_PAD_SD1_CMD__PWM4_PWMO | MUX_PAD_CTRL(PAD_CTL_DSE_240ohm));
+	imx_pwm_config(pwm3, 25000, 50000);
+	imx_pwm_enable(pwm3);
+}
+
+#if 0
+static void enable_vidout(struct display_info_t const *dev)
+{
+	imx_iomux_v3_setup_multiple_pads(
+		vidout_pads,
+		 ARRAY_SIZE(vidout_pads));
+}
+#endif
+
+static struct display_info_t const displays[] = {{
+	/* HDMI Output */
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= detect_hdmi,
+	.enable	= enable_hdmi,
+	.mode	= {
+		.name           = "HDMI",
+		.refresh        = 60,
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	/* HannStar HSD100PXN1-A00 with egalx_ts controller
+	 * (aka Freescale MXC-LVDS1 10" 1024x768 60Hz LCD touchscreen)
+	 */
+	.bus	= 2,
+	.addr	= 0x4,
+	.pixfmt	= IPU_PIX_FMT_LVDS666,
+	.detect	= detect_i2c,
+	.enable	= enable_lvds,
+	.mode	= {
+		.name           = "Hannstar-XGA",
+		.refresh        = 60,
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			struct display_info_t const *dev = displays+i;
+			if (dev->detect(dev)) {
+				panel = dev->mode.name;
+				printf("auto-detected panel %s\n", panel);
+				break;
+			}
+		}
+		if (!panel) {
+			panel = displays[0].mode.name;
+			i = 0;
+			printf("No panel detected: default to %s\n", panel);
+		}
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = ipuv3_fb_init(&displays[i].mode, 0,
+				    displays[i].pixfmt);
+		if (!ret) {
+			displays[i].enable(displays+i);
+			printf("DISP:  %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		ret = -EINVAL;
+	}
+	return (0 != ret);
+}
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct anatop_regs *anatop = (struct anatop_regs *)ANATOP_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int reg;
+
+	/* Turn on LDB0,IPU,IPU DI0 clocks */
+	reg = __raw_readl(&mxc_ccm->CCGR3);
+	reg |=   MXC_CCM_CCGR3_IPU1_IPU_DI0_OFFSET
+		|MXC_CCM_CCGR3_LDB_DI0_MASK;
+	writel(reg, &mxc_ccm->CCGR3);
+
+	/* Turn on HDMI PHY clock */
+	reg = __raw_readl(&mxc_ccm->CCGR2);
+	reg |=  MXC_CCM_CCGR2_HDMI_TX_IAHBCLK_MASK
+	       |MXC_CCM_CCGR2_HDMI_TX_ISFRCLK_MASK;
+	writel(reg, &mxc_ccm->CCGR2);
+
+	/* clear HDMI PHY reset */
+	__raw_writeb(HDMI_MC_PHYRSTZ_DEASSERT,
+		     HDMI_ARB_BASE_ADDR+HDMI_MC_PHYRSTZ);
+
+	/* set PFD1_FRAC to 0x13 == 455 MHz (480*18)/0x13 */
+	writel(ANATOP_PFD_480_PFD1_FRAC_MASK, &anatop->pfd_480_clr);
+	writel(0x13<<ANATOP_PFD_480_PFD1_FRAC_SHIFT, &anatop->pfd_480_set);
+
+	/* set LDB0, LDB1 clk select to 011/011 */
+	reg = readl(&mxc_ccm->cs2cdr);
+	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK
+		 |MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
+	reg |= (3<<MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET)
+	      |(3<<MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->cs2cdr);
+
+	reg = readl(&mxc_ccm->cscmr2);
+	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV;
+	writel(reg, &mxc_ccm->cscmr2);
+
+	reg = readl(&mxc_ccm->chsccdr);
+	reg &= ~(MXC_CCM_CHSCCDR_IPU1_DI0_PRE_CLK_SEL_MASK
+		|MXC_CCM_CHSCCDR_IPU1_DI0_PODF_MASK
+		|MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_MASK);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<<MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET)
+	      |(CHSCCDR_PODF_DIVIDE_BY_3
+		<<MXC_CCM_CHSCCDR_IPU1_DI0_PODF_OFFSET)
+	      |(CHSCCDR_IPU_PRE_CLK_540M_PFD
+		<<MXC_CCM_CHSCCDR_IPU1_DI0_PRE_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->chsccdr);
+
+	reg = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
+	     |IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_HIGH
+	     |IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
+	     |IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
+	     |IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT
+	     |IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+	     |IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT
+	     |IOMUXC_GPR2_LVDS_CH1_MODE_DISABLED
+	     |IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0;
+	writel(reg, &iomux->gpr[2]);
+
+	reg = readl(&iomux->gpr[3]);
+	reg = (reg & ~IOMUXC_GPR3_LVDS0_MUX_CTL_MASK)
+	    | (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
+	       <<IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET);
+	writel(reg, &iomux->gpr[3]);
+
+	/* backlights off until needed */
+	imx_iomux_v3_setup_multiple_pads(backlight_pads,
+					 ARRAY_SIZE(backlight_pads));
+	gpio_direction_input(LVDS_BACKLIGHT_GP);
+	gpio_direction_input(MIPI_BACKLIGHT_GP);
+}
+#endif
+
+static int setup_pmic_voltages(void)
+{
+	int ret;
+	unsigned char value, rev_id = 0 ;
+
+	ret = i2c_set_bus_num(1);
+	if (ret)
+		return ret; 
+	if (!i2c_probe(0x8)) {
+		if (i2c_read(0x8, 0, 1, &value, 1)) {
+			printf("Read device ID error!\n");
+			return -1;
+		}
+		if (i2c_read(0x8, 3, 1, &rev_id, 1)) {
+			printf("Read Rev ID error!\n");
+			return -1;
+		}
+		printf("PMIC:  deviceid=%x, revid=%x\n", value, rev_id);
+		/*set VGEN1 to 1.5V and enable*/
+		if (i2c_read(0x8, 0x6c, 1, &value, 1)) {
+			printf("Read VGEN1 error!\n");
+			return -1;
+		}
+		value &= ~0x1f;
+		value |= 0x1e;
+		if (i2c_write(0x8, 0x6c, 1, &value, 1)) {
+			printf("Set VGEN1 error!\n");
+			return -1;
+		}
+		/*set SWBST to 5.0V and enable */
+		if (i2c_read(0x8, 0x66, 1, &value, 1)) {
+			printf("Read SWBST error!\n");
+			return -1;
+		}
+		value &= ~0xf;
+		value |= 0x8;
+		if (i2c_write(0x8, 0x66, 1, &value, 1)) {
+			printf("Set SWBST error!\n");
+			return -1;
+		}
+	}
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+/* BOOT_CFG1, BOOT_CFG2, BOOT_CFG3, BOOT_CFG4
+ * see Table 8-11 and Table 5-9
+ *  BOOT_CFG1[7] = 1 (boot from NAND)
+ *  BOOT_CFG1[5] = 0 - raw NAND
+ *  BOOT_CFG1[4] = 0 - default pad settings
+ *  BOOT_CFG1[3:2] = 00 - devices = 1
+ *  BOOT_CFG1[1:0] = 00 - Row Address Cycles = 3
+ *  BOOT_CFG2[4:3] = 00 - Boot Search Count = 2
+ *  BOOT_CFG2[2:1] = 01 - Pages In Block = 64
+ *  BOOT_CFG2[0] = 0 - Reset time 12ms
+ */
+static const struct boot_mode board_boot_modes[] = {
+	/* NAND: raw, 64pages per block, 3 row addr cycles, 2 copies of FCB/DBBT */
+	{ "nand", MAKE_CFGVAL(0x80, 0x02, 0x00, 0x00) },
+	{ NULL,	0 },
+};
+#endif
+
+/*
+ * Board Support
+ */
+
+/*
+ * Do not overwrite the console
+ * Use always serial for U-Boot console
+ */
+int overwrite_console(void)
+{
+	return 1;
+}
+
+
+/*
+ * very early in the call chain - setup SoC peripherals
+ * (NB: Can not printf from here)
+ */
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+#ifdef CONFIG_MXC_SPI
+	setup_spi();
+#endif
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info0);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+#if defined(CONFIG_VIDEO_IPUV3)
+	setup_display();
+#endif
+
+	return 0;
+}
+
+#if defined(CONFIG_DISPLAY_BOARDINFO)
+/* Identify board and display banner/info
+ */
+#define SRC_SBMR1 0x020d8004  // holds BOOT_CFG1-BOOT_CFG4 from eFuse/pins
+#define SRC_SBMR2 0x020d801c
+#define SRC_GPR9  0x020d8040  // holds copy of BOOT_CFG1-BOOT_CFG4 acted on
+#define SRC_GPR10 0x020d8044
+
+void show_boot_mode(uint boot_cfg)
+{
+// this reads boot_cfg efuse/pins - does not reflect what actually booted
+// from if you used bmode
+//printf("BOOT_CFG1=0x%02x\n", src_sbmr1 & 0xff);
+//printf("BOOT_CFG2=0x%02x\n", (src_sbmr1 >> 8) & 0xff);
+//printf("BOOT_CFG3=0x%02x\n", (src_sbmr1 >> 16) & 0xff);
+//printf("BOOT_CFG4=0x%02x\n", (src_sbmr1 >> 24) & 0xff);
+	switch ((boot_cfg & 0x000000ff) >> 4) {
+	case 0x2:
+		printf("SATA");
+		break;
+	case 0x3:
+		printf("SPI NOR");
+		break;
+	case 0x4:
+	case 0x5:
+		// BOOT_CFG2[3:4] is devno
+		printf(" SD%d", (boot_cfg & 0x00001800) >> 11);
+    break;
+  case 0x6:
+  case 0x7:
+		// BOOT_CFG2[3:4] is devno
+		printf(" MMC%d", (boot_cfg & 0x00001800) >> 11);
+    break;
+  case 0x8 ... 0xf:
+		printf("NAND");
+    break;
+  default:
+		printf("Unknown");
+    break;
+  }
+	printf(" 0x%08x\n", boot_cfg);
+}
+
+
+int checkboard(void)
+{
+	struct ventana_board_info *info = &ventana_info;
+	uint src_sbmr2 = readl(SRC_SBMR2);
+	uint src_gpr10 = readl(SRC_GPR10);
+
+	read_eeprom();
+	if (!(src_sbmr2 & 1<<4)) {
+		// can consider this 'manufacturing mode' if needed
+		printf("First boot - eFUSE not blown\n");
+	}
+
+	//if (src_gpr10 & 1<<30)
+	//	printf("APP_IMAGE: Secondary\n");
+	printf("APP_IMAGE: %s\n", (src_gpr10 & 1<<30)?"Secondary":"Primary");
+	if (src_gpr10 & 1<<29)
+		printf("NAND: bad blocks in application image\n");
+
+#if defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+	printf("Env: SPI FLASH\n");
+#elif defined(CONFIG_ENV_IS_IN_MMC)
+	printf("Env: MMC\n");
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+	printf("Env: NAND FLASH\n");
+#endif
+
+	// SRC_SBMR1 reflects eFUSE/pin
+	printf("BOOT_CFG: ");
+	show_boot_mode(readl(SRC_SBMR1));
+	// SRC_GPR9 reflects what was actually booted off of if not 0
+	// (ie if bmode was used)
+	if (readl(SRC_GPR9)) {
+		printf("BMODE: ");
+		show_boot_mode(readl(SRC_GPR9));
+	}
+	printf("\n");
+
+	printf("Gateworks Corporation Copyright 2013\n");
+	if (info->model[0]) {
+		printf("Model: %s\n", info->model);
+		printf("MFGDate: %02x-%02x-%02x%02x\n",
+			info->mfgdate[0], info->mfgdate[1],
+			info->mfgdate[2], info->mfgdate[3]);
+		printf("Serial:%d\n", info->serial);
+	} else {
+		printf("Invalid EEPROM - board will not function fully\n");
+	}
+
+	return 0;
+}
+#endif
+
+/* Set gd->ram_size
+ */
+int dram_init(void)
+{
+	struct ventana_board_info *info = &ventana_info;
+
+	if (info->model[0] && info->sdram_size > 0 && info->sdram_size < 9) {
+		int i = info->sdram_size;
+		gd->ram_size = 32*1024*1024;
+		while(--i)
+			gd->ram_size *=2;		
+	} else {
+		// let get_ram_size do its work against 1GB
+		gd->ram_size = get_ram_size((void *)PHYS_SDRAM, PHYS_SDRAM_SIZE);
+	}
+
+	return 0;
+}
+
+/* initialize periperhals
+ */
+int board_init(void)
+{
+	int ret = 0;
+ 
+#ifdef CONFIG_CMD_NAND
+	setup_gpmi_nand();
+#endif
+
+	/* address of linux boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_I2C_MXC
+	ret = setup_pmic_voltages();
+	if (ret)
+		return -1;
+#endif
+
+	setup_pcie();
+
+#ifdef CONFIG_CMD_SATA
+	setup_sata();
+#endif
+
+	if (!i2c_set_bus_num(0)) {
+		unsigned char buf[4];
+		if (!gsc_i2c_read(0x20, 14, 1, buf, 1)) {
+			printf("GSC:   v%d", buf[0]);
+			if (!gsc_i2c_read(0x20, 10, 1, buf, 4)) {
+				/* show firmware revision and CRC */
+				printf(" 0x%04x", buf[2] | buf[3]<<8);
+				/* show status register */
+				printf(" 0x%02x", buf[0]);
+				/* display if encountered a GSC watchdog timeout */
+				if (buf[0] & 0x40) {
+					printf(" WD_TIMEOUT");
+					/* clear flag */
+					buf[0] &= ~0x40;
+					gsc_i2c_write(0x20, 1, 1, &buf[0], 1);
+				}
+			}
+			printf("\n");
+		}
+		if (!gsc_i2c_read(0x68, 0x00, 1, buf, 4))
+			printf("RTC:   %d\n", buf[0] | buf[1]<<8 | buf[2]<<16 | buf[3]<<24);
+	}
+
+#ifdef CONFIG_CMD_GSC
+	// if eFUSE not blown show GSC HWMON info
+	if (!(readl(SRC_SBMR2) & 1<<4)) {
+		mdelay(1500);
+		do_gsc(NULL, 0, 0, NULL);
+	}
+#endif
+
+	return 0;
+}
+
+/* late init
+ */
+int misc_init_r(void)
+{
+	/* set env vars based on board model from EEPROM */
+	if (ventana_info.model[0]) {
+		char str[20];
+		char fdt[30];
+		char *p;
+		int i;
+
+		memset(str, 0, sizeof(str));
+		for (i = 0; i < sizeof(ventana_info.model) && ventana_info.model[i]; i++)
+			str[i] = tolower(ventana_info.model[i]);
+		if (!getenv("model"))
+			setenv("model", str);
+		if (!getenv("fdt_file")) {
+			sprintf(fdt, "imx6q-%s.dtb", str);
+			setenv("fdt_file", fdt);
+		}
+		if ( (p = strchr(str, '-')) ) {
+			*p++ = 0;
+
+			setenv("model_base", str);
+			if (!getenv("fdt_file1")) {
+				sprintf(fdt, "imx6q-%s.dtb", str);
+				setenv("fdt_file1", fdt);
+			}
+			str[4] = 'x';
+			str[5] = 'x';
+			str[6] = 0;
+			if (!getenv("fdt_file2")) {
+				sprintf(fdt, "imx6q-%s.dtb", str);
+				setenv("fdt_file2", fdt);
+			}
+		}
+		get_mac("ethaddr", ventana_info.mac0);
+		get_mac("eth1addr", ventana_info.mac1);
+		sprintf(str, "%6d", ventana_info.serial);
+		setenv("serial#", str);
+		setup_board_gpio(getenv("model"));
+	}
+
+	/* generate a random eth mac if no EEPROM (1st boot - mfg mode) */
+	else {
+		u32 ethaddr_low, ethaddr_high;
+		char str[20];
+
+		imx_otp_read_one_u32(0x01, &ethaddr_low);
+		imx_otp_read_one_u32(0x01, &ethaddr_high);
+
+		/*
+		 * setting the 2nd LSB in the most significant byte of
+		 * the address makes it a locally administered ethernet
+		 * address
+		 */
+    ethaddr_high &= 0xfeff;
+		ethaddr_high |= 0x0200;
+		sprintf(str, "%02X:%02X:%02X:%02X:%02X:%02X",
+			ethaddr_high >> 8, ethaddr_high & 0xff,
+			ethaddr_low >> 24, (ethaddr_low >> 16) & 0xff,
+			(ethaddr_low >> 8) & 0xff, ethaddr_low & 0xff);
+		printf("### Setting random MAC address = \"%s\"\n", str);
+		setenv("ethaddr", str);
+	}
+
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+	/* disable GSC boot watchdog
+	 *
+	 *  The Gateworks System Controller implements a boot
+	 *  watchdog (always enabled) to cover things like ERR006282 which can
+	 *  lead to random boot failures.
+	 */
+	if (!i2c_set_bus_num(0)) {
+		unsigned char val;
+		if (!gsc_i2c_read(0x20, 1, 1, &val, 1)) {
+			val |= 0x80;
+			if (gsc_i2c_write(0x20, 1, 1, &val, 1))
+				printf("Error: could not disable GSC Watchdog\n");
+		} else {
+			printf("Error: could not disable GSC Watchdog\n");
+		}
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_OF_LIBFDT) && defined(CONFIG_OF_BOARD_SETUP)
+void ft_board_setup(void *blob, bd_t * bd)
+{
+	struct ventana_board_info *info = &ventana_info;
+	struct node_info nodes[] = {
+		{ "sst,w25q256",          MTD_DEV_TYPE_NOR, },  // SPI flash
+		{ "fsl,imx6q-gpmi-nand",  MTD_DEV_TYPE_NAND, }, // NAND flash
+	};
+  const char *model = getenv("model");
+
+	if (getenv("fdt_noauto")) {
+		printf("   Skiping ft_board_setup (fdt_noauto defined)\n");
+		return;
+	}
+
+  if (!model) {
+		printf("invalid board info: Leaving FDT fully enabled\n");
+		return;
+	}
+
+	/* MTD partitions
+	 * Update partition nodes using info from mtdparts env var
+	 */
+	printf("   Updating MTD partitions...\n");
+	fdt_fixup_mtdparts(blob, nodes, ARRAY_SIZE(nodes));
+
+	printf("   Adjusting FDT per EEPROM for %s...\n", model);
+	/* Note that fdt_fixup_ethernet is called in arm/lib/bootm before this
+	 * which sets mac-address and local-mac-address properties of
+	 * ethernet<n> aliases to ethaddr...eth<n>addr env
+	 */
+
+	/* board serial number */
+	fdt_setprop(blob, 0, "system-serial", getenv("serial#"), strlen(getenv("serial#") + 1));
+
+	/* Peripheral Config */
+	if (!info->config_eth0)
+		fdt_del_node_and_alias(blob, "ethernet0");
+	if (!info->config_eth1)
+		fdt_del_node_and_alias(blob, "ethernet1");
+	if (!info->config_hdmi_out)
+		fdt_del_node_and_alias(blob, "hdmi_out");
+	if (!info->config_sata)
+		fdt_del_node_and_alias(blob, "ahci0");
+	if (!info->config_pcie)
+		fdt_del_node_and_alias(blob, "pcie");
+	if (!info->config_ssi0)
+		fdt_del_node_and_alias(blob, "ssi0");
+	if (!info->config_ssi1)
+		fdt_del_node_and_alias(blob, "ssi1");
+	if (!info->config_lcd)
+		fdt_del_node_and_alias(blob, "lcd0");
+	if (!info->config_lvds0)
+		fdt_del_node_and_alias(blob, "lvds0");
+	if (!info->config_lvds1)
+		fdt_del_node_and_alias(blob, "lvds1");
+	if (!info->config_usb0)
+		fdt_del_node_and_alias(blob, "usb0");
+	if (!info->config_usb1)
+		fdt_del_node_and_alias(blob, "usb1");
+	if (!info->config_sd0)
+		fdt_del_node_and_alias(blob, "usdhc0");
+	if (!info->config_sd1)
+		fdt_del_node_and_alias(blob, "usdhc1");
+	if (!info->config_sd2)
+		fdt_del_node_and_alias(blob, "usdhc2");
+	if (!info->config_sd3)
+		fdt_del_node_and_alias(blob, "usdhc3");
+	if (!info->config_uart0)
+		fdt_del_node_and_alias(blob, "serial0");
+	if (!info->config_uart1)
+		fdt_del_node_and_alias(blob, "serial1");
+	if (!info->config_uart2)
+		fdt_del_node_and_alias(blob, "serial2");
+	if (!info->config_uart3)
+		fdt_del_node_and_alias(blob, "serial3");
+	if (!info->config_uart4)
+		fdt_del_node_and_alias(blob, "serial4");
+	if (!info->config_ipu0)
+		fdt_del_node_and_alias(blob, "ipu0");
+	if (!info->config_ipu1)
+		fdt_del_node_and_alias(blob, "ipu1");
+	if (!info->config_flexcan)
+		fdt_del_node_and_alias(blob, "can0");
+	if (!info->config_mipi_dsi)
+		fdt_del_node_and_alias(blob, "mipi_dsi");
+	if (!info->config_mipi_csi)
+		fdt_del_node_and_alias(blob, "mipi_csi");
+	if (!info->config_tzasc0)
+		fdt_del_node_and_alias(blob, "tzasc0");
+	if (!info->config_tzasc1)
+		fdt_del_node_and_alias(blob, "tzasc1");
+	if (!info->config_i2c0)
+		fdt_del_node_and_alias(blob, "i2c0");
+	if (!info->config_i2c1)
+		fdt_del_node_and_alias(blob, "i2c1");
+	if (!info->config_i2c2)
+		fdt_del_node_and_alias(blob, "i2c2");
+	if (!info->config_vpu)
+		fdt_del_node_and_alias(blob, "vpu");
+	if (!info->config_csi0)
+		fdt_del_node_and_alias(blob, "csi0");
+	if (!info->config_csi1)
+		fdt_del_node_and_alias(blob, "csi1");
+	if (!info->config_caam)
+		fdt_del_node_and_alias(blob, "caam");
+	if (!info->config_espci0)
+		fdt_del_node_and_alias(blob, "spi0");
+	if (!info->config_espci1)
+		fdt_del_node_and_alias(blob, "spi1");
+	if (!info->config_espci2)
+		fdt_del_node_and_alias(blob, "spi2");
+	if (!info->config_espci3)
+		fdt_del_node_and_alias(blob, "spi3");
+	if (!info->config_espci4)
+		fdt_del_node_and_alias(blob, "spi4");
+	if (!info->config_espci5)
+		fdt_del_node_and_alias(blob, "spi5");
+	if (!info->config_hdmi_in)
+		fdt_del_node_and_alias(blob, "hdmi_in");
+	if (!info->config_vid_out)
+		fdt_del_node_and_alias(blob, "cvbs_out");
+	if (!info->config_vid_in)
+		fdt_del_node_and_alias(blob, "cvbs_in");
+	if (!info->config_nand)
+		fdt_del_node_and_alias(blob, "nand");
+}
+#endif /* defined(CONFIG_OF_FLAT_TREE) && defined(CONFIG_OF_BOARD_SETUP) */
+
diff --git a/board/gateworks/gw_ventana/gw_ventana.cfg b/board/gateworks/gw_ventana/gw_ventana.cfg
new file mode 100644
index 0000000..878fe2a
--- /dev/null
+++ b/board/gateworks/gw_ventana/gw_ventana.cfg
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2013 Gateworks Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd, nand, sata
+ */
+BOOT_FROM      nand
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+#include "ddr-setup.cfg"
+#include "1066mhz_4x128mx16.cfg"
+#include "clocks.cfg"
diff --git a/board/gateworks/gw_ventana/ventana_eeprom.h b/board/gateworks/gw_ventana/ventana_eeprom.h
new file mode 100644
index 0000000..85b9b5f
--- /dev/null
+++ b/board/gateworks/gw_ventana/ventana_eeprom.h
@@ -0,0 +1,108 @@
+/*
+ * ventana_eeprom.h - Gateworks Ventana EEPROM Configuration
+ * v1.00
+ */
+#ifndef _VENTANA_EEPROM_
+#define _VENTANA_EEPROM_
+
+struct ventana_board_info {
+	u8 mac0[6];          // 0x00: MAC1
+	u8 mac1[6];          // 0x06: MAC2
+	u8 res0[12];         // 0x0C: reserved
+	u32 serial;          // 0x18: Serial Number (read only)
+	u8 console;          // 0x1C: console UART 
+	u8 res1[3];          // 0x1D: reserved
+	u8 mfgdate[4];       // 0x20: MFG date (read only)
+	u8 res2[7];          // 0x24
+	// sdram config
+	u8 sdram_size;       // 0x2B: enum (512,1024,2048) MB
+	u8 sdram_speed;      // 0x2C: enum (100,133,166,200,267,333,400) MHz
+	u8 sdram_width;      // 0x2D: enum (32,64) bit
+	// cpu config
+	u8 cpu_speed;        // 0x2E: enum (800,1000,1200) MHz
+	u8 cpu_type;         // 0x2F: enum (imx6q,imx6d,imx6dl,imx6s)
+	u8 model[16];        // 0x30: model string (affects kernel board setup)
+	// FLASH config
+	u8 nand_flash_size;  // 0x40: enum (4,8,16,32,64,128) MB
+	u8 spi_flash_size;   // 0x41: enum (4,8,16,32,64,128) MB
+
+	// Config1: SoC Peripherals
+	u8 config_eth0:1;    // 0: 0x42
+	u8 config_eth1:1;    // 1
+	u8 config_hdmi_out:1;// 2
+	u8 config_sata:1;    // 3
+	u8 config_pcie:1;    // 4
+	u8 config_ssi0:1;    // 5
+	u8 config_ssi1:1;    // 6
+	u8 config_lcd:1;     // 7
+
+	u8 config_lvds0:1;   // 0: 0x43
+	u8 config_lvds1:1;   // 1
+	u8 config_usb0:1;    // 2 (USB EHCI)
+	u8 config_usb1:1;    // 3 (USB OTG)
+	u8 config_sd0:1;     // 4
+	u8 config_sd1:1;     // 5
+	u8 config_sd2:1;     // 6
+	u8 config_sd3:1;     // 7
+
+	u8 config_uart0:1;   // 0: 0x44
+	u8 config_uart1:1;   // 1
+	u8 config_uart2:1;   // 2
+	u8 config_uart3:1;   // 3
+	u8 config_uart4:1;   // 4
+	u8 config_ipu0:1;    // 5
+	u8 config_ipu1:1;    // 6
+	u8 config_flexcan:1; // 7
+
+	u8 config_mipi_dsi:1;// 0: 0x45
+	u8 config_mipi_csi:1;// 1
+	u8 config_tzasc0:1;  // 2
+	u8 config_tzasc1:1;  // 3
+	u8 config_i2c0:1;    // 4
+	u8 config_i2c1:1;    // 5
+	u8 config_i2c2:1;    // 6
+	u8 config_vpu:1;     // 7
+
+	u8 config_csi0:1;    // 0: 0x46
+	u8 config_csi1:1;    // 1
+	u8 config_caam:1;    // 2
+	u8 config_mezz:1;    // 3
+	u8 config_res1:1;    // 4
+	u8 config_res2:1;    // 5
+	u8 config_res3:1;    // 6
+	u8 config_res4:1;    // 7
+
+	u8 config_espci0:1;  // 0: 0x47
+	u8 config_espci1:1;  // 1
+	u8 config_espci2:1;  // 2
+	u8 config_espci3:1;  // 3
+	u8 config_espci4:1;  // 4
+	u8 config_espci5:1;  // 5
+	u8 config_res5:1;    // 6
+	u8 config_res6:1;    // 7
+
+	// Config2: Other Peripherals 
+	u8 config_gps:1;     // 0: 0x48
+	u8 config_spifl0:1;  // 1
+	u8 config_spifl1:1;  // 2
+	u8 config_gspbatt:1; // 3
+	u8 config_hdmi_in:1; // 4
+	u8 config_vid_out:1; // 5
+	u8 config_vid_in:1;  // 6
+	u8 config_nand:1;    // 7
+
+	u8 config_res8:1;    // 0: 0x49
+	u8 config_res9:1;    // 1
+	u8 config_res10:1;   // 2
+	u8 config_res11:1;   // 3
+	u8 config_res12:1;   // 4
+	u8 config_res13:1;   // 5
+	u8 config_res14:1;   // 6
+	u8 config_res15:1;   // 7
+
+	u8 res3[4];          // 0x4A
+
+	u8 chksum[2];        // 0x4E
+};
+
+#endif
diff --git a/boards.cfg b/boards.cfg
index 136ea0a..8358dac 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -253,6 +253,7 @@ mx6qarm2                     arm         armv7       mx6qarm2            freesca
 mx6qsabreauto                arm         armv7       mx6qsabreauto       freescale      mx6		mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/imximage.cfg
 mx6qsabrelite                arm         armv7       mx6qsabrelite       freescale      mx6		mx6qsabrelite:IMX_CONFIG=board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg
 mx6qsabresd                  arm         armv7       mx6qsabresd         freescale      mx6		mx6qsabresd:IMX_CONFIG=board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg
+gw_ventana                   arm         armv7       gw_ventana          gateworks      mx6		gw_ventana:IMX_CONFIG=board/gateworks/gw_ventana/gw_ventana.cfg
 eco5pk                       arm         armv7       eco5pk              8dtech         omap3
 cm_t35                       arm         armv7       cm_t35              -              omap3
 omap3_overo                  arm         armv7       overo               -              omap3
diff --git a/common/Makefile b/common/Makefile
index 719fc23..ffb2d3a 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -111,6 +111,7 @@ COBJS-$(CONFIG_CMD_I2C) += cmd_i2c.o
 COBJS-$(CONFIG_CMD_HASH) += cmd_hash.o
 COBJS-$(CONFIG_CMD_IDE) += cmd_ide.o
 COBJS-$(CONFIG_CMD_IMMAP) += cmd_immap.o
+COBJS-$(CONFIG_CMD_IMXOTP) += cmd_imxotp.o
 COBJS-$(CONFIG_CMD_INI) += cmd_ini.o
 COBJS-$(CONFIG_CMD_IRQ) += cmd_irq.o
 COBJS-$(CONFIG_CMD_ITEST) += cmd_itest.o
diff --git a/common/cmd_imxotp.c b/common/cmd_imxotp.c
new file mode 100644
index 0000000..3d5b98a
--- /dev/null
+++ b/common/cmd_imxotp.c
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <asm/arch/sys_proto.h>
+
+/* meant to reject most of the zeros return by simple_strtoul call */
+int validate_zero_from_simple_strtoul(char *str)
+{
+	int i;
+
+	/* reject negatives */
+	if (str[0] == '-')
+		return -1;
+
+	/* reject no zero initialed */
+	if (str[0] != '0')
+		return -1;
+
+	/* accept zero */
+	if (strlen(str) == 1)
+		return 0;
+
+	/* only accept started with "0x" or "0X" or "00" */
+	if (str[1] != 'x' && str[1] != 'X' && str[1] != '0')
+		return -1;
+
+	/* reject "0x" or "0X" or "00" only */
+	if (strlen(str) == 3)
+		return -1;
+
+	/* only accept all zeros */
+	for (i = 1; i < strlen(str) - 1; i++) {
+		if (str[1] != '0')
+			return -1;
+	}
+	return 0;
+}
+
+int do_imxotp(cmd_tbl_t *cmd_tbl, int flag, int argc, char *  const argv[])
+{
+	u32 addr, value_read;
+#ifdef IMX_OTPWRITE_ENABLED
+	u32 fused_value, value_to_fuse;
+	int force_to_fuse = 0;
+#endif
+
+	if (argc < 3) {
+usage:
+		cmd_usage(cmd_tbl);
+		return 1;
+	}
+
+	if (!strcmp(argv[1], "read")) {
+		switch (argc) {
+		case 3:
+			addr = simple_strtoul(argv[2], NULL, 16);
+			if ((addr == 0) &&
+				validate_zero_from_simple_strtoul(argv[2]))
+				goto usage;
+			break;
+		default:
+			goto usage;
+		}
+		printf("Reading fuse at index 0x%X\n", addr);
+		if (imx_otp_read_one_u32(addr, &value_read))
+			return -1;
+		printf("Fuse at index 0x%X has the value: 0x%08X\n", addr, value_read);
+#ifdef IMX_OTPWRITE_ENABLED
+	} else if (!strcmp(argv[1], "blow")) {
+		if (argc < 4 || argc > 5)
+			goto usage;
+
+		if (!strcmp(argv[2], "--force")) {
+			force_to_fuse = 1;
+			addr = simple_strtoul(argv[3], NULL, 16);
+			if ((addr == 0)
+				  && validate_zero_from_simple_strtoul(argv[3]))
+				goto usage;
+			value_to_fuse = simple_strtoul(argv[4], NULL, 16);
+			if ((value_to_fuse == 0)
+				  && validate_zero_from_simple_strtoul(argv[4]))
+				goto usage;
+		} else {
+			addr = simple_strtoul(argv[2], NULL, 16);
+			if ((addr == 0)
+				  && validate_zero_from_simple_strtoul(argv[2]))
+				goto usage;
+			value_to_fuse = simple_strtoul(argv[3], NULL, 16);
+			if ((value_to_fuse == 0)
+				  && validate_zero_from_simple_strtoul(argv[3]))
+				goto usage;
+		}
+
+		/* show the current value of specified address (fuse index) */
+		if (imx_otp_read_one_u32(addr, &value_read))
+			return -1;
+		printf("Current fuse at index 0x%X has the value: 0x%08X\n",
+				addr, value_read);
+
+		if ((value_to_fuse & value_read) == value_to_fuse)
+			printf("!! Fuse blow skipped:"
+					" the bits have been already set.\n");
+		else if (force_to_fuse) {
+			printf("Blowing fuse at index 0x%X, value: 0x%08X\n",
+					addr, value_to_fuse);
+			if (imx_otp_blow_one_u32(addr,
+					value_to_fuse, &fused_value)) {
+				printf("ERROR: failed to blow fuse"
+					  " at 0x%X with value of 0x%08X\n",
+						addr, value_to_fuse);
+			} else {
+				printf("Operation %s fuse"
+					  " at index 0x%X value: 0x%08X\n",
+					((fused_value & value_to_fuse) ==
+					value_to_fuse) ? "succeeded" : "failed",
+					addr, fused_value);
+			}
+		} else {
+			printf("!! Fuse blow aborted."
+				" if you do want to blow it."
+				" Please use the command:\n"
+				"%s blow --force %X %X\n",
+				argv[0], addr, value_to_fuse);
+		}
+#endif
+	} else
+		goto usage;
+
+	return 0;
+}
+
+U_BOOT_CMD(imxotp, 5, 0, do_imxotp,
+	"One-Time Programable sub-system for i.MX processors",
+	"read <addr>\n"
+	" - read fuse at 'addr'\n"
+#ifdef IMX_OTPWRITE_ENABLED
+	"imxotp blow [--force] <addr> <value>\n"
+	" - blow fuse at 'addr' with hex value 'value'\n"
+#endif
+);
diff --git a/common/cmd_ubifs.c b/common/cmd_ubifs.c
index 7752123..0937fa8 100644
--- a/common/cmd_ubifs.c
+++ b/common/cmd_ubifs.c
@@ -121,8 +121,10 @@ int do_ubifs_ls(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	debug("Using filename %s\n", filename);
 
 	ret = ubifs_ls(filename);
-	if (ret)
-		printf("%s not found!\n", filename);
+	if (ret) {
+		printf("** File not found %s **\n", filename);
+		ret = CMD_RET_FAILURE;
+	}
 
 	return ret;
 }
@@ -157,8 +159,10 @@ int do_ubifs_load(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	debug("Loading file '%s' to address 0x%08x (size %d)\n", filename, addr, size);
 
 	ret = ubifs_load(filename, addr, size);
-	if (ret)
-		printf("%s not found!\n", filename);
+	if (ret) {
+		printf("** File not found %s **\n", filename);
+		ret = CMD_RET_FAILURE;
+	}
 
 	return ret;
 }
diff --git a/drivers/dma/apbh_dma.c b/drivers/dma/apbh_dma.c
index 0c1cd83..510cb28 100644
--- a/drivers/dma/apbh_dma.c
+++ b/drivers/dma/apbh_dma.c
@@ -31,7 +31,8 @@
 #include <asm/arch/clock.h>
 #include <asm/arch/imx-regs.h>
 #include <asm/arch/sys_proto.h>
-#include <asm/arch/dma.h>
+#include <asm/imx-common/dma.h>
+#include <asm/imx-common/regs-apbh.h>
 
 static struct mxs_dma_chan mxs_dma_channels[MXS_MAX_DMA_CHANNELS];
 
@@ -226,7 +227,7 @@ static int mxs_dma_reset(int channel)
 #if defined(CONFIG_MX23)
 	uint32_t setreg = (uint32_t)(&apbh_regs->hw_apbh_ctrl0_set);
 	uint32_t offset = APBH_CTRL0_RESET_CHANNEL_OFFSET;
-#elif defined(CONFIG_MX28)
+#elif (defined(CONFIG_MX28) || defined(CONFIG_MX6))
 	uint32_t setreg = (uint32_t)(&apbh_regs->hw_apbh_channel_ctrl_set);
 	uint32_t offset = APBH_CHANNEL_CTRL_RESET_CHANNEL_OFFSET;
 #endif
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 8cdc3b6..40bff2f 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -29,6 +29,8 @@ COBJS-$(CONFIG_ALI152X) += ali512x.o
 COBJS-$(CONFIG_DS4510)  += ds4510.o
 COBJS-$(CONFIG_CBMEM_CONSOLE) += cbmem_console.o
 COBJS-$(CONFIG_GPIO_LED) += gpio_led.o
+COBJS-$(CONFIG_IMX_OTP) += imx_otp.o
+COBJS-$(CONFIG_IMX_PWM) += imx_pwm.o
 COBJS-$(CONFIG_FSL_MC9SDZ60) += mc9sdz60.o
 COBJS-$(CONFIG_NS87308) += ns87308.o
 COBJS-$(CONFIG_PDSP188x) += pdsp188x.o
diff --git a/drivers/misc/imx_otp.c b/drivers/misc/imx_otp.c
new file mode 100644
index 0000000..b4d1299
--- /dev/null
+++ b/drivers/misc/imx_otp.c
@@ -0,0 +1,246 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/sys_proto.h>
+
+#define BF(value, field)	(((value) << BP_##field) & BM_##field)
+#define DEF_RELAX 20
+
+#ifdef CONFIG_IMX_OTP_DEBUG
+#define log(a, ...) printf("[%s,%3d]:"a"\n", __func__, __LINE__, ## __VA_ARGS__)
+#else
+#define log(a, ...)
+#endif
+
+static int otp_wait_busy(u32 flags)
+{
+	int count;
+	u32 c;
+	struct iim_regs *otp = (struct iim_regs *)IMX_OTP_BASE;
+
+	for (count = 10000; count >= 0; count--) {
+		c = readl(&otp->ctrl);
+		if (!(c & (BM_OCOTP_CTRL_BUSY | BM_OCOTP_CTRL_ERROR | flags)))
+			break;
+	}
+
+	if (count < 0) {
+		printf("ERROR: otp_wait_busy timeout. 0x%X\n", c);
+		/* clear ERROR bit, busy bit will be cleared by controller */
+		writel(BM_OCOTP_CTRL_ERROR, &otp->ctrl_clr);
+		return -1;
+	}
+
+	log("wait busy successful.");
+	return 0;
+}
+
+static int set_otp_timing(void)
+{
+	u32 clk_rate;
+	u32 relax, strobe_read, strobe_prog;
+	u32 timing;
+	struct iim_regs *otp = (struct iim_regs *)IMX_OTP_BASE;
+
+	/* get clock */
+	clk_rate = mxc_get_clock(MXC_IPG_CLK);
+	if (clk_rate == -1) {
+		printf("ERROR: mxc_get_clock failed\n");
+		return -1;
+	}
+
+	log("clk_rate: %d.", clk_rate);
+
+	relax = clk_rate / (1000000000 / DEF_RELAX) - 1;
+	strobe_prog = clk_rate / (1000000000 / 10000) + 2 * (DEF_RELAX + 1) - 1;
+	strobe_read = clk_rate / (1000000000 / 40) + 2 * (DEF_RELAX + 1) - 1;
+
+	timing = BF(relax, OCOTP_TIMING_RELAX);
+	timing |= BF(strobe_read, OCOTP_TIMING_STROBE_READ);
+	timing |= BF(strobe_prog, OCOTP_TIMING_STROBE_PROG);
+	log("timing: 0x%X", timing);
+
+	writel(timing, &otp->timing);
+
+	return 0;
+}
+
+static int otp_read_prep(void)
+{
+	return  (!set_otp_timing()) ? otp_wait_busy(0) : -1;
+}
+
+#ifdef IMX_OTPWRITE_ENABLED
+static int otp_blow_prep(void)
+{
+	return  (!set_otp_timing()) ? otp_wait_busy(0) : -1;
+}
+
+static int otp_blow_post(void)
+{
+	struct iim_regs *otp = (struct iim_regs *)IMX_OTP_BASE;
+
+	printf("Reloading shadow registers...\n");
+	/* reload all the shadow registers */
+	writel(BM_OCOTP_CTRL_RELOAD_SHADOWS, &otp->ctrl_set);
+	udelay(1);
+
+	return otp_wait_busy(BM_OCOTP_CTRL_RELOAD_SHADOWS);
+}
+#endif
+
+static int fuse_read_addr(u32 addr, u32 *pdata)
+{
+	u32 ctrl_reg;
+	struct iim_regs *otp = (struct iim_regs *)IMX_OTP_BASE;
+
+	ctrl_reg = readl(&otp->ctrl);
+	ctrl_reg &= ~BM_OCOTP_CTRL_ADDR;
+	ctrl_reg &= ~BM_OCOTP_CTRL_WR_UNLOCK;
+	ctrl_reg |= BF(addr, OCOTP_CTRL_ADDR);
+	writel(ctrl_reg, &otp->ctrl);
+
+	writel(BM_OCOTP_READ_CTRL_READ_FUSE, &otp->read_ctrl);
+	if (otp_wait_busy(0))
+		return -1;
+
+	*pdata = readl(&otp->fuse_data);
+	return 0;
+}
+
+#ifdef IMX_OTPWRITE_ENABLED
+static int fuse_blow_addr(u32 addr, u32 value)
+{
+	u32 ctrl_reg;
+	struct iim_regs *otp = (struct iim_regs *)IMX_OTP_BASE;
+
+	log("blowing...");
+
+	/* control register */
+	ctrl_reg = readl(&otp->ctrl);
+	ctrl_reg &= ~BM_OCOTP_CTRL_ADDR;
+	ctrl_reg |= BF(addr, OCOTP_CTRL_ADDR);
+	ctrl_reg |= BF(BV_OCOTP_CTRL_WR_UNLOCK__KEY, OCOTP_CTRL_WR_UNLOCK);
+	writel(ctrl_reg, &otp->ctrl);
+
+	writel(value, &otp->data);
+	if (otp_wait_busy(0))
+		return -1;
+
+	/* write postamble */
+	udelay(2000);
+	return 0;
+}
+#endif
+
+/*
+ * read one u32 to indexed fuse
+ */
+int imx_otp_read_one_u32(u32 index, u32 *pdata)
+{
+	u32 ctrl_reg;
+	int ret = 0;
+	struct iim_regs *otp = (struct iim_regs *)IMX_OTP_BASE;
+
+	log("index: 0x%X", index);
+
+	if (index > IMX_OTP_ADDR_MAX) {
+		printf("ERROR: invalid address.\n");
+		ret = -1;
+		goto exit_nop;
+	}
+
+	enable_otp_clk(1);
+
+	if (otp_read_prep()) {
+		ret = -1;
+		printf("ERROR: read preparation failed\n");
+		goto exit_cleanup;
+	}
+
+	if (fuse_read_addr(index, pdata)) {
+		ret = -1;
+		printf("ERROR: read failed\n");
+		goto exit_cleanup;
+	}
+
+	if (*pdata == IMX_OTP_DATA_ERROR_VAL) {
+		ctrl_reg = readl(&otp->ctrl);
+		if (ctrl_reg & BM_OCOTP_CTRL_ERROR) {
+			printf("ERROR: read fuse failed\n");
+			ret = -1;
+		}
+	}
+
+exit_cleanup:
+	enable_otp_clk(0);
+exit_nop:
+	return ret;
+}
+
+#ifdef IMX_OTPWRITE_ENABLED
+/*
+ * blow one u32 to indexed fuse
+ */
+int imx_otp_blow_one_u32(u32 index, u32 data, u32 *pfused_value)
+{
+	int ret = 0;
+	struct iim_regs *otp = (struct iim_regs *)IMX_OTP_BASE;
+
+	enable_otp_clk(1);
+
+	if (otp_blow_prep()) {
+		ret = -1;
+		printf("ERROR: blow preparation failed\n");
+		goto exit_cleanup;
+	}
+
+	if (fuse_blow_addr(index, data)) {
+		ret = -1;
+		printf("ERROR: blow fuse failed\n");
+		goto exit_cleanup;
+	}
+
+	if (otp_blow_post()) {
+		ret = -1;
+		printf("ERROR: blow post operation failed\n");
+		goto exit_cleanup;
+	}
+
+	if (readl(&otp->ctrl) & BM_OCOTP_CTRL_ERROR) {
+		ret = -1;
+		printf("ERROR: OTP control\n");
+		goto exit_cleanup;
+	}
+
+	if (imx_otp_read_one_u32(index, pfused_value)) {
+		ret = -1;
+		printf("ERROR: OTP read\n");
+	}
+
+exit_cleanup:
+	enable_otp_clk(0);
+
+	return ret;
+}
+#endif
diff --git a/drivers/misc/imx_pwm.c b/drivers/misc/imx_pwm.c
new file mode 100644
index 0000000..c7782a1
--- /dev/null
+++ b/drivers/misc/imx_pwm.c
@@ -0,0 +1,121 @@
+/*
+ * Porting to u-boot:
+ * Linux IMX PWM driver
+ *
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/types.h>
+#include <asm/io.h>
+#include <asm/imx-common/imx_pwm.h>
+#include <asm/arch/clock.h>
+#include <common.h>
+#include <div64.h>
+
+#define MX_PWMCR                 0x00    /* PWM Control Register */
+#define MX_PWMSAR                0x0C    /* PWM Sample Register */
+#define MX_PWMPR                 0x10    /* PWM Period Register */
+#define MX_PWMCR_PRESCALER(x)    (((x - 1) & 0xFFF) << 4)
+#define MX_PWMCR_CLKSRC_IPG_HIGH (2 << 16)
+#define MX_PWMCR_CLKSRC_IPG      (1 << 16)
+#define MX_PWMCR_EN              (1 << 0)
+
+#define MX_PWMCR_STOPEN		(1 << 25)
+#define MX_PWMCR_DOZEEN		(1 << 24)
+#define MX_PWMCR_WAITEN		(1 << 23)
+#define MX_PWMCR_DBGEN		(1 << 22)
+#define MX_PWMCR_CLKSRC_IPG	(1 << 16)
+#define MX_PWMCR_CLKSRC_IPG_32k	(3 << 16)
+
+int imx_pwm_config(struct pwm_device pwm, int duty_ns, int period_ns)
+{
+	unsigned long long c;
+	unsigned long period_cycles, duty_cycles, prescale;
+	u32 cr;
+
+	if (period_ns == 0 || duty_ns > period_ns)
+		return -1;
+
+	pwm.mmio_base = pwm.pwm_id ? (unsigned long)IMX_PWM2_BASE:
+				(unsigned long)IMX_PWM1_BASE;
+
+	if (pwm.pwmo_invert)
+		duty_ns = period_ns - duty_ns;
+
+	c = mxc_get_clock(MXC_IPG_PERCLK);
+	c = c * period_ns;
+	do_div(c, 1000000000);
+	period_cycles = c;
+
+	prescale = period_cycles / 0x10000 + 1;
+
+	period_cycles /= prescale;
+	c = (unsigned long long)period_cycles * duty_ns;
+	do_div(c, period_ns);
+	duty_cycles = c;
+
+	writel(duty_cycles, pwm.mmio_base + MX_PWMSAR);
+	writel(period_cycles, pwm.mmio_base + MX_PWMPR);
+
+	cr = MX_PWMCR_PRESCALER(prescale) |
+		MX_PWMCR_STOPEN | MX_PWMCR_DOZEEN |
+		MX_PWMCR_WAITEN | MX_PWMCR_DBGEN;
+
+	cr |= MX_PWMCR_CLKSRC_IPG_HIGH;
+
+	writel(cr, pwm.mmio_base + MX_PWMCR);
+
+	return 0;
+}
+
+int imx_pwm_enable(struct pwm_device pwm)
+{
+	unsigned long reg;
+	int rc = 0;
+
+	if (pwm.enable_pwm_clk)
+		pwm.enable_pwm_clk();
+
+	pwm.mmio_base = pwm.pwm_id ? (unsigned long)IMX_PWM2_BASE:
+				(unsigned long)IMX_PWM1_BASE;
+
+	reg = readl(pwm.mmio_base + MX_PWMCR);
+	reg |= MX_PWMCR_EN;
+	writel(reg, pwm.mmio_base + MX_PWMCR);
+
+	if (pwm.enable_pwm_pad)
+		pwm.enable_pwm_pad();
+
+	return rc;
+}
+
+int imx_pwm_disable(struct pwm_device pwm)
+{
+	if (pwm.disable_pwm_pad)
+		pwm.disable_pwm_pad();
+
+	pwm.mmio_base = pwm.pwm_id ? (unsigned long)IMX_PWM2_BASE:
+				(unsigned long)IMX_PWM1_BASE;
+
+	writel(0, pwm.mmio_base + MX_PWMCR);
+
+	if (pwm.disable_pwm_clk)
+		pwm.disable_pwm_clk();
+
+	return 0;
+}
diff --git a/drivers/mmc/fsl_esdhc.c b/drivers/mmc/fsl_esdhc.c
index b90f3e7..9a3c658 100644
--- a/drivers/mmc/fsl_esdhc.c
+++ b/drivers/mmc/fsl_esdhc.c
@@ -402,6 +402,12 @@ esdhc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
 				return COMM_ERR;
 		} while (!(irqstat & IRQSTAT_TC) &&
 				(esdhc_read32(&regs->prsstat) & PRSSTAT_DLA));
+#ifdef CONFIG_MX6
+		/* In imx6 TC (data end) interrupt sometimes occur earlier
+		   than DMA completes. In this case just wait a little more. */ 
+		while (!(irqstat & (IRQSTAT_DINT | IRQSTAT_DMAE)))
+			irqstat = esdhc_read32(&regs->irqstat);
+#endif
 #endif
 	}
 
diff --git a/drivers/mmc/mxsmmc.c b/drivers/mmc/mxsmmc.c
index a72f66c..e166d20 100644
--- a/drivers/mmc/mxsmmc.c
+++ b/drivers/mmc/mxsmmc.c
@@ -41,7 +41,7 @@
 #include <asm/arch/clock.h>
 #include <asm/arch/imx-regs.h>
 #include <asm/arch/sys_proto.h>
-#include <asm/arch/dma.h>
+#include <asm/imx-common/dma.h>
 #include <bouncebuf.h>
 
 struct mxsmmc_priv {
diff --git a/drivers/mtd/nand/mxs_nand.c b/drivers/mtd/nand/mxs_nand.c
index e38e151..398e4dd 100644
--- a/drivers/mtd/nand/mxs_nand.c
+++ b/drivers/mtd/nand/mxs_nand.c
@@ -34,12 +34,19 @@
 #include <asm/io.h>
 #include <asm/arch/clock.h>
 #include <asm/arch/imx-regs.h>
+#include <asm/imx-common/regs-bch.h>
+#include <asm/imx-common/regs-gpmi.h>
 #include <asm/arch/sys_proto.h>
-#include <asm/arch/dma.h>
+#include <asm/imx-common/dma.h>
 
 #define	MXS_NAND_DMA_DESCRIPTOR_COUNT		4
 
 #define	MXS_NAND_CHUNK_DATA_CHUNK_SIZE		512
+#if defined(CONFIG_MX6)
+#define	MXS_NAND_CHUNK_DATA_CHUNK_SIZE_SHIFT	2
+#else
+#define	MXS_NAND_CHUNK_DATA_CHUNK_SIZE_SHIFT	0
+#endif
 #define	MXS_NAND_METADATA_SIZE			10
 
 #define	MXS_NAND_COMMAND_BUFFER_SIZE		32
@@ -980,14 +987,16 @@ static int mxs_nand_scan_bbt(struct mtd_info *mtd)
 	tmp |= MXS_NAND_METADATA_SIZE << BCH_FLASHLAYOUT0_META_SIZE_OFFSET;
 	tmp |= (mxs_nand_get_ecc_strength(mtd->writesize, mtd->oobsize) >> 1)
 		<< BCH_FLASHLAYOUT0_ECC0_OFFSET;
-	tmp |= MXS_NAND_CHUNK_DATA_CHUNK_SIZE;
+	tmp |= MXS_NAND_CHUNK_DATA_CHUNK_SIZE
+		>> MXS_NAND_CHUNK_DATA_CHUNK_SIZE_SHIFT;
 	writel(tmp, &bch_regs->hw_bch_flash0layout0);
 
 	tmp = (mtd->writesize + mtd->oobsize)
 		<< BCH_FLASHLAYOUT1_PAGE_SIZE_OFFSET;
 	tmp |= (mxs_nand_get_ecc_strength(mtd->writesize, mtd->oobsize) >> 1)
 		<< BCH_FLASHLAYOUT1_ECCN_OFFSET;
-	tmp |= MXS_NAND_CHUNK_DATA_CHUNK_SIZE;
+	tmp |= MXS_NAND_CHUNK_DATA_CHUNK_SIZE
+		>> MXS_NAND_CHUNK_DATA_CHUNK_SIZE_SHIFT;
 	writel(tmp, &bch_regs->hw_bch_flash0layout1);
 
 	/* Set *all* chip selects to use layout 0 */
diff --git a/drivers/mtd/spi/Makefile b/drivers/mtd/spi/Makefile
index 90f8392..6812de3 100644
--- a/drivers/mtd/spi/Makefile
+++ b/drivers/mtd/spi/Makefile
@@ -30,6 +30,7 @@ COBJS-$(CONFIG_SPL_SPI_LOAD)	+= spi_spl_load.o
 endif
 
 COBJS-$(CONFIG_SPI_FLASH)	+= spi_flash.o
+COBJS-$(CONFIG_SPI_FLASH_MTD)	+= spi_flash_mtd.o
 COBJS-$(CONFIG_SPI_FLASH_ATMEL)	+= atmel.o
 COBJS-$(CONFIG_SPI_FLASH_EON)	+= eon.o
 COBJS-$(CONFIG_SPI_FLASH_MACRONIX)	+= macronix.o
diff --git a/drivers/mtd/spi/spi_flash.c b/drivers/mtd/spi/spi_flash.c
index 00aece9..207612a 100644
--- a/drivers/mtd/spi/spi_flash.c
+++ b/drivers/mtd/spi/spi_flash.c
@@ -221,6 +221,7 @@ int spi_flash_cmd_erase(struct spi_flash *flash, u32 offset, size_t len)
 
 		debug("SF: erase %2x %2x %2x %2x (%x)\n", cmd[0], cmd[1],
 		      cmd[2], cmd[3], offset);
+printf("SF: erase block:%2x (%x)\n", cmd[1], offset);
 
 		ret = spi_flash_cmd_write_enable(flash);
 		if (ret)
@@ -389,6 +390,10 @@ struct spi_flash *spi_flash_probe(unsigned int bus, unsigned int cs,
 	print_size(flash->sector_size, ", total ");
 	print_size(flash->size, "\n");
 
+#ifdef CONFIG_SPI_FLASH_MTD
+	spi_flash_mtd_init(flash);
+#endif
+
 	spi_release_bus(spi);
 
 	return flash;
diff --git a/drivers/mtd/spi/spi_flash_internal.h b/drivers/mtd/spi/spi_flash_internal.h
index 141cfa8..c0e441e 100644
--- a/drivers/mtd/spi/spi_flash_internal.h
+++ b/drivers/mtd/spi/spi_flash_internal.h
@@ -97,6 +97,9 @@ int spi_flash_cmd_wait_ready(struct spi_flash *flash, unsigned long timeout);
 /* Erase sectors. */
 int spi_flash_cmd_erase(struct spi_flash *flash, u32 offset, size_t len);
 
+/* SPI flash MTD adapter init */
+int spi_flash_mtd_init(struct spi_flash *flash);
+
 /* Manufacturer-specific probe functions */
 struct spi_flash *spi_flash_probe_spansion(struct spi_slave *spi, u8 *idcode);
 struct spi_flash *spi_flash_probe_atmel(struct spi_slave *spi, u8 *idcode);
diff --git a/drivers/mtd/spi/spi_flash_mtd.c b/drivers/mtd/spi/spi_flash_mtd.c
new file mode 100644
index 0000000..5fac974
--- /dev/null
+++ b/drivers/mtd/spi/spi_flash_mtd.c
@@ -0,0 +1,101 @@
+/*
+ * (C) Copyright 2012 Daniel Schwierzeck, daniel.schwierzeck@gmail.com
+ *
+ * MTD layer driver for SPI flash devices
+ *
+ * This file is released under the terms of GPL v2 and any later version.
+ * See the file COPYING in the root directory of the source tree for details.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <asm/errno.h>
+#include <linux/mtd/mtd.h>
+#include <spi_flash.h>
+
+static struct mtd_info sf_mtd_info;
+static char sf_mtd_name[8];
+
+static int spi_flash_mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct spi_flash *flash = mtd->priv;
+	int err;
+
+	instr->state = MTD_ERASING;
+
+	err = spi_flash_erase(flash, instr->addr, instr->len);
+	if (err) {
+		instr->state = MTD_ERASE_FAILED;
+		instr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
+		return -EIO;
+	}
+
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+
+	return 0;
+}
+
+static int spi_flash_mtd_read(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, u_char *buf)
+{
+	struct spi_flash *flash = mtd->priv;
+	int err;
+
+	err = spi_flash_read(flash, from, len, buf);
+	if (!err)
+		*retlen = len;
+
+	return err;
+}
+
+static int spi_flash_mtd_write(struct mtd_info *mtd, loff_t to, size_t len,
+	size_t *retlen, const u_char *buf)
+{
+	struct spi_flash *flash = mtd->priv;
+	int err;
+
+	err = spi_flash_write(flash, to, len, buf);
+	if (!err)
+		*retlen = len;
+
+	return err;
+}
+
+static void spi_flash_mtd_sync(struct mtd_info *mtd)
+{
+}
+
+static int spi_flash_mtd_number(void)
+{
+#ifdef CONFIG_SYS_MAX_FLASH_BANKS
+	return CONFIG_SYS_MAX_FLASH_BANKS;
+#else
+	return 0;
+#endif
+}
+
+int spi_flash_mtd_init(struct spi_flash *flash)
+{
+	memset(&sf_mtd_info, 0, sizeof(sf_mtd_info));
+	sprintf(sf_mtd_name, "nor%d", spi_flash_mtd_number());
+
+	sf_mtd_info.name = sf_mtd_name;
+	sf_mtd_info.type = MTD_NORFLASH;
+	sf_mtd_info.flags = MTD_CAP_NORFLASH;
+	sf_mtd_info.writesize = 1;
+
+	sf_mtd_info.erase = spi_flash_mtd_erase;
+	sf_mtd_info.read = spi_flash_mtd_read;
+	sf_mtd_info.write = spi_flash_mtd_write;
+	sf_mtd_info.sync = spi_flash_mtd_sync;
+
+	sf_mtd_info.size = flash->size;
+	sf_mtd_info.priv = flash;
+
+	/* Only uniform flash devices for now */
+	sf_mtd_info.numeraseregions = 0;
+	sf_mtd_info.erasesize = flash->sector_size;
+
+	return add_mtd_device(&sf_mtd_info);
+}
diff --git a/drivers/mtd/spi/winbond.c b/drivers/mtd/spi/winbond.c
index 4418302..ac59d2e 100644
--- a/drivers/mtd/spi/winbond.c
+++ b/drivers/mtd/spi/winbond.c
@@ -63,6 +63,11 @@ static const struct winbond_spi_flash_params winbond_spi_flash_table[] = {
 		.name			= "W25Q128",
 	},
 	{
+		.id			= 0x4019,
+		.nr_blocks		= 512,
+		.name			= "W25Q256",
+	},
+	{
 		.id			= 0x5014,
 		.nr_blocks		= 128,
 		.name			= "W25Q80",
@@ -105,7 +110,11 @@ struct spi_flash *spi_flash_probe_winbond(struct spi_slave *spi, u8 *idcode)
 	flash->erase = spi_flash_cmd_erase;
 	flash->read = spi_flash_cmd_read_fast;
 	flash->page_size = 256;
+#if defined(CONFIG_SPI_FLASH_WINBOND_ERASESIZE)
+	flash->sector_size = CONFIG_SPI_FLASH_WINBOND_ERASESIZE;
+#else
 	flash->sector_size = 4096;
+#endif
 	flash->size = 4096 * 16 * params->nr_blocks;
 
 	return flash;
diff --git a/drivers/spi/mxs_spi.c b/drivers/spi/mxs_spi.c
index bb865b7..e47ace1 100644
--- a/drivers/spi/mxs_spi.c
+++ b/drivers/spi/mxs_spi.c
@@ -31,7 +31,7 @@
 #include <asm/arch/clock.h>
 #include <asm/arch/imx-regs.h>
 #include <asm/arch/sys_proto.h>
-#include <asm/arch/dma.h>
+#include <asm/imx-common/dma.h>
 
 #define	MXS_SPI_MAX_TIMEOUT	1000000
 #define	MXS_SPI_PORT_OFFSET	0x2000
diff --git a/include/configs/gw_ventana.h b/include/configs/gw_ventana.h
new file mode 100644
index 0000000..cfb23aa
--- /dev/null
+++ b/include/configs/gw_ventana.h
@@ -0,0 +1,335 @@
+/*
+ * Copyright (C) 2013 Gateworks Corporation
+ *
+ * Configuration settings for the Freescale i.MX6Q Sabre Lite board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.		See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/**
+ * Gateworks Ventana board config - NAND based boot device
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_MX6
+#define CONFIG_MX6Q              /* i.MX6Q CPU */
+#define CONFIG_DISPLAY_CPUINFO   /* display cpu info */
+#define CONFIG_DISPLAY_BOARDINFO /* display board info */
+
+#define CONFIG_MACH_TYPE	4520   /* Gateworks Ventana Platform */
+
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+/* ATAGs */
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_SERIAL_TAG
+#define CONFIG_REVISION_TAG
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(10 * 1024 * 1024)
+
+/* Init Functions */
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_MISC_INIT_R
+
+/* GPIO */
+#define CONFIG_MXC_GPIO
+
+/* Serial */
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE	       UART2_BASE
+
+/* I2C Configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		          100000
+
+/* OCOTP Configs */
+#define CONFIG_CMD_IMXOTP
+#ifdef CONFIG_CMD_IMXOTP
+  #define CONFIG_IMX_OTP
+  #define IMX_OTP_BASE            OCOTP_BASE_ADDR
+  #define IMX_OTP_ADDR_MAX        0x7F
+  #define IMX_OTP_DATA_ERROR_VAL  0xBADABADA
+  #define IMX_OTPWRITE_ENABLED
+#endif
+
+/* PWM Configs */
+#define CONFIG_IMX_PWM
+#define IMX_PWM1_BASE    PWM1_BASE_ADDR
+#define IMX_PWM2_BASE    PWM2_BASE_ADDR
+#define IMX_PWM3_BASE    PWM3_BASE_ADDR
+#define IMX_PWM4_BASE    PWM4_BASE_ADDR
+
+/* MMC Configs */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR      0
+#define CONFIG_SYS_FSL_USDHC_NUM       1
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_BOUNCE_BUFFER
+
+/* Filesystem support */
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_UBIFS
+#define CONFIG_DOS_PARTITION
+
+/*
+ * SATA Configs
+ */
+#define CONFIG_CMD_SATA
+#ifdef CONFIG_CMD_SATA
+  #define CONFIG_DWC_AHSATA
+  #define CONFIG_SYS_SATA_MAX_DEVICE	1
+  #define CONFIG_DWC_AHSATA_PORT_ID	0
+  #define CONFIG_DWC_AHSATA_BASE_ADDR	SATA_ARB_BASE_ADDR
+  #define CONFIG_LBA48
+  #define CONFIG_LIBATA
+#endif
+
+/* Various command support */
+#include <config_cmd_default.h>
+#undef CONFIG_CMD_IMLS
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_BMODE         /* set eFUSE shadow for a boot dev and reset */
+#define CONFIG_CMD_HDMIDETECT    /* detect HDMI output device */
+#define CONFIG_CMD_SETEXPR
+#define CONFIG_CMD_BOOTZ
+#define CONFIG_CMD_GSC
+#define CONFIG_CMD_UBI
+#define CONFIG_RBTREE
+#define CONFIG_LZO
+
+/* Ethernet support */
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE             ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE      RGMII
+#define CONFIG_ETHPRIME          "FEC"
+#define CONFIG_FEC_MXC_PHYADDR   0
+#define CONFIG_PHYLIB
+#define CONFIG_ARP_TIMEOUT       200UL
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_USB_ETHER_SMSC95XX
+#define CONFIG_MXC_USB_PORT       1
+#define CONFIG_MXC_USB_PORTSC     (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS      0
+
+/* Framebuffer and LCD */
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_IPUV3
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_IPUV3_CLK          260000000
+
+/* serial console (ttymxc1,115200) */
+#define CONFIG_CONS_INDEX         1
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT	             "Ventana > "
+#define CONFIG_SYS_CBSIZE	             512
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_HWCONFIG
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS	       16
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+/* Memory configuration */
+#define CONFIG_SYS_MEMTEST_START       0x10000000
+#define CONFIG_SYS_MEMTEST_END	       0x10010000
+#define CONFIG_SYS_TEXT_BASE	         0x17800000
+#define CONFIG_SYS_LOAD_ADDR           0x10800000
+#define CONFIG_SYS_HZ                  1000
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS           1
+#define PHYS_SDRAM                     MMDC0_ARB_BASE_ADDR
+#define PHYS_SDRAM_SIZE                (1u * 1024 * 1024 * 1024)
+
+#define CONFIG_SYS_SDRAM_BASE          PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR       IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE       IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+       (CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+       (CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH  /* no NOR flash */
+
+/*
+ * MTD Command for mtdparts
+ */
+#define CONFIG_CMD_MTDPARTS
+#define CONFIG_MTD_DEVICE
+//#define CONFIG_FLASH_CFI_MTD
+#define CONFIG_MTD_PARTITIONS
+#define MTDIDS_DEFAULT    "nand0=nand"
+#define MTDPARTS_DEFAULT  "mtdparts=nand:16m(uboot),1m(env),-(rootfs)"
+
+/* Enable NAND support */
+#define CONFIG_CMD_TIME
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+#ifdef CONFIG_CMD_NAND
+  #define CONFIG_NAND_MXS
+  #define CONFIG_SYS_MAX_NAND_DEVICE	1
+  #define CONFIG_SYS_NAND_BASE		0x40000000
+  #define CONFIG_SYS_NAND_5_ADDR_CYCLE
+  #define CONFIG_SYS_NAND_ONFI_DETECTION
+
+  /* DMA stuff, needed for GPMI/MXS NAND support */
+  #define CONFIG_APBH_DMA
+  #define CONFIG_APBH_DMA_BURST
+  #define CONFIG_APBH_DMA_BURST8
+#endif
+
+/* Persistent Environment Config */
+#define CONFIG_ENV_OVERWRITE    /* allow to overwrite serial and ethaddr */
+//#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_ENV_IS_IN_NAND
+#if defined(CONFIG_ENV_IS_IN_MMC)
+  #define CONFIG_ENV_OFFSET              (6 * 64 * 1024)
+  #define CONFIG_ENV_SIZE                (8 * 1024)
+  #define CONFIG_SYS_MMC_ENV_DEV         0
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+  #define CONFIG_ENV_OFFSET              (16 << 20)
+  #define CONFIG_ENV_SECT_SIZE           (128 << 10)
+  #define CONFIG_ENV_SIZE                CONFIG_ENV_SECT_SIZE
+  #define CONFIG_ENV_OFFSET_REDUND       (CONFIG_ENV_OFFSET + (512 << 10))
+  #define CONFIG_ENV_SIZE_REDUND         CONFIG_ENV_SIZE
+#endif
+
+/* Environment */
+#define CONFIG_BAUDRATE           115200
+#define CONFIG_BOOTDELAY          3
+#define CONFIG_LOADADDR           CONFIG_SYS_LOAD_ADDR
+#define CONFIG_IPADDR             192.168.1.1
+#define CONFIG_SERVERIP           192.168.1.146
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"script=boot/6x_bootscript-ventana\0" \
+	"uimage=boot/uImage\0" \
+	"console=ttymxc1\0" \
+	"fdt_high=0xffffffff\0" \
+	"fdt_addr=0x11000000\0" \
+	"hwconfig=rs232;" \
+		"dio0:mode=gpio;dio1:mode=gpio;dio2:mode=gpio;dio3:mode=gpio\0" \
+	"video=\0" \
+	"image_rootfs=openwrt-imx61-root.ubi\0" \
+	\
+	"mtdparts=" MTDPARTS_DEFAULT "\0" \
+	"mtdids=" MTDIDS_DEFAULT "\0" \
+	\
+	"nand_loadfdt=" \
+		"if ubifsload ${fdt_addr} boot/${fdt_file}; then " \
+			"echo Loaded DTB from boot/${fdt_file}; " \
+		"else " \
+			"if ubifsload ${fdt_addr} boot/${fdt_file1}; then " \
+				"echo Loaded DTB from boot/${fdt_file1}; " \
+			"else " \
+				"if ubifsload ${fdt_addr} boot/${fdt_file2}; then " \
+					"echo Loaded DTB from boot/${fdt_file2}; " \
+				"fi; " \
+			"fi; " \
+		"fi\0" \
+	\
+	"nand_boot=" \
+		"ubi part rootfs && ubifsmount ubi0:rootfs; " \
+		"run nand_loadfdt && fdt addr ${fdt_addr} && fdt boardsetup; " \
+		"if ubifsload ${loadaddr} ${uimage}; then " \
+			"echo Booting from NAND flashs...; " \
+			"ubifsumount; " \
+			"setenv bootargs console=${console},${baudrate} " \
+				"root=ubi0:rootfs ubi.mtd=2 rootfstype=ubifs ${video} ${extra}; " \
+			"bootm ${loadaddr} - ${fdt_addr}; " \
+		"fi\0" \
+	"nand_update=echo Updating NAND from ${serverip}:${image_rootfs} ...; " \
+		"tftp ${loadaddr} ${image_rootfs} && " \
+		"nand erase.part rootfs && " \
+		"nand write ${loadaddr} rootfs ${filesize}\0" \
+	\
+	"mmc_root=/dev/mmcblk0p1 rootfstype=ext4 rootwait rw\0" \
+	"mmc_loaduimage=ext2load mmc 0:1 ${loadaddr} ${uimage}\0" \
+	"mmc_loadfdt=" \
+		"if ext2load mmc 0:1 ${fdt_addr} boot/${fdt_file}; then " \
+			"echo Loaded DTB from boot/${fdt_file}; " \
+		"else " \
+			"if ext2load mmc 0:1 ${fdt_addr} boot/${fdt_file1}; then " \
+				"echo Loaded DTB from boot/${fdt_file1}; " \
+			"else " \
+				"if ext2load mmc 0:1 ${fdt_addr} boot/${fdt_file2}; then " \
+					"echo Loaded DTB from boot/${fdt_file2}; " \
+				"fi; " \
+			"fi; " \
+		"fi\0" \
+	"mmc_boot=mmc dev 0 && mmc rescan && " \
+		"if ext2load mmc 0:1 ${loadaddr} ${script}; then " \
+			"source; " \
+		"else " \
+			"ext2load mmc 0:1 ${loadaddr} ${uimage} && " \
+			"echo 'Booting from mmc...'; "\
+			"setenv bootargs console=${console},${baudrate} " \
+				"root=/dev/mmcblk0p1 rootfstype=ext4 rootwait rw ${video} ${extra}; " \
+			"if run mmc_loadfdt && fdt addr ${fdt_addr} && fdt boardsetup; then " \
+				"bootm ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"bootm; " \
+			"fi; " \
+		"fi\0"
+
+#define CONFIG_BOOTCOMMAND "if run mmc_boot; then; else run nand_boot; fi"
+
+/* Device Tree Support */
+#define CONFIG_OF_BOARD_SETUP
+#define CONFIG_OF_LIBFDT
+#define CONFIG_FDT_FIXUP_PARTITIONS
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+  #define CONFIG_CMD_CACHE
+#endif
+
+#endif			       /* __CONFIG_H */
diff --git a/include/configs/mx6qsabrelite.h b/include/configs/mx6qsabrelite.h
index 752f098..058de75 100644
--- a/include/configs/mx6qsabrelite.h
+++ b/include/configs/mx6qsabrelite.h
@@ -118,8 +118,9 @@
 #define CONFIG_MXC_USB_PORTSC	(PORT_PTS_UTMI | PORT_PTS_PTW)
 #define CONFIG_MXC_USB_FLAGS	0
 
-/* Miscellaneous commands */
+/* imx6 commands */
 #define CONFIG_CMD_BMODE
+#define CONFIG_CMD_HDMIDETECT
 
 /* Framebuffer and LCD */
 #define CONFIG_VIDEO
diff --git a/spl/Makefile b/spl/Makefile
index 101d478..b8fc203 100644
--- a/spl/Makefile
+++ b/spl/Makefile
@@ -92,6 +92,10 @@ LIBS-y += arch/$(ARCH)/cpu/tegra-common/libcputegra-common.o
 LIBS-y += $(CPUDIR)/tegra-common/libtegra-common.o
 endif
 
+ifneq ($(CONFIG_MX23),)
+LIBS-y += arch/$(ARCH)/imx-common/libimx-common.o
+endif
+
 # Add GCC lib
 ifeq ("$(USE_PRIVATE_LIBGCC)", "yes")
 PLATFORM_LIBGCC = $(SPLTREE)/arch/$(ARCH)/lib/libgcc.o
